{"noir_version":"0.31.0+6936a52bb4de2170b6e4c41afd9cf4327d4fbeb1","hash":2764793201242994183,"abi":{"parameters":[{"name":"x","type":{"kind":"array","length":44,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"1d3dalVXFMXxdznXoew5xtrrw1cppaQaS0ASMbFQxHfvsSZaaRrpv4eeOe+M2QvXxWCM8NN9/HB4dfXL+19/vr55fXt3ePHjh8Ob25eX99e3N8evPhxa+/P37t5e3nz68u7+8t394UXva14crm5eHX851D9eHF5fv7k6vNi3jxd/e3jf9/Hw8L5PPf+wZ/fDw55j/vXhny4ObU91m57qNiPVbWaq26xMt9m3VLeJVLdRqts41W1SdfGeqov3VF28p+riPVUX76m6uKfq4p6qi3uqLu6purin6uKeqot7qi7uqbq4p+rinqqLR6ouHqm6eKTq4pGqi0eqLh6punik6uKRqotHqi4eqbp4purimaqLZ6ounqm6eKbq4pmqi2eqLp6punim6uKZqotXqi5eqbp4perilaqLV6ouXqm6eKXq4pWqi1eqLl6puji2VGUcW6o2ji1VHceWqo9jS1XIsaVq5NhSVXJsqTo5tlSlHFuuVo5crRy5WjlytXLkauXI1cqRq5UjVytHrlaOXK0cuVpZuVpZuVpZuVpZuVpZuVpZuVpZuVpZuVpZuVpZuVrZuVrZuVrZuVrZuVrZuVrZuVrZuVrZuVrZuVrZuVq55WrllquVW65WbrlaOddLepHrLb3I9Zpe5HpPL3K9qBeneFOve3u8Tt/j+YfXjIdnj3+V5i/PSk88e5yM/vhw8zcPf7r6KV7rO9fVo+7VVffqrnv1Vvfqe92r97pXH3WvPuteve6a9rpr2uuuaa+7pr3ump7iZdJzXb3umva6a9rrrmmvu6a97pqOums66q7pqLumo+6anuJ14HNdve6ajrprOuqu6ai7pqPums66azrrrumsu6az7pqe4oXuc1297prOums6667prLums+6arrpruuqu6aq7pqvump7ilfxzXb3umq66a7rqrumqu6ar7JpqK7um2squqbaya6qt7JpqK7um2squqbaya6qt7JpqK7um2uquadRd06i7plF3TaPump7gczD6trXHh7e1Pf/w828C6ASfg3HS6/Rc1xm5rvPf16m7Pf4J3b39f7FfZa9+gs/XONvVo+7VVffqrnv1Vvfqe92r97pXH3WvXndNVXdNXXdNXXdNXXdNXXdNT/A5Lme7et01dd01dd01dd01dd01bXXXtNVd01Z3TVvdNT3B5++c7ep117TVXdNWd01b3TVtddd0r7ume9013euu6V53TU/w2UJnu/pe9+p113Svu6Z73TXd665pr7umve6a9rpr2uuu6Qk+W+hsV396TYf7l6t/+8+jPh/64emf878eG/3rKX859fSP2N89FeiU0CmjUw2d2tGpjk4NdGqiUygbHWWjo2x0lI2OstFRNjrKRkfZ6CgbHWWjo2wMlI2BsjFQNgbKxkDZGCgbA2VjoGwMlI2BsjFRNibKxkTZmCgbE2VjomxMlI2JsjFRNibKxkLZWCgbC2VjoWwslI2FsrFQNhbKxkLZWCgb//C/TH//WLBjYsfMjjV2bGfHOjs22LHJjrGUBEtJsJQES0mwlARLSbCUBEtJsJQES0mwlIilRCwlYikRS4lYSsRSIpYSsZSIpUQsJWYpMUuJWUrMUmKWErOUmKXELCVmKTFLSWMpaSwljaWksZQ0lpLGUtJYShpLSWMpYZIajFKDWWowTA2mqcE4NZinBgPVYKIajFSDmWowVA2mqsFYNZirBoPVYLIajFaD2WowXA2mq8F4NZivBgPWYMIajFiDGWswZA2mrMGYNZizBoPWYNIajFqDWWswbA2mrcG4NZi3BgPXYOIajFyDmWswdA2mrsHYNZi7BoPXYPIajF6D2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmL2K2auYvYrZq5i9itmrmb2a2auZvZrZq5m9mtmrmb2a2auZvZrZq5m9mtmrmb2a2auZvZrZq5m9mtmrmb2a2auZvZrZq5m9mtmrmb2a2auZvZrZq5m9mtmrmb2a2auZvZrZq5m9mtmrmb2a2auZvZrZq5m9mtmrmb2a2auZvZrZq5m9mtmrmb2a2auZvZrZq5m9mtmrmb2a2auZvZrZq5m9mtmrmb2a2auZvZrZq5m9mtmrmb3639rr8YvfLt9dX/7y5urueODT997fvLy/vr15+PL+97efv3N89g8=","file_map":{"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"30":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\nmod runtime;\nmod meta;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"50":{"source":"\n// ### METHOD 1. Lookup table is local variable. lookup cost is extremely expensive\n// N.B. if I make BASE64_DECODE_BE a `global` variable we get the same cost\nfn base64_decode_without_struct<let InputElements: u64, let OutputBytes: u64>(input: [u8; InputElements]) -> [u8; OutputBytes] {\n    let BASE64_DECODE_BE: [Field; 128] = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0-9\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 10-19\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 20-29\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 30-39\n        0, 0, 0,// 40-42\n        62,// 43\n        0, 0, 0,// 44-46\n        63,// 47\n        52, 53, 54, 55, 56, 57, 58, 59, 60, 61,// 48-57\n        0, 0, 0, 0, 0, 0, 0,// 58-64\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,// 65-90 (A-Z)\n        0, 0, 0, 0, 0, 0,// 91-96\n        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,// 97-122 (a-z)\n        0, 0, 0, 0, 0// 123-127\n    ];\n\n    // 240 bits fits 40 6-bit chunks and 30 8-bit chunks\n    // we pack 40 base64 values into a field element and convert into 30 bytes\n    // TODO: once we support arithmetic ops on generics, derive OutputBytes from InputBytes\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let BASE64_ELEMENTS_PER_CHUNK: u64 = 40;\n    let BYTES_PER_CHUNK: u64 = 30;\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u64;\n\n    for i in 0..num_chunks - 1 {\n        let mut slice: Field = 0;\n        for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n            let idx = input[i * BASE64_ELEMENTS_PER_CHUNK + j] as Field;\n            slice += BASE64_DECODE_BE[idx];\n        }\n        let slice_bytes: [u8; 30] = slice.to_be_bytes(30).as_array();\n        for j in 0..BYTES_PER_CHUNK {\n            result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n        }\n    }\n\n    let base64_elements_in_final_chunk = InputElements - ((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK);\n\n    let mut slice: Field = 0;\n    for j in 0..base64_elements_in_final_chunk {\n        slice *= 64;\n        slice += BASE64_DECODE_BE[input[(num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK + j] as Field];\n    }\n    for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n        slice *= 64;\n    }\n\n    // TODO: check is it cheaper to use a constant value in `to_be_bytes` or can we use `bytes_in_final_chunk`?\n    let slice_bytes: [u8; 30] = slice.to_be_bytes(30).as_array();\n    let num_bytes_in_final_chunk = OutputBytes - ((num_chunks - 1) * BYTES_PER_CHUNK);\n    for i in 0..num_bytes_in_final_chunk {\n        result[(num_chunks - 1) * BYTES_PER_CHUNK + i] = slice_bytes[i];\n    }\n    result\n}\n\n// #### METHOD 2. When lookup table is in a struct, lookups are much cheaper and ROM table is used in backend\nstruct Lookup {\n    table: [Field; 128]\n}\nimpl Lookup {\n    fn new() -> Self {\n        Lookup {\n            table: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0-9\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 10-19\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 20-29\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 30-39\n                0, 0, 0,// 40-42\n                62,// 43\n                0, 0, 0,// 44-46\n                63,// 47\n                52, 53, 54, 55, 56, 57, 58, 59, 60, 61,// 48-57\n                0, 0, 0, 0, 0, 0, 0,// 58-64\n                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,// 65-90 (A-Z)\n                0, 0, 0, 0, 0, 0,// 91-96\n                26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,// 97-122 (a-z)\n                0, 0, 0, 0, 0// 123-127\n            ]\n        }\n    }\n\n    fn get(self, idx: Field) -> Field {\n        self.table[idx]\n    }\n}\n\nfn base64_decode_with_struct<let InputElements: u64, let OutputBytes: u64>(input: [u8; InputElements]) -> [u8; OutputBytes] {\n    // let BASE64_DECODE_BE: [u8; 128] = [\n    //     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0-9\n    //     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 10-19\n    //     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 20-29\n    //     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 30-39\n    //     0, 0, 0,// 40-42\n    //     62,// 43\n    //     0, 0, 0,// 44-46\n    //     63,// 47\n    //     52, 53, 54, 55, 56, 57, 58, 59, 60, 61,// 48-57\n    //     0, 0, 0, 0, 0, 0, 0,// 58-64\n    //     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,// 65-90 (A-Z)\n    //     0, 0, 0, 0, 0, 0,// 91-96\n    //     26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,// 97-122 (a-z)\n    //     0, 0, 0, 0, 0// 123-127\n    // ];\n    let mut BASE64_DECODE_BE = Lookup::new();\n\n    // 240 bits fits 40 6-bit chunks and 30 8-bit chunks\n    // we pack 40 base64 values into a field element and convert into 30 bytes\n    // TODO: once we support arithmetic ops on generics, derive OutputBytes from InputBytes\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let BASE64_ELEMENTS_PER_CHUNK: u64 = 40;\n    let BYTES_PER_CHUNK: u64 = 30;\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u64;\n\n    for i in 0..num_chunks - 1 {\n        let mut slice: Field = 0;\n        for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n            let idx = input[i * BASE64_ELEMENTS_PER_CHUNK + j] as Field;\n            slice += BASE64_DECODE_BE.get(idx);\n        }\n        let slice_bytes: [u8; 30] = slice.to_be_bytes(30).as_array();\n        for j in 0..BYTES_PER_CHUNK {\n            result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n        }\n    }\n\n    let base64_elements_in_final_chunk = InputElements - ((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK);\n\n    let mut slice: Field = 0;\n    for j in 0..base64_elements_in_final_chunk {\n        slice *= 64;\n        slice += BASE64_DECODE_BE.get(input[(num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK + j] as Field);\n    }\n    for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n        slice *= 64;\n    }\n\n    // TODO: check is it cheaper to use a constant value in `to_be_bytes` or can we use `bytes_in_final_chunk`?\n    let slice_bytes: [u8; 30] = slice.to_be_bytes(30).as_array();\n    let num_bytes_in_final_chunk = OutputBytes - ((num_chunks - 1) * BYTES_PER_CHUNK);\n    for i in 0..num_bytes_in_final_chunk {\n        result[(num_chunks - 1) * BYTES_PER_CHUNK + i] = slice_bytes[i];\n    }\n    result\n}\n\n// to measure, run `info.sh`\nfn main(x: [u8; 44]) {\n    for i in 0..1 {\n        let r: [u8; 32] = base64_decode_with_struct(x);\n        println(f\"{r}\");\n    }\n}\n\n// to measure. rename this to `main` and run `info.sh`\nfn main_expensive(x: [u8; 44]) {\n    for i in 0..1 {\n        let r: [u8; 32] = base64_decode_without_struct(x);\n        println(f\"{r}\");\n    }\n}\n\n#[test]\nfn test_bodyhash_base64_decode1() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103,\n        119, 76, 105, 121, 112,\n        110, 86, 114, 69, 50,\n        67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87,\n        84, 107, 65, 104, 83,\n        90, 53, 43, 87, 69,\n        82, 104, 75, 104, 88,\n        116, 108, 85, 61\n    ];\n    let res: [u8; 32] = base64_decode_with_struct(input);\n    println(f\"DECODED = {res}\");\n    let expected_res: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172,\n        77, 130, 209, 39, 248, 203, 56, 92, 89, 57,\n        0, 133, 38, 121, 249, 97, 17, 132, 168, 87,\n        182, 85\n    ];\n    assert(res == expected_res);\n}\n","path":"/Users/zac/noir_base64/src/main.nr"}},"names":["main"]}