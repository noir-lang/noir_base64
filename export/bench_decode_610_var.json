{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":3240888534286707074,"abi":{"parameters":[{"name":"input","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":816,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":610,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5634341720269277520":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"10786350277216215763":{"error_kind":"string","string":"base64 encoded strings must be a multiple of 4 bytes"},"14282763056172254502":{"error_kind":"string","string":"if first byte contains padding so must the second"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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sjvVsmtv2Z1m2Z1u2Z1h2Z1p2Z1l2Z1t2Z1j2Z1r2Z1n2Z1v2V1g2V1o2V1k2V1s2V1i2V1q2V1m2V1u2V1h2V1p2V1l2V1t2V1j2V1r2V1n2V1v2SUtu5Rll2fZpS27jGWXtexusOxutOxusuxutuxusexutexus+xut+zusOzutOzusuzutuzusezutezus+zut+wesOwetOwesuwetuwesewetewes+wet+yesOyetOyesuyetuyeseyeteyes+yet+xesOxetOxesuxetuxesexetexes+xet+zesOzetOzesuzetuzesezetezes+zet+w6WHYdLbtOll1ny66LZdfVsutm2XW37HpYdj0tu16WXW/Lro9l19ey62fZ9bfsBlh2Ay27QZbdYMtuiGU31LIbZtkNt+xGWHYjLbtRlt1oy26MZTfWshtn2Y237CZYdhMtu0mW3WTLboplN9Wym2bZTbfsZlh2My27WZbdbMtujmU317KbZ9l9YNl9aNl9ZNl9bNl9YtnNt+wWWHYLLbtPLbvPLLvPLbsvLLsvLbuvLLtFlt1iy26JZbfUsltm2S237L627FZYdistu1WW3WrL7hvLbo1lt9ayW2fZrbfsvrXsNlh2Gy27TZbdd5bd95bdD5bdZstui2W31bLbZtltt+x2WHY7Lbtdlt1uy+5Hy+4ny26PZfezZfeLZbfXsvvVsttn2f1m2f1u2f1h2e237PT/+PuugGVX0LIrZNkVtuyKWHZFLbtill1xy66EZVfSsitl2ZW27MpYdmUtu3KWXXnLroJlV9Gyq2TZVbbsqlh2VS27apZddcuuhmVX07KrZdnVtuzqWHZ1Lbt6ll19y66BZdfQsmtk2TW27JpYdk0tu2aWXXPLroVl19Kya2XZtbbs2lh2bS27dpZdQP2P+t5//ty9/ip44L/m/+2vXwUO/PeEA/8NuH35wLMCVBoLCNBYUIDGQgI0FhagsYgAjUUFaCwmQGNxARpLCNBYUoDGUgI0lhagsYwAjWUFaCwnQGN5ARorCNBYUYDGSgI0VhagsYoAjVUFaKwmQGN1ARprCNBYU4DGWgI01hagsY4AjXUFaKwnQGN9ARobCNDYUIDGRgI0NhagsYkAjU0FaGwmQGNzARpbCNDYUoDGVgI0thagsY0AjW0FaGwnQGNAgEZfgMagAI0hARrDAjRG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","debug_symbols":"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iI2jO51EbBze6SRiU5gS+0X+hpWxKUyJHd3pJGNTmBI7vNNJxKYwJXZ0p5OKDbzT6T426E4nGZvClNjhnU4iNoUpsaM7nWRsClNiR3c6ydgUpsQO73S6jw2600nFBt3pJGNTmBI7utNJxqYwJXZ4p5OITWFK7OhOJxmbypQY3emkYoPudFKxgXc6idhUpsToTicZm8qUGN3pJGNTmRLDO51EbCpTYnSnk4oNvNPpPjboTicZm8qUGN7pJGJTmRKjO51kbCpTYnSnk4xNZUoM73S6jw2600nFBt3pJGNTmRKjO51kbCpTYnink4hNZUqM7nSSsalMidGdTio26E4nFRt4p5OITWVKjO50krGpTInRnU4yNpUpMbzTScSmMiVGdzqp2MA7ne5jg+50krGpTInhnU4iNpUpMbrTScamMiVGdzrJ2FSmxPBOp/vYoDudVGzQnU4yNpUpMbrTScamMiWGdzqJ2FSmxOhOJxmbypQY3emkYoPudFKxgXc6idhUpsToTicZm8qUGN3pJGNTmRLDO51EbApT4kB3OonYBLzT6TY2ge50krEpTInjYn/DitgUpsSB7nSSsSlMiQPd6SRjU5gSB7zT6T426E4nFRt0p5OMTWFKHOhOJxmbwpQ44J1OIjaFKXGgO51kbApT4kB3OqnYoDudVGzgnU4iNoUpcaA7nWRsClPiQHc6ydgUpsQB73QSsalMidGdTio28E6n+9igO51kbCpTYnink4hNZUqM7nSSsalMidGdTjI2lSkxvNPpPjboTicVG3Snk4xNZUqM7nSSsalMieGdTiI2lSkxutNJxqYyJUZ3OqnYoDudVGzgnU4iNpUpMbrTScamMiVGdzrJ2FSmxPBOJxGbypQY3emkYgPvdLqPDbrTScamMiWGdzqJ2FSmxOhOJxmbypQY3ekkY1OZEsM7ne5jg+50UrFBdzrJ2FSmxOhOJxmbypQY3ukkYlOZEqM7nWRsKlNidKeTig2600nFBt7pJGJTmRKjO51kbCpTYnSnk4xNZUoM73QSsalMidGdTio28E6n+9igO51kbCpTYnink4hNZUqM7nSSsalMidGdTjI2hSnxhHc63cZmojudRGwmutNJxqYwJZ4X+RtWxqYwJZ7wTicRm8KUeKI7nWRsClPiie50UrFBdzqp2MA7nURsClPiie50krEpTIknutNJxqYw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","file_map":{"7":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"63":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\npub mod Base64DecodeBEURLWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[input_byte]\n                } else {\n                    BASE64_DECODE_BE_TABLE[input_byte]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[input_byte]\n            } else {\n                BASE64_DECODE_BE_TABLE[input_byte]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        unsafe {\n            //@safety get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n            // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    assert_eq(\n        has_first_padding_byte_claim,\n        has_second_padding_byte_claim * has_first_padding_byte_claim,\n        \"if first byte contains padding so must the second\",\n    );\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEURLWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEURLWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEURLWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEURLWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEURLWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEURLWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/zac/noir_base64/src/decoder.nr"},"65":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let r = unsafe {\n        //@safety r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n        __boundary_check(limit)\n    };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/zac/noir_base64/src/boundary_check.nr"},"67":{"source":"use crate::decoder::{Base64DecodeBE, Base64DecodeBENoPad};\nuse crate::encoder::{Base64EncodeBE, Base64EncodeBENoPad, Base64EncodeBEUrlSafe};\n\n#[export]\nfn bench_encode_610(input: [u8; 610]) -> [u8; 816] {\n    Base64EncodeBE::encode(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBEUrlSafe::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 816> {\n    Base64EncodeBE::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBEUrlSafe::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_no_pad(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBENoPad::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var_no_pad(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBENoPad::encode_var(input)\n}\n\n#[export]\nfn bench_decode_610(input: [u8; 816]) -> [u8; 610] {\n    (Base64DecodeBE::decode(input))\n}\n\n#[export]\nfn bench_decode_610_var(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBE::decode_var(input));\n    r\n}\n\n#[export]\nfn bench_decode_610_no_pad(input: [[u8; 816]; 3]) -> [[u8; 610]; 3] {\n    let mut r: [[u8; 610]; 3] = [[0; 610]; 3];\n    for i in 0..3 {\n        r[i] = (Base64DecodeBENoPad::decode(input[i]));\n    }\n    r\n}\n\n#[export]\nfn bench_decode_610_var_no_pad(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBENoPad::decode_var(input));\n    r\n}\n\n","path":"/Users/zac/noir_base64/src/benchmarks/mod.nr"}},"names":["bench_decode_610_var"],"brillig_names":["__get_num_padding_chars_var","__boundary_check","__validate_decoded","directive_to_radix","directive_integer_quotient"]}