{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":4204423913033693548,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":816,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":610,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{"3951064283418873378":{"error_kind":"fmtstring","length":123,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32}]},"5634341720269277520":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"11095990634905808880":{"error_kind":"fmtstring","length":49,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14304927234259905409":{"error_kind":"fmtstring","length":129,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32}]},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"63":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\npub mod Base64DecodeBEURLWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[input_byte]\n                } else {\n                    BASE64_DECODE_BE_TABLE[input_byte]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[input_byte]\n            } else {\n                BASE64_DECODE_BE_TABLE[input_byte]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        unsafe {\n            //@safety get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n            // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    assert_eq(\n        has_first_padding_byte_claim,\n        has_second_padding_byte_claim * has_first_padding_byte_claim,\n        \"if first byte contains padding so must the second\",\n    );\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEURLWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEURLWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEURLWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEURLWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEURLWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEURLWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/zac/noir_base64/src/decoder.nr"},"67":{"source":"use crate::decoder::{Base64DecodeBE, Base64DecodeBENoPad};\nuse crate::encoder::{Base64EncodeBE, Base64EncodeBENoPad, Base64EncodeBEUrlSafe};\n\n#[export]\nfn bench_encode_610(input: [u8; 610]) -> [u8; 816] {\n    Base64EncodeBE::encode(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBEUrlSafe::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 816> {\n    Base64EncodeBE::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBEUrlSafe::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_no_pad(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBENoPad::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var_no_pad(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBENoPad::encode_var(input)\n}\n\n#[export]\nfn bench_decode_610(input: [u8; 816]) -> [u8; 610] {\n    (Base64DecodeBE::decode(input))\n}\n\n#[export]\nfn bench_decode_610_var(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBE::decode_var(input));\n    r\n}\n\n#[export]\nfn bench_decode_610_no_pad(input: [[u8; 816]; 3]) -> [[u8; 610]; 3] {\n    let mut r: [[u8; 610]; 3] = [[0; 610]; 3];\n    for i in 0..3 {\n        r[i] = (Base64DecodeBENoPad::decode(input[i]));\n    }\n    r\n}\n\n#[export]\nfn bench_decode_610_var_no_pad(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBENoPad::decode_var(input));\n    r\n}\n\n","path":"/Users/zac/noir_base64/src/benchmarks/mod.nr"}},"names":["bench_decode_610"],"brillig_names":["__validate_decoded","directive_to_radix"]}