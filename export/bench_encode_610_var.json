{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":9935209465335534220,"abi":{"parameters":[{"name":"input","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":610,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":816,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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k7Z5R+oylv08aZt3pC5z2c+TtnlH6jKY/Txpm3ekLpPZz5O2eUfqMpr9PGmbd6Qus9nPMdu8I3UZzn6O2eYdqct09o/HbPOkbd6RuqxnP8ds847UZT97fLoMaD9P2uYdqcuE9vOkbd6RuoxoP0/a5h2py4z286Rt3pG6DGk/T9rmHanLlPbzpG3ekbqMaT9P2uYdqcuc9vOkbd6RugxqP0/a5h2py6T286Rt3pG6jGo/T9rmHanLrPbzpG3ekboMaz9P2uYdqcu09vOkbd6RuoxrP0/a5h2py7z2c7Y270hdBrafs7V5R+oysf2crc07UpeR7edsbd6Rusxs/3i2Jk862uxsjzY726PNzvZos7M9PrvNk3Z5RxptdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t0WZne7TZ2R5tdrZHm53t2WZne7bZ2Z5tdrZnm53t+dltnrTLO9Jss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xszzY727PNzvZss7M92+xsrzY726vNzvZqs7O92uxsr89u86Rd3pFWm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7XZ2V5tdrZXm53t1WZne7fZ2d5tdrZ3m53t3WZne392myft8o602+xs7zY727vNzvZus7O92+xs7zY727vNzvZus7O92+xs7zY727vNzvZus7O92+xs7zY727vNzvZus7O92+xs7zY727vNzvZus7O92+xs7zY727vNzvZus7O92+xs7zY727vNzvZus7O92+xs7zY727vNzvZus7O92+xs7zY727vNzvZus7O92+xs7zY727vNzvZus7O92+xs7zY727vNzvZus7O92+xsb/LO9pojvvzSa679//mk4Hekb/yk4Hekb/yku82Tgt+RvvGTgt+RvvGTgt+RvvGTgt+RvvGTgt+Rvu2Tkne2v/GTtnlHIu9sf+MnbfOORN7Z/sZP2uYdibyz/Y2ftM07Enln+xs/aZt3JPLO9jd+0jbvSOSd7W/8pG3ekcg729/4Sdu8I5F3tr/xk7Z5RyLvbH/jJ23zjkTe2f7GT9rmHYm8s/2Nn7TNOxJ5Z/sbP2mbdyTyzvY3ftI270jkne1v/KRt3pHIO9vf+EnbvCORd7a/8ZN+33ekveKn05z591/8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","file_map":{"7":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"64":{"source":"use super::defaults::{BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK};\n\nuse crate::tables::{\n    BASE64_ENCODE_BE_TABLE, BASE64_ENCODE_BE_VAR_TABLE, BASE64URL_ENCODE_BE_TABLE,\n    BASE64URL_ENCODE_BE_VAR_TABLE,\n};\n\npub use crate::boundary_check::boundary_check;\n\nglobal CONVERT_MODULO3_TO_PADDING_BYTES: [u32; 3] = [0, 2, 1];\nglobal PAD_1: [Field; 3] = [0, 1, 1];\nglobal PAD_2: [Field; 3] = [0, 1, 0];\n\n// Encoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64EncodeBE {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * 3) + (((InputBytes % 3) / 2) * 2)] {\n        crate::encoder::encode::<InputBytes, 0, 1>(input)\n    }\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * 3) + (((MAX_INPUT_LEN % 3) / 2) * 2)> {\n        crate::encoder::encode_var::<_, 0, 1>(input)\n    }\n}\n\n// Encoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64EncodeBENoPad {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2)) + (((InputBytes % 3) / 2))] {\n        crate::encoder::encode::<InputBytes, 0, 0>(input)\n    }\n\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, (((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2)) + (((MAX_INPUT_LEN % 3) / 2)))> {\n        crate::encoder::encode_var::<_, 0, 0>(input)\n    }\n}\n\n// Encoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64EncodeBEUrlSafe {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2)) + (((InputBytes % 3) / 2))] {\n        crate::encoder::encode::<_, 1, 0>(input)\n    }\n\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, (((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2)) + (((MAX_INPUT_LEN % 3) / 2)))> {\n        crate::encoder::encode_var::<_, 1, 0>(input)\n    }\n}\n\n// Encoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64EncodeBEUrlSafeWithPad {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * 3) + (((InputBytes % 3) / 2) * 2)] {\n        crate::encoder::encode::<_, 1, 1>(input)\n    }\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * 3) + (((MAX_INPUT_LEN % 3) / 2) * 2)> {\n        crate::encoder::encode_var::<_, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Take an array of ASCII values and convert into base64 values\n * @tparam InputElements: The size of the array being encoded\n * @tparam UseUrlTable: are we encoding using the URL and Filename Safe Alphabet, or standard Base64 Alphabet? \n **/\nfn encode_elements<let InputElements: u32, let UseUrlTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; InputElements] {\n    let mut result: [u8; InputElements] = [0; InputElements];\n\n    for i in 0..InputElements {\n        let token: u8 = if UseUrlTable == 1 {\n            BASE64URL_ENCODE_BE_TABLE[input[i]]\n        } else {\n            BASE64_ENCODE_BE_TABLE[input[i]]\n        };\n        result[i] = token as u8;\n    }\n\n    result\n}\n\n/**\n * @brief Encode a variable-length ASCII string into Base64 values\n **/\nfn encode_var<let MAX_INPUT_LEN: u32, let UseURLTable: u1, let HasPadding: u32>(\n    input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))> {\n    assert((HasPadding == 0) | (HasPadding == 1), \"invalid HasPadding parameter\");\n    // The max number of output Base64 values can be derived from the max input size\n    let mut result_arr: [u8; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] = [\n        0; ((MAX_INPUT_LEN * 8) / 6)\n            + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2))\n            + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))\n    ];\n\n    // Note: is this correct?\n    let output_length = ((MAX_INPUT_LEN * 8) / 6)\n        + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2))\n        + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding));\n\n    // Step 1: convert the input into six-bit chunks. We can map each chunk into Base64 values.\n    let raw: [u8; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] =\n        crate::encoder::split_into_six_bit_chunks::<_, _, 1>(input.storage());\n\n    let real_length = input.len();\n    // The input length modulo 3 can be used to determine the number of padding bytes\n    let real_length_mod_3 = if HasPadding == 1 { real_length % 3 } else { 0 };\n    // encoded_length = the number of Base64 values minus padding\n    let encoded_length = ((real_length * 8) + 5) / 6;\n    let final_length = encoded_length\n        + if HasPadding == 1 {\n            CONVERT_MODULO3_TO_PADDING_BYTES[real_length_mod_3]\n        } else {\n            0\n        };\n\n    // Get an array of Field elements where boundary_flags[i] = 0 if i < encoded_length, otherwise i = 1.\n    // We use this array to determine if the result array should contain a valid Base64 encoded value, 0 or if an error state has been reached\n    let boundary_flags: [Field; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] =\n        boundary_check(encoded_length);\n\n    // Using 2 lookups is slightly cheaper than figuring out if the 1st/2nd padding byte is set from the padding length param... I think?\n    let has_first_padding_byte = if HasPadding == 1 {\n        PAD_1[real_length_mod_3]\n    } else {\n        0\n    };\n    let has_second_padding_byte = if HasPadding == 1 {\n        PAD_2[real_length_mod_3]\n    } else {\n        0\n    };\n\n    // If we have actual data to iterate through, populate the 1st result entry with the base64 encoding of `raw[0]`.\n    // Note: if `boundary_flags[0] = 1`, the `BASE64_ENCODE_BE_VAR_TABLE` lookup will output 0.\n    // Note: `MAX_INPUT_LEN` is known at compile time so this `if` statement should not incur constraints.\n    if MAX_INPUT_LEN > 0 {\n        result_arr[0] = BASE64_ENCODE_BE_VAR_TABLE[raw[0] as Field + boundary_flags[0] * 64] as u8;\n    }\n\n    let mut previous_was_first_padding_byte = 0;\n    for i in 1..output_length {\n        let exceed_length = boundary_flags[i];\n        // hit_limit = we are at the first location where a padding Base64 character *could* be enerated\n\n        let mut encoding_index: Field = 0;\n\n        if HasPadding == 1 {\n            let hit_limit: Field = (1 - boundary_flags[i - 1]) * boundary_flags[i];\n            // We need to write a padding byte if `i == encoding_length` and `has_first_padding_byte == 1`\n            let write_first_padding_byte: Field = hit_limit * has_first_padding_byte;\n            // We need to write a padding byte if `i == encoding_length + 1` and `has_second_padding_byte == 1`\n            let write_second_padding_byte =\n                previous_was_first_padding_byte * has_second_padding_byte;\n\n            // Look up the encoded Base64 value given an input 6-bit chunk.\n            // We have 2 edge cases that we need to handle efficiently (writing padding bytes or we have exceeded the input length)\n            // Instead of expensive conditional logic we apply lookup tables as a quasi state machine to handle these edge cases.\n            // CASE 1: `exceed_length = 0`, `write_first_padding_byte = 0`, `write_second_padding_byte = 0`\n            //      outcome: we map the 6-bit input value into a Base64 encoding\n            // CASE 2: `exceed_length = 1` AND `write_first_padding_byte = 0` AND `write_second_padding_byte = 0`\n            //      outcome: if `raw[i] = 0`, the returned value is 0. All other inputs for `raw[i]` return an error state\n            // CASE 3: `exceed_length = 1` AND ()`write_first_padding_byte = 1` OR `write_second_padding_byte = 1`)\n            //      outcome: if `raw[i] = 0`, the returned value is BASE64_PADDING_CHAR. All other inputs for `raw[i]` return an error state\n            // Note: due to how they are constructed, it is not possible for both `write_first_padding_byte` and `write_second_padding_byte` to equal 1.\n            //       Similarly, it is not possible for `exceed_length = 0` and either of `write_first_padding_byte` or `write_second_padding_byte` to equal 1.\n            encoding_index = raw[i] as Field\n                + (exceed_length + write_first_padding_byte + write_second_padding_byte) * 64;\n            previous_was_first_padding_byte = write_first_padding_byte;\n        } else {\n            // We have 2 edge cases that we need to handle efficiently (writing padding bytes or we have exceeded the input length)\n            // Instead of expensive conditional logic we apply lookup tables as a quasi state machine to handle these edge cases.\n            // CASE 1: `exceed_length = 0`\n            //      outcome: we map the 6-bit input value into a Base64 encoding\n            // CASE 2: `exceed_length = 1`\n            //      outcome: if `raw[i] = 0`, the returned value is 0. All other inputs for `raw[i]` return an error state\n\n            encoding_index = raw[i] as Field + (exceed_length * 64);\n        }\n\n        // Note: this `if` condition is known at compile time so should not incur additional constraints\n        let token: u8 = if UseURLTable == 1 {\n            BASE64_ENCODE_BE_VAR_TABLE[encoding_index]\n        } else {\n            BASE64URL_ENCODE_BE_VAR_TABLE[encoding_index]\n        };\n        (token as Field).assert_max_bit_size::<7>();\n        result_arr[i] = token;\n    }\n\n    // we can use `from_parts_unchecked` here because the table BASE64_ENCODE_BE_VAR_TABLE (and it's URL equivalent)\n    // will produce an error if a nonzero input is given past `final_length`\n    let mut r: BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))> =\n        BoundedVec::from_parts_unchecked(result_arr, final_length);\n\n    r\n}\n\n/**\n * @brief Take an array of ASCII bytes and convert into an array of six-bit chunks\n **/\nfn split_into_six_bit_chunks<let InputBytes: u32, let OutputElements: u32, let HasPadding: u32>(\n    input: [u8; InputBytes],\n) -> [u8; OutputElements] {\n    // Calculate the number of padding characters and the length of the output without padding\n\n    // input bytes modulo 3 . e.g.\n\n    // input = 5 implies 1 padding char = 40 bits of data = 6 base64 vals + 2 bits\n    // 1 is padding so we have 5 base64 vals\n    let rem = InputBytes % 3;\n    let num_padding_chars = if HasPadding == 1 {\n        if rem == 1 {\n            2\n        } else if rem == 2 {\n            1\n        } else {\n            0\n        }\n    } else {\n        0\n    };\n\n    let mut result: [u8; OutputElements] = [0; OutputElements];\n\n    let num_chunks = (InputBytes / BYTES_PER_CHUNK) + (InputBytes % BYTES_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            // pack the bytes into the field element\n            let mut slice: Field = 0;\n            for j in 0..BYTES_PER_CHUNK {\n                slice *= 256;\n                slice += input[i * BYTES_PER_CHUNK + j] as Field;\n            }\n            // extract the 6-bit values from the Field element\n            let slice_base64_chunks: [u8; BASE64_ELEMENTS_PER_CHUNK] = slice.to_be_radix(64);\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                result[i * BASE64_ELEMENTS_PER_CHUNK + j] = slice_base64_chunks[j];\n            }\n        }\n\n        // process the final chunk, which may require padding\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_offset = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let bytes_in_final_chunk = InputBytes - byte_offset;\n        let num_elements_in_final_chunk = OutputElements - base64_offset;\n\n        // pack the bytes into the field element\n        let mut slice: Field = 0;\n        for j in 0..bytes_in_final_chunk {\n            slice *= 256;\n            slice += input[(num_chunks - 1) * BYTES_PER_CHUNK + j] as Field;\n        }\n        for _ in bytes_in_final_chunk..BYTES_PER_CHUNK {\n            slice *= 256;\n        }\n\n        // extract the 6-bit values from the Field element\n        let slice_base64_chunks: [u8; BASE64_ELEMENTS_PER_CHUNK] = slice.to_be_radix(64);\n        for i in 0..num_elements_in_final_chunk {\n            // If padding is enabled, we can skip setting the last `non_padded_output_length` chars\n            // N.B. if statement is compile time so shouldn't add c onstraints\n            if HasPadding == 1 {\n                let non_padded_output_length = OutputElements - num_padding_chars;\n                if (base64_offset + i < non_padded_output_length) {\n                    result[base64_offset + i] = slice_base64_chunks[i];\n                }\n            } else {\n                result[base64_offset + i] = slice_base64_chunks[i];\n            }\n        }\n    }\n\n    result\n}\n\nfn encode<let InputBytes: u32, let UseUrlTable: u1, let UsePadding: u32>(\n    input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * (1 + UsePadding * 2)) + (((InputBytes % 3) / 2) * (1 + UsePadding))] {\n    assert((UsePadding == 0 as u32) | (UsePadding == 1 as u32), \"UsePadding must be 0 or 1\");\n    let mut result = crate::encoder::encode_elements::<_, UseUrlTable>(\n        crate::encoder::split_into_six_bit_chunks::<_, _, UsePadding>(input),\n    );\n    // this relationship should be evaluated at compile time\n    let OutputElements = ((InputBytes * 8) / 6)\n        + (((InputBytes % 3) % 2) * (1 + UsePadding * 2))\n        + (((InputBytes % 3) / 2) * (1 + UsePadding));\n    if UsePadding == 1 {\n        // handle padding\n        let rem = InputBytes % 3;\n        if (rem == 1) {\n            result[OutputElements - 1] = BASE64_PADDING_CHAR;\n            result[OutputElements - 2] = BASE64_PADDING_CHAR;\n        } else if (rem == 2) {\n            result[OutputElements - 1] = BASE64_PADDING_CHAR;\n        }\n    }\n    result\n}\n\n// === TESTS ======================================================================================\n\n#[test]\nfn test_encode_elements() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII (with the = padding character stripped)\n    let ascii_expected: [u8; 43] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85,\n    ];\n\n    let input: [u8; 43] = [\n        6, 49, 12, 37, 32, 48, 11, 34, 50, 41, 39, 21, 43, 4, 54, 2, 52, 18, 31, 56, 50, 51, 33, 28,\n        22, 19, 36, 0, 33, 18, 25, 57, 62, 22, 4, 17, 33, 10, 33, 23, 45, 37, 20,\n    ];\n\n    let ascii_result = crate::encoder::encode_elements::<_, 0>(input);\n\n    assert(ascii_result == ascii_expected);\n}\n\n#[test]\nfn test_encode_empty() {\n    let input: [u8; 0] = [];\n    let result = Base64EncodeBE::encode(input);\n    let expected: [u8; 0] = [];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_padding() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 4] = [90, 103, 61, 61];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 4] = [90, 109, 56, 61];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_standard_no_pad() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 2] = [90, 103];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 3] = [90, 109, 56];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_max_byte() {\n    let input: [u8; 1] = [255];\n\n    let result: [u8; 4] = Base64EncodeBE::encode(input);\n    let expected: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    assert(result == expected);\n\n    let result: [u8; 2] = Base64EncodeBENoPad::encode(input);\n    let expected: [u8; 2] = [47, 119]; // \"/w\"\n    assert(result == expected);\n\n    let result: [u8; 4] = Base64EncodeBEUrlSafeWithPad::encode(input);\n    let expected: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    assert(result == expected);\n\n    let result: [u8; 2] = Base64EncodeBEUrlSafe::encode(input);\n    let expected: [u8; 2] = [95, 119]; // \"_w\"\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_ascii() {\n    // \"Hello World!\"\n    let input: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n    // base64: SGVsbG8gV29ybGQh\n    let expected: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_utf8() {\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let input: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let expected: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let input: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let expected: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n\n    let expected: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_standard() {\n    // test encoding to / and +\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 4] = [47, 43, 65, 61];\n    let result: [u8; 4] = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_url_safe_with_pad() {\n    // test encoding to _ and -\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 4] = [95, 45, 65, 61];\n    let result: [u8; 4] = Base64EncodeBEUrlSafeWithPad::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_url_safe() {\n    // test encoding to _ and -\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 3] = [95, 45, 65];\n    let result: [u8; 3] = Base64EncodeBEUrlSafe::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU\n    // Translated directly to ASCII (with padding byte character stripped)\n    let expected: [u8; 43] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85,\n    ];\n\n    let input: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_base64_encode_slash() {\n    let input: [u8; 1] = [63]; // '/' in Base64\n    let result: [u8; 1] = crate::encoder::encode_elements::<_, 0>(input);\n\n    // Should map to '/' in ASCII, which is 47\n    assert(result[0] == 47);\n}\n\n#[test]\nfn test_encode_var_empty() {\n    let input: BoundedVec<u8, 3> = BoundedVec::new();\n    let result = Base64EncodeBE::encode_var(input);\n    let expected: BoundedVec<u8, 4> = BoundedVec::new();\n    assert(result == expected);\n\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64EncodeBE::encode_var(input);\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var() {\n    // \"Hello, World!\"\n    let input: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let expected: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let expected_no_pad: BoundedVec<u8, 22> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode_var(input);\n    println(f\"result = {result}\");\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode_var(input);\n    assert(result == expected_no_pad);\n    let result = Base64EncodeBEUrlSafeWithPad::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafe::encode_var(input);\n    assert(result == expected_no_pad);\n}\n\n#[test]\nfn test_encode_var_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let input: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let expected: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let expected_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode_var(input);\n    assert(result == expected_no_pad);\n    let result = Base64EncodeBEUrlSafeWithPad::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafe::encode_var(input);\n    assert(result == expected_no_pad);\n}\n","path":"/Users/zac/noir_base64/src/encoder.nr"},"65":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let r = unsafe {\n        //@safety r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n        __boundary_check(limit)\n    };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/zac/noir_base64/src/boundary_check.nr"},"67":{"source":"use crate::decoder::{Base64DecodeBE, Base64DecodeBENoPad};\nuse crate::encoder::{Base64EncodeBE, Base64EncodeBENoPad, Base64EncodeBEUrlSafe};\n\n#[export]\nfn bench_encode_610(input: [u8; 610]) -> [u8; 816] {\n    Base64EncodeBE::encode(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBEUrlSafe::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 816> {\n    Base64EncodeBE::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBEUrlSafe::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_no_pad(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBENoPad::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var_no_pad(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBENoPad::encode_var(input)\n}\n\n#[export]\nfn bench_decode_610(input: [u8; 816]) -> [u8; 610] {\n    (Base64DecodeBE::decode(input))\n}\n\n#[export]\nfn bench_decode_610_var(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBE::decode_var(input));\n    r\n}\n\n#[export]\nfn bench_decode_610_no_pad(input: [[u8; 816]; 3]) -> [[u8; 610]; 3] {\n    let mut r: [[u8; 610]; 3] = [[0; 610]; 3];\n    for i in 0..3 {\n        r[i] = (Base64DecodeBENoPad::decode(input[i]));\n    }\n    r\n}\n\n#[export]\nfn bench_decode_610_var_no_pad(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBENoPad::decode_var(input));\n    r\n}\n\n","path":"/Users/zac/noir_base64/src/benchmarks/mod.nr"}},"names":["bench_encode_610_var"],"brillig_names":["__boundary_check","directive_to_radix","directive_integer_quotient"]}