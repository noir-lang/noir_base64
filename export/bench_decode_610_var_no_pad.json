{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":6357438229604867928,"abi":{"parameters":[{"name":"input","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":816,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":610,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5634341720269277520":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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XJ96w/WpN5xHpOH61BuuT73hPCIN16fecH3qDecRabg+9YbrU284j0jD9ak3XJ96w3lEGq5PveH61BvOI9JwfeoN16fecH3qDden3nB96g3Xp95wfeoN16fecH3qDden3nB96g3Xp95wfeoN16fecH3qDden3nB96g3Xp95wfeoN16fecH3qDden3nB96g3Xp95wfeoN16fecH3qDden3nB96g3Xp95wfeoN16fecH3qDXcPsuH61BuuT73h7kE2XJ96x/Wpd9w9yI7rU++4PvV+0WZ2x/Wpd1yfesfdg+y4PvWO61PvuHuQHden3nF96h13D7Lj+tR7yeNp6yWPp62XPJ62XvJ42nrJ42nrNY+nrdc8nrZe83jaes3jaevv3xj+4LMm2ptqor2pJtqbaqK9qSbamyLR3hSJ9qZItDdFor3p9Vv7n3zWRHtTJNqbItHeFIn2pki0N7VEe1NLtDe1RHtTS7Q3vW7O+OSzJtqbWqK9CecR6Y32Dl9vuHf4cB6R3nHv8HXcO3w4j0h/3SOiT4R7hw/nEekdN7M77h0+nEekD9zMHrh3+HAekT5wM/t1j4j+1Gh3ZfrAzexBu9/YcR6RPnAze9LuN3acR6RP3MyetPuNHecR6RM3syftfmPHeUT6xM3sictGcB6RvnAze+GyEZxHpC/czF64bATnEekLN7MXLhvBeUT6xs3sjctGcB6RvnEz+/2mdvmp4fZsXJ96x/Wpd5xHpOP61AeuT33gPCID16c+cH3q58C4PyPazB64PvWB84gMXJ/6wPWpD5xHZOD61AeuT33gPCID16c+cH3qA9enPnB96gPXpz5wfeoD16c+cH3qA9enPnB96gPXpz5wfeoD16c+cH3qA9enPnB96gPXpz5wfeoD16c+cH3qA9enPnB96gPXpz5wfeoD16c+cH3qA9enPnB96gPXpz5wfeoD16c+cH3qA9enPnD3IAeuT33g+tQH7h7kwPWpD1yf+sDdgxy4PvWB61MfuHuQA9enPnB96gN3D3Lg+tQHrk994O5BDlyf+sD1qQ/cPciB61MfI4+nbYw8nrYx8njaxszjaRszj6dtzDyetjHzeNrG67dvP/mseTxtY+bxtI2ZaG+aifammWhvWon2ppVob1qJ9qaVaG96/Qb8J5810d60Eu1NK9HetBLtTSvR3rQT7U070d60E+1NO9He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hZvZC3e/EecRKQs3s1/3iOhPDbdnL9zMXrhsBOcRKQs3szcuG8F5RMrGzeyNy0ZwHpGycTN747IRnEekbNzM3rRspOI8IvWizex60bKRivOI1Is2syuuT73iPCIV16decX3qFecRqbg+9YrrU684j0jF9alXXJ96xXlEKq5PveL61CvOI1JxfeoV16decR6RiutTr7g+9YrrU6+4PvWK61OvuD71iutTr7g+9YrrU6+4PvWK61OvuD71iutTr7g+9YrrU6+4PvWK61OvuD71iutTr7g+9YrrU6+4PvWK61OvuD71iutTr7g+9YrrU6+4PvWK61OvuD71iutTr7g+9YrrU6+4e5AV16decX3qFXcPsuL61CuuT73i7kFWXJ96xfWpV9w9yIrrU6+4PvWKuwdZcX3qFdenXnH3ICuuT73i+tQr7h5kxfWp15nH01ZnHk9bnXk8bXXm8bTVmcfTVlceT1tdeTxtdeXxtNWVx9NW378x/MFnTbQ3rUR700q0N61Ee9NKtDftRHvTTrQ37UR70060N71+a/+Tz5pob9qJ9qadaG/aifamnWdviivP3hRXnr0prjx7U1x59qa4WqJnzbM3xZVnbwqcRyQu2jt8cdHe4QucRyQK7R2+KLR3+ALnEYnXPSL6RLR3+ALnEYmCm9mF9g5f4DwiUXEzu9Le4QucRyQqbma/7hHRnxrtrkxU3MyutPuNgfOIRMXN7KDdbwycRyQCN7ODdr8xcB6RCNzMDtr9xsB5RCJwMztw2QjOIxINN7MbLhvBeUSi4WZ2w2UjOI9INNzMbrhsBOcRiY6b2R2XjeA8ItFxM/v9pnb5qeH2bFyfeuD61APnEQlcn3rg+tQD5xEJXJ964PrUA+cRCVyfeuD61APnEQlcn3rg+tQD5xEJXJ964PrUA+cRCVyfeuD61APXpx64PvXA9akHrk89cH3qgetTD1yfeuD61APXpx64PvXA9akHrk89cH3qgetTD1yfeuD61APXpx64PvXA9akHrk89cH3qgetTD1yfeuD61BuuT73h+tQbrk+94frU20Wb2Q3Xp95wfeoNdw+y4frUG65PveHuQTZcn3rD9ak33D3IhutTb7g+9Ya7B9lwfeoN16fecPcgG65PveH61BvuHmTD9ak3XJ96w92DbLg+9VbzeNpazeNpazWPp61FHk9bizyethZ5PG0t8nja2uu3bz/5rHk8bS3yeNpaJNqbItHeFIn2ppZob2qJ9qaWaG9qifam12/Af/JZE+1NLdHe1BLtTS3R3tQS7U090d7UE+1NPdHe1BPtTe9bKD74rIn2pp5ob+qJ9qaeaG/CeUTawL3DN3Dv8OE8Im3g3uF73SOiPzXc+yAD9w7fwL3Dh/OItIGb2RP3Dh/OI9ImbmZP3Dt8OI9Im7iZPXHv8OE8Im3iZvbE3W/EeUTaws3shbvfiPOItIWb2Qt3vxHnEWkLN7MX7n4jziPSNm5mb1w2gvOItI2b2a97RPSnhtuzN25mb1w2gvOItE2b2f2iZSMd5xHpF21m94uWjfSLtmf3izaz+0XLRjrOI9Jxfeod16fecR6RjutT77g+9Y7ziHRcn3rH9al3nEek4/rUO65PveM8Ih3Xp95xfeod5xHpuD71jutT7ziPSMf1qXdcn3rH9al3XJ96x/Wpd1yfesf1qXdcn3rH9al3XJ96x/Wpd1yfesf1qXdcn3rH9al3XJ96x/Wpd1yfesf1qXdcn3rH9al3XJ96x/Wpd1yfesf1qXdcn3rH9al3XJ96x/Wpd1yfesf1qXdcn3rH9al33D3IjutT77g+9Y67B9lxfeod16fecfcgO65PveP61DvuHmTH9al3XJ96x92D7Lg+9Y7rU++4e5Ad16fecX3qHXcPsuP61PvM42nrK4+nra88nra+8nja+srjaeuv32T95LPm8bT1lcfT1lceT1tfeTxtfSXam3aivWkn2pt2or1pJ9qb3r9N/sFnTbQ37UR70060N+1Ee9POszeNK8/eNK48e9O48uxN48qzN53wPtGz5tmbxpVnbxpXnr1pXHn2pnEl2ptKor0J5xEZhfYO3yi0d/gGziMyCu0dvlFo7/ANnEdkFNo7fKPQ3uEbOI/IqLiZXWnv8A2cR2RU3MyutHf4Bs4jMipuZlfaO3wD5xEZgZvZQbvfOHAekRG4mf26R0R/arg9O3AzO2j3GwfOIzICN7Mb7X7jwHlERsPN7IbLRnAekdFwM7vhshGcR2Q03MxuuGwE5xEZHTezOy4bwXlERsfN7I7LRnAekdFxM7vjshGcR2Tg+tQHrk994DwiA9enPnB96gPnERm4PvWB61MfOI/IwPWpD1yf+sB5RAauT33g+tQHziMycH3qA9enPnAekYHrUx+4PvWB61MfuD71getTH7g+9YHrUx+4PvWB61MfuD71getTH7g+9YHrUx+4PvWB61MfuD71getTH7g+9YHrUx+4PvWB61MfuD71ietTn7g+9YnrU5+4PvV50fbsietTn7g+9YnrU5+4PvWJ61OfuD71ibsHOXF96hPXpz5x9yAnrk994vrUJ+4e5MT1qU9cn/rE3YOcuD71ietTn7h7kBPXpz5xfeoTdw9y4vrUJ65PfeLuQU5cn/qMPJ62GXk8bTPyeNrm+7dCP/iseTxtM/J42mbk8bTNyONpm5HH0zZbHk/bbIn2ppZob2qJ9qbXb2Z/8lkT7U0t0d7UEu1NLdHe1BLtTT3R3tQT7U090d7UE+1Nr9sRPvmsifamnmhv6on2pp5ob+qJ9qaRaG8aifamkWhvwnlE5useEX0i3Dt8OI/IHLh3+AbuHT6cR2RO3Dt8E/cOH84jMiduZr/uEdGfGu4dvomb2RP3Dh/OIzInbmYv3Dt8OI/IXLiZvXD3G3EekblwM3vh7jfiPCJz4Wb2wt1vxHlE5sbN7I2734jziMyNm9kbl43gPCJz42b2xmUjOI/Iumgze120bGThPCLros3sdTXcp0bbs9dFm9nromUjC+cRWRduZhdaNrJwHpGF61NfuD71hfOILFyf+sL1qS+cR2Th+tQXrk994TwiC9envnB96gvnEVm4PvWF61NfOI/IwvWpL1yf+sJ5RBauT33h+tQXrk994frUF65PfeH61BeuT33h+tQXrk994frUF65PfeH61BeuT33h+tQXrk994frUF65PfeH61BeuT33h+tQXrk994frUF65PfeH61BeuT33h+tQXrk994frUF65PfeH61BeuT33h+tQXrk994e5BLlyf+sL1qS/cPciF61NfuD71hbsHuXB96gvXp75w9yAXrk994frUF+4e5ML1qS9cn/rC3YNcuD71hetTX7h7kAvXp75WHk/bev2G5SefNY+nba08nra18nja1srjaVsrj6dt7TyetrXzeNrWzuNpWzvR3vT6LedPPmuivWkn2pt2or1pJ9qbdp69aV959qZ95dmb9pVnb9pXnr1pXy3Rs+bZm/aVZ2/aV569aV959qZ9JdqbSqK9qSTam0qivakk2ptet3188llp74PsQnuHbxfaO3wb5xHZhfYO3660d/g2ziOyK+0dvl1p7/BtnEdkV9zMrrR3+DbO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","file_map":{"7":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"63":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\npub mod Base64DecodeBEURLWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[input_byte]\n                } else {\n                    BASE64_DECODE_BE_TABLE[input_byte]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[input_byte]\n            } else {\n                BASE64_DECODE_BE_TABLE[input_byte]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        unsafe {\n            //@safety get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n            // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    assert_eq(\n        has_first_padding_byte_claim,\n        has_second_padding_byte_claim * has_first_padding_byte_claim,\n        \"if first byte contains padding so must the second\",\n    );\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEURLWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEURLWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEURLWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEURLWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEURLWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEURLWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/zac/noir_base64/src/decoder.nr"},"65":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let r = unsafe {\n        //@safety r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n        __boundary_check(limit)\n    };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/zac/noir_base64/src/boundary_check.nr"},"67":{"source":"use crate::decoder::{Base64DecodeBE, Base64DecodeBENoPad};\nuse crate::encoder::{Base64EncodeBE, Base64EncodeBENoPad, Base64EncodeBEUrlSafe};\n\n#[export]\nfn bench_encode_610(input: [u8; 610]) -> [u8; 816] {\n    Base64EncodeBE::encode(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBEUrlSafe::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 816> {\n    Base64EncodeBE::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBEUrlSafe::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_no_pad(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBENoPad::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var_no_pad(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBENoPad::encode_var(input)\n}\n\n#[export]\nfn bench_decode_610(input: [u8; 816]) -> [u8; 610] {\n    (Base64DecodeBE::decode(input))\n}\n\n#[export]\nfn bench_decode_610_var(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBE::decode_var(input));\n    r\n}\n\n#[export]\nfn bench_decode_610_no_pad(input: [[u8; 816]; 3]) -> [[u8; 610]; 3] {\n    let mut r: [[u8; 610]; 3] = [[0; 610]; 3];\n    for i in 0..3 {\n        r[i] = (Base64DecodeBENoPad::decode(input[i]));\n    }\n    r\n}\n\n#[export]\nfn bench_decode_610_var_no_pad(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBENoPad::decode_var(input));\n    r\n}\n\n","path":"/Users/zac/noir_base64/src/benchmarks/mod.nr"}},"names":["bench_decode_610_var_no_pad"],"brillig_names":["__boundary_check","__validate_decoded","directive_to_radix","directive_integer_quotient"]}