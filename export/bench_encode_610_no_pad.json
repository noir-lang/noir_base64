{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":10304413090763667145,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":610,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":814,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"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kmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp0W2XRaZNNpkU2nRTad1gPcsItsOi2y6bTIptMim06LbDotsum0yKbTIptOi2w6LbLptMim0yKbTotsOi2y6bTIptMim06LbDotsum0yKbTIptOi2w6LbLptMim0yKbTotsOi2y6bTIptMim06LbDotsum0yKbTIptOi2w6LbLptMim0yKbTotsOi2y6bTIptMim06LbDotsum0yKbTIptOi2w6LbLptMim0yKbTotsOi2y6bTIptMim06LbDotsum0yKbTIptOi2w6LbLptMim0yKbTotsOi2y6bTIptMim06LbDotrOl0P/zlh4/ffPPxr3/+5rsvPv/p43ff/nh/9f74Pz7/4ePnf/nmq98/fv3zt1/807c//ef3f3zzx+9//8N3X3z15c8/fPXbX/rbd/fP/xc=","file_map":{"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"64":{"source":"use super::defaults::{BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK};\n\nuse crate::tables::{\n    BASE64_ENCODE_BE_TABLE, BASE64_ENCODE_BE_VAR_TABLE, BASE64URL_ENCODE_BE_TABLE,\n    BASE64URL_ENCODE_BE_VAR_TABLE,\n};\n\npub use crate::boundary_check::boundary_check;\n\nglobal CONVERT_MODULO3_TO_PADDING_BYTES: [u32; 3] = [0, 2, 1];\nglobal PAD_1: [Field; 3] = [0, 1, 1];\nglobal PAD_2: [Field; 3] = [0, 1, 0];\n\n// Encoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64EncodeBE {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * 3) + (((InputBytes % 3) / 2) * 2)] {\n        crate::encoder::encode::<InputBytes, 0, 1>(input)\n    }\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * 3) + (((MAX_INPUT_LEN % 3) / 2) * 2)> {\n        crate::encoder::encode_var::<_, 0, 1>(input)\n    }\n}\n\n// Encoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64EncodeBENoPad {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2)) + (((InputBytes % 3) / 2))] {\n        crate::encoder::encode::<InputBytes, 0, 0>(input)\n    }\n\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, (((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2)) + (((MAX_INPUT_LEN % 3) / 2)))> {\n        crate::encoder::encode_var::<_, 0, 0>(input)\n    }\n}\n\n// Encoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64EncodeBEUrlSafe {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2)) + (((InputBytes % 3) / 2))] {\n        crate::encoder::encode::<_, 1, 0>(input)\n    }\n\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, (((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2)) + (((MAX_INPUT_LEN % 3) / 2)))> {\n        crate::encoder::encode_var::<_, 1, 0>(input)\n    }\n}\n\n// Encoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64EncodeBEUrlSafeWithPad {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * 3) + (((InputBytes % 3) / 2) * 2)] {\n        crate::encoder::encode::<_, 1, 1>(input)\n    }\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * 3) + (((MAX_INPUT_LEN % 3) / 2) * 2)> {\n        crate::encoder::encode_var::<_, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Take an array of ASCII values and convert into base64 values\n * @tparam InputElements: The size of the array being encoded\n * @tparam UseUrlTable: are we encoding using the URL and Filename Safe Alphabet, or standard Base64 Alphabet? \n **/\nfn encode_elements<let InputElements: u32, let UseUrlTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; InputElements] {\n    let mut result: [u8; InputElements] = [0; InputElements];\n\n    for i in 0..InputElements {\n        let token: u8 = if UseUrlTable == 1 {\n            BASE64URL_ENCODE_BE_TABLE[input[i]]\n        } else {\n            BASE64_ENCODE_BE_TABLE[input[i]]\n        };\n        result[i] = token as u8;\n    }\n\n    result\n}\n\n/**\n * @brief Encode a variable-length ASCII string into Base64 values\n **/\nfn encode_var<let MAX_INPUT_LEN: u32, let UseURLTable: u1, let HasPadding: u32>(\n    input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))> {\n    assert((HasPadding == 0) | (HasPadding == 1), \"invalid HasPadding parameter\");\n    // The max number of output Base64 values can be derived from the max input size\n    let mut result_arr: [u8; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] = [\n        0; ((MAX_INPUT_LEN * 8) / 6)\n            + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2))\n            + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))\n    ];\n\n    // Note: is this correct?\n    let output_length = ((MAX_INPUT_LEN * 8) / 6)\n        + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2))\n        + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding));\n\n    // Step 1: convert the input into six-bit chunks. We can map each chunk into Base64 values.\n    let raw: [u8; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] =\n        crate::encoder::split_into_six_bit_chunks::<_, _, 1>(input.storage());\n\n    let real_length = input.len();\n    // The input length modulo 3 can be used to determine the number of padding bytes\n    let real_length_mod_3 = if HasPadding == 1 { real_length % 3 } else { 0 };\n    // encoded_length = the number of Base64 values minus padding\n    let encoded_length = ((real_length * 8) + 5) / 6;\n    let final_length = encoded_length\n        + if HasPadding == 1 {\n            CONVERT_MODULO3_TO_PADDING_BYTES[real_length_mod_3]\n        } else {\n            0\n        };\n\n    // Get an array of Field elements where boundary_flags[i] = 0 if i < encoded_length, otherwise i = 1.\n    // We use this array to determine if the result array should contain a valid Base64 encoded value, 0 or if an error state has been reached\n    let boundary_flags: [Field; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] =\n        boundary_check(encoded_length);\n\n    // Using 2 lookups is slightly cheaper than figuring out if the 1st/2nd padding byte is set from the padding length param... I think?\n    let has_first_padding_byte = if HasPadding == 1 {\n        PAD_1[real_length_mod_3]\n    } else {\n        0\n    };\n    let has_second_padding_byte = if HasPadding == 1 {\n        PAD_2[real_length_mod_3]\n    } else {\n        0\n    };\n\n    // If we have actual data to iterate through, populate the 1st result entry with the base64 encoding of `raw[0]`.\n    // Note: if `boundary_flags[0] = 1`, the `BASE64_ENCODE_BE_VAR_TABLE` lookup will output 0.\n    // Note: `MAX_INPUT_LEN` is known at compile time so this `if` statement should not incur constraints.\n    if MAX_INPUT_LEN > 0 {\n        result_arr[0] = BASE64_ENCODE_BE_VAR_TABLE[raw[0] as Field + boundary_flags[0] * 64] as u8;\n    }\n\n    let mut previous_was_first_padding_byte = 0;\n    for i in 1..output_length {\n        let exceed_length = boundary_flags[i];\n        // hit_limit = we are at the first location where a padding Base64 character *could* be enerated\n\n        let mut encoding_index: Field = 0;\n\n        if HasPadding == 1 {\n            let hit_limit: Field = (1 - boundary_flags[i - 1]) * boundary_flags[i];\n            // We need to write a padding byte if `i == encoding_length` and `has_first_padding_byte == 1`\n            let write_first_padding_byte: Field = hit_limit * has_first_padding_byte;\n            // We need to write a padding byte if `i == encoding_length + 1` and `has_second_padding_byte == 1`\n            let write_second_padding_byte =\n                previous_was_first_padding_byte * has_second_padding_byte;\n\n            // Look up the encoded Base64 value given an input 6-bit chunk.\n            // We have 2 edge cases that we need to handle efficiently (writing padding bytes or we have exceeded the input length)\n            // Instead of expensive conditional logic we apply lookup tables as a quasi state machine to handle these edge cases.\n            // CASE 1: `exceed_length = 0`, `write_first_padding_byte = 0`, `write_second_padding_byte = 0`\n            //      outcome: we map the 6-bit input value into a Base64 encoding\n            // CASE 2: `exceed_length = 1` AND `write_first_padding_byte = 0` AND `write_second_padding_byte = 0`\n            //      outcome: if `raw[i] = 0`, the returned value is 0. All other inputs for `raw[i]` return an error state\n            // CASE 3: `exceed_length = 1` AND ()`write_first_padding_byte = 1` OR `write_second_padding_byte = 1`)\n            //      outcome: if `raw[i] = 0`, the returned value is BASE64_PADDING_CHAR. All other inputs for `raw[i]` return an error state\n            // Note: due to how they are constructed, it is not possible for both `write_first_padding_byte` and `write_second_padding_byte` to equal 1.\n            //       Similarly, it is not possible for `exceed_length = 0` and either of `write_first_padding_byte` or `write_second_padding_byte` to equal 1.\n            encoding_index = raw[i] as Field\n                + (exceed_length + write_first_padding_byte + write_second_padding_byte) * 64;\n            previous_was_first_padding_byte = write_first_padding_byte;\n        } else {\n            // We have 2 edge cases that we need to handle efficiently (writing padding bytes or we have exceeded the input length)\n            // Instead of expensive conditional logic we apply lookup tables as a quasi state machine to handle these edge cases.\n            // CASE 1: `exceed_length = 0`\n            //      outcome: we map the 6-bit input value into a Base64 encoding\n            // CASE 2: `exceed_length = 1`\n            //      outcome: if `raw[i] = 0`, the returned value is 0. All other inputs for `raw[i]` return an error state\n\n            encoding_index = raw[i] as Field + (exceed_length * 64);\n        }\n\n        // Note: this `if` condition is known at compile time so should not incur additional constraints\n        let token: u8 = if UseURLTable == 1 {\n            BASE64_ENCODE_BE_VAR_TABLE[encoding_index]\n        } else {\n            BASE64URL_ENCODE_BE_VAR_TABLE[encoding_index]\n        };\n        (token as Field).assert_max_bit_size::<7>();\n        result_arr[i] = token;\n    }\n\n    // we can use `from_parts_unchecked` here because the table BASE64_ENCODE_BE_VAR_TABLE (and it's URL equivalent)\n    // will produce an error if a nonzero input is given past `final_length`\n    let mut r: BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))> =\n        BoundedVec::from_parts_unchecked(result_arr, final_length);\n\n    r\n}\n\n/**\n * @brief Take an array of ASCII bytes and convert into an array of six-bit chunks\n **/\nfn split_into_six_bit_chunks<let InputBytes: u32, let OutputElements: u32, let HasPadding: u32>(\n    input: [u8; InputBytes],\n) -> [u8; OutputElements] {\n    // Calculate the number of padding characters and the length of the output without padding\n\n    // input bytes modulo 3 . e.g.\n\n    // input = 5 implies 1 padding char = 40 bits of data = 6 base64 vals + 2 bits\n    // 1 is padding so we have 5 base64 vals\n    let rem = InputBytes % 3;\n    let num_padding_chars = if HasPadding == 1 {\n        if rem == 1 {\n            2\n        } else if rem == 2 {\n            1\n        } else {\n            0\n        }\n    } else {\n        0\n    };\n\n    let mut result: [u8; OutputElements] = [0; OutputElements];\n\n    let num_chunks = (InputBytes / BYTES_PER_CHUNK) + (InputBytes % BYTES_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            // pack the bytes into the field element\n            let mut slice: Field = 0;\n            for j in 0..BYTES_PER_CHUNK {\n                slice *= 256;\n                slice += input[i * BYTES_PER_CHUNK + j] as Field;\n            }\n            // extract the 6-bit values from the Field element\n            let slice_base64_chunks: [u8; BASE64_ELEMENTS_PER_CHUNK] = slice.to_be_radix(64);\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                result[i * BASE64_ELEMENTS_PER_CHUNK + j] = slice_base64_chunks[j];\n            }\n        }\n\n        // process the final chunk, which may require padding\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_offset = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let bytes_in_final_chunk = InputBytes - byte_offset;\n        let num_elements_in_final_chunk = OutputElements - base64_offset;\n\n        // pack the bytes into the field element\n        let mut slice: Field = 0;\n        for j in 0..bytes_in_final_chunk {\n            slice *= 256;\n            slice += input[(num_chunks - 1) * BYTES_PER_CHUNK + j] as Field;\n        }\n        for _ in bytes_in_final_chunk..BYTES_PER_CHUNK {\n            slice *= 256;\n        }\n\n        // extract the 6-bit values from the Field element\n        let slice_base64_chunks: [u8; BASE64_ELEMENTS_PER_CHUNK] = slice.to_be_radix(64);\n        for i in 0..num_elements_in_final_chunk {\n            // If padding is enabled, we can skip setting the last `non_padded_output_length` chars\n            // N.B. if statement is compile time so shouldn't add c onstraints\n            if HasPadding == 1 {\n                let non_padded_output_length = OutputElements - num_padding_chars;\n                if (base64_offset + i < non_padded_output_length) {\n                    result[base64_offset + i] = slice_base64_chunks[i];\n                }\n            } else {\n                result[base64_offset + i] = slice_base64_chunks[i];\n            }\n        }\n    }\n\n    result\n}\n\nfn encode<let InputBytes: u32, let UseUrlTable: u1, let UsePadding: u32>(\n    input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * (1 + UsePadding * 2)) + (((InputBytes % 3) / 2) * (1 + UsePadding))] {\n    assert((UsePadding == 0 as u32) | (UsePadding == 1 as u32), \"UsePadding must be 0 or 1\");\n    let mut result = crate::encoder::encode_elements::<_, UseUrlTable>(\n        crate::encoder::split_into_six_bit_chunks::<_, _, UsePadding>(input),\n    );\n    // this relationship should be evaluated at compile time\n    let OutputElements = ((InputBytes * 8) / 6)\n        + (((InputBytes % 3) % 2) * (1 + UsePadding * 2))\n        + (((InputBytes % 3) / 2) * (1 + UsePadding));\n    if UsePadding == 1 {\n        // handle padding\n        let rem = InputBytes % 3;\n        if (rem == 1) {\n            result[OutputElements - 1] = BASE64_PADDING_CHAR;\n            result[OutputElements - 2] = BASE64_PADDING_CHAR;\n        } else if (rem == 2) {\n            result[OutputElements - 1] = BASE64_PADDING_CHAR;\n        }\n    }\n    result\n}\n\n// === TESTS ======================================================================================\n\n#[test]\nfn test_encode_elements() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII (with the = padding character stripped)\n    let ascii_expected: [u8; 43] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85,\n    ];\n\n    let input: [u8; 43] = [\n        6, 49, 12, 37, 32, 48, 11, 34, 50, 41, 39, 21, 43, 4, 54, 2, 52, 18, 31, 56, 50, 51, 33, 28,\n        22, 19, 36, 0, 33, 18, 25, 57, 62, 22, 4, 17, 33, 10, 33, 23, 45, 37, 20,\n    ];\n\n    let ascii_result = crate::encoder::encode_elements::<_, 0>(input);\n\n    assert(ascii_result == ascii_expected);\n}\n\n#[test]\nfn test_encode_empty() {\n    let input: [u8; 0] = [];\n    let result = Base64EncodeBE::encode(input);\n    let expected: [u8; 0] = [];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_padding() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 4] = [90, 103, 61, 61];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 4] = [90, 109, 56, 61];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_standard_no_pad() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 2] = [90, 103];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 3] = [90, 109, 56];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_max_byte() {\n    let input: [u8; 1] = [255];\n\n    let result: [u8; 4] = Base64EncodeBE::encode(input);\n    let expected: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    assert(result == expected);\n\n    let result: [u8; 2] = Base64EncodeBENoPad::encode(input);\n    let expected: [u8; 2] = [47, 119]; // \"/w\"\n    assert(result == expected);\n\n    let result: [u8; 4] = Base64EncodeBEUrlSafeWithPad::encode(input);\n    let expected: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    assert(result == expected);\n\n    let result: [u8; 2] = Base64EncodeBEUrlSafe::encode(input);\n    let expected: [u8; 2] = [95, 119]; // \"_w\"\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_ascii() {\n    // \"Hello World!\"\n    let input: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n    // base64: SGVsbG8gV29ybGQh\n    let expected: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_utf8() {\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let input: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let expected: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let input: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let expected: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n\n    let expected: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_standard() {\n    // test encoding to / and +\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 4] = [47, 43, 65, 61];\n    let result: [u8; 4] = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_url_safe_with_pad() {\n    // test encoding to _ and -\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 4] = [95, 45, 65, 61];\n    let result: [u8; 4] = Base64EncodeBEUrlSafeWithPad::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_url_safe() {\n    // test encoding to _ and -\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 3] = [95, 45, 65];\n    let result: [u8; 3] = Base64EncodeBEUrlSafe::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU\n    // Translated directly to ASCII (with padding byte character stripped)\n    let expected: [u8; 43] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85,\n    ];\n\n    let input: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_base64_encode_slash() {\n    let input: [u8; 1] = [63]; // '/' in Base64\n    let result: [u8; 1] = crate::encoder::encode_elements::<_, 0>(input);\n\n    // Should map to '/' in ASCII, which is 47\n    assert(result[0] == 47);\n}\n\n#[test]\nfn test_encode_var_empty() {\n    let input: BoundedVec<u8, 3> = BoundedVec::new();\n    let result = Base64EncodeBE::encode_var(input);\n    let expected: BoundedVec<u8, 4> = BoundedVec::new();\n    assert(result == expected);\n\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64EncodeBE::encode_var(input);\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var() {\n    // \"Hello, World!\"\n    let input: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let expected: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let expected_no_pad: BoundedVec<u8, 22> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode_var(input);\n    println(f\"result = {result}\");\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode_var(input);\n    assert(result == expected_no_pad);\n    let result = Base64EncodeBEUrlSafeWithPad::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafe::encode_var(input);\n    assert(result == expected_no_pad);\n}\n\n#[test]\nfn test_encode_var_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let input: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let expected: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let expected_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode_var(input);\n    assert(result == expected_no_pad);\n    let result = Base64EncodeBEUrlSafeWithPad::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafe::encode_var(input);\n    assert(result == expected_no_pad);\n}\n","path":"/Users/zac/noir_base64/src/encoder.nr"},"67":{"source":"use crate::decoder::{Base64DecodeBE, Base64DecodeBENoPad};\nuse crate::encoder::{Base64EncodeBE, Base64EncodeBENoPad, Base64EncodeBEUrlSafe};\n\n#[export]\nfn bench_encode_610(input: [u8; 610]) -> [u8; 816] {\n    Base64EncodeBE::encode(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBEUrlSafe::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 816> {\n    Base64EncodeBE::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBEUrlSafe::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_no_pad(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBENoPad::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var_no_pad(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBENoPad::encode_var(input)\n}\n\n#[export]\nfn bench_decode_610(input: [u8; 816]) -> [u8; 610] {\n    (Base64DecodeBE::decode(input))\n}\n\n#[export]\nfn bench_decode_610_var(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBE::decode_var(input));\n    r\n}\n\n#[export]\nfn bench_decode_610_no_pad(input: [[u8; 816]; 3]) -> [[u8; 610]; 3] {\n    let mut r: [[u8; 610]; 3] = [[0; 610]; 3];\n    for i in 0..3 {\n        r[i] = (Base64DecodeBENoPad::decode(input[i]));\n    }\n    r\n}\n\n#[export]\nfn bench_decode_610_var_no_pad(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBENoPad::decode_var(input));\n    r\n}\n\n","path":"/Users/zac/noir_base64/src/benchmarks/mod.nr"}},"names":["bench_encode_610_no_pad"],"brillig_names":["directive_to_radix"]}