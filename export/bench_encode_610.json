{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":1853412407085507866,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":610,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":816,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"5d3LjiTGcYXhd5k1FxWRWRkRehXDEChehAEIkuDFgEHw3Z2USUmADXnhwqB+/Lup7uyeOKtzVl//8uHLr/7y81///PHbr7/78cOf/u2XD99898XnP3387tv76ZcPJx5/++KP33/+7W+ff/zp8x9++vCnfMxnH7769sv7r9W/fvbh64/ffPXhT6d+/ex/PK2q3592nn883f/L09g5j98fx17P/j+eZz7//jzzt//9Xz1/7sf5/fVz5/7745hf//2zGzQsQdMSdFmCbkvQpyXosQQtS9C2BB1J0LQso7Qso7Qso7Qso9yWoJZllJZllJZllJZllJZltCzLaFmW0bIso2VZRmtbglqW0bIso2VZRsuyjJZlGW3LMtqWZbQty2hbltHelqCWZbQty2hbltG2LKNtWUZPyzJ6WpbR07KMnpZl9NyWoJZl9LQso6dlGT0ty+hpWUbHsoyOZRkdyzI6lmV0tiWoZRkdyzI6lmV0LMvoWJZRWZZRWZZRWZZRWZZRbUtQyzIqyzIqyzIqyzIqyzJqyzJqyzJqyzJqyzLqbQlqWUZtWUZtWUZtWUZtWUZjWUZjWUZjWUZjWUazLUEty2gsy2gsy2gsy2gky6gekmVUD8kyqodkGdVDsozqsS1BJcuoHpJlVA/JMqqHZBnVw7KMLAZ2WQzsshjYZTGwy2Jgl8XALouBXRYDuywGdlkM7LIY2GUxsMtiYJfFwC6LgV0WA7ssBnZZDOyyGNhlMbDLYmCXxcAui4FdFgO7LAZ2WQzsshjYZTGwy2Jgl8XALouBXRYDuywGdlkM7LIY2GUxsMtiYJfFwC6LgV0WA7ssBnZZDOyyGNhlMbDLYmCXxcAui4FdFgO7LAZ2WQzsshjYZTGwy2Jgl8XALouBXRYDuywGdlkM7LIY2GUxsMtiYJfFwC6LgV0WA7ssBnZZDOyyGNhlMbDLYmCXxcAui4FdFgO7LAZ2WQzsshjYZTGwy2Jgl8XALouBXRYDuywGdlkM7LIY2GUxsMtiYJfFwC6LgV0WA7ssBnZZDOy2GNhtMbDbYmC3xcDux7YElSyjthjYbTGw22Jgt8XAbouB3RYDuy0GdlsM7LYY2G0xsNtiYLfFwG6Lgd0WA7stBnZbDOy2GNhtMbDbYmC3xcBui4HdFgO7LQZ2WwzsthjYbTGw22Jgt8XAbouB3RYDuy0GdlsM7LYY2G0xsNtiYLfFwG6Lgd0WA7stBnZbDOy2GNhtMbDbYmC3xcBui4HdFgO7LQZ2WwzsthjYbTGw22Jgt8XAbouB3RYDuy0GdlsM7LYY2G0xsNtiYLfFwG6Lgd0WA7stBnZbDOy2GNhtMbDbYmC3xcBui4HdFgO7LQZ2WwzsthjYbTGw22Jgt8XAbouB3RYDuy0GdlsM7LYY2G0xsNtiYLfFwG6Lgd0WA7stBnZbDOy2GNhtMbDbYmC3xcBui4HdFgN7LAb2WAzssRjYYzGw57EtQSXLaCwG9lgM7LEY2GMxsMdiYI/FwB6LgT0WA3ssBvZYDOyxGNhjMbDHYmCPxcAei4E9FgN7LAb2WAzssRjYYzGwx2Jgj8XAHouBPRYDeywG9lgM7LEY2GMxsMdiYI/FwB6LgT0WA3ssBvZYDOyxGNhjMbDHYmCPxcAei4E9FgN7LAb2WAzssRjYYzGwx2Jgj8XAHouBPRYDeywG9lgM7LEY2GMxsMdiYI/FwB6LgT0WA3ssBvZYDOyxGNhjMbDHYmCPxcAei4E9FgN7LAb2WAzssRjYYzGwx2Jgj8XAHouBPRYDeywG9lgM7LEY2GMxsMdiYI/FwB6LgT0WA3ssBvZYDOyxGNhjMbDHYmCPxcAei4E9FgN7LAb2WAzssRjYYzGwx2Jgj8XAjocFwb5JJdvoJpWMo5tUso5u0q1JKtlHN6lkIN2kkoV0k0om0k2q2UgWDvsm1WwkC4h9k2o2koXEvkk1G8mCYt+kmo1kYbFvUs1GssDYN6lmI1lo7JtUs5EsOPZNqtlIFh77JtVsJAuQfZNqNpKFyL5JNRvJgmTfpJqNZGGyb1LNRrJA2TepZiNZqOybVLORLFj2TarZSBYu+ybVbCQLmH2TajaShcy+STUbyYJm36SajWRhs29SzUaywNk3qWYjWejsm1SzkSx49k2q2UgWPvsm1WwkC6B9k2o2koXQvkk1G8mCaN+kmo1kYbRvUs1GskDaN6lmI1ko7ZtUs5EsmPZNqtlIFk77JtVsJAuofZNqNpKF1L5JNRvJgmrfpJqNZGG1b1LNRrLA2jepZiNZaO2bVLORLLj2TarZSBZe+ybVbCQLsH2TajaShdi+STUbyYJs36SajWRhtm9Sy0YKjbMdGmc7NM52aJzteGxNUstGCo2zHRpnOzTOdmic7dA426FxtkPjbIfG2Q6Nsx0aZzs0znZonO3QONuhcbZD42yHxtkOjbMdGmc7NM52aJzt0DjboXG2Q+Nsh8bZDo2zHRpnOzTOdmic7dA426FxtkPjbIfG2Q6Nsx0aZzs0znZonO3QONuhcbZD42yHxtkOjbMdGmc7NM52aJzt0DjboXG2Q+Nsh8bZDo2zHRpnOzTOdmic7dA426FxtkPjbIfG2Q6Nsx0aZzs0znZonO3QONuhcbZD42yHxtkOjbMdGmc7NM52aJzt0DjboXG2Q+Nsh8bZDo2zHRpnOzTOdmic7dA426FxtkPjbIfG2Q6Nsx0aZzs0znZonO3QONuhcbZD42yHxtkOjbMdGmc7NM52aJzt0DjboXG2U+Nsp8bZTo2znRpnOx9bk9SykVLjbKfG2U6Ns50aZzs1znZqnO3UONupcbZT42ynxtlOjbOdGmc7Nc52apzt1DjbqXG2U+Nsp8bZTo2znRpnOzXOdmqc7dQ426lxtlPjbKfG2U6Ns50aZzs1znZqnO3UONupcbZT42ynxtlOjbOdGmc7Nc52apzt1DjbqXG2U+Nsp8bZTo2znRpnOzXOdmqc7dQ426lxtlPjbKfG2U6Ns50aZzs1znZqnO3UONupcbZT42ynxtlOjbOdGmc7Nc52apzt1DjbqXG2U+Nsp8bZTo2znRpnOzXOdmqc7dQ426lxtlPjbKfG2U6Ns50aZzs1znZqnO3UONupcbZT42ynxtlOjbOdGmc7Nc52apzt1DjbqXG2U+Nsp8bZTo2znRpnOzXOdmqc7aVxtpfG2V4aZ3tpnO312Jqklo20NM720jjbS+NsL42zvTTO9tI420vjbC+Ns700zvbSONtL42wvjbO9NM720jjbS+NsL42zvTTO9tI420vjbC+Ns700zvbSONtL42wvjbO9NM720jjbS+NsL42zvTTO9tI420vjbC+Ns700zvbSONtL42wvjbO9NM720jjbS+NsL42zvTTO9tI420vjbC+Ns700zvbSONtL42wvjbO9NM720jjbS+NsL42zvTTO9tI420vjbC+Ns700zvbSONtL42wvjbO9NM720jjbS+NsL42zvTTO9tI420vjbC+Ns700zvbSONtL42wvjbO9NM720jjbS+NsL42zvTTO9tI420vjbC+Ns700zvbSONtL42wvjbO9NM720jjbS+NsL42zvTTO9tI420vjbC+Ns700zvbSONtb42xvjbO9Nc721jjb+7E1SS0baWuc7a1xtrfG2d4aZ3trnO2tcba3xtneGmd7a5ztrXG2t8bZ3hpne2uc7a1xtrfG2d4aZ3trnO2tcba3xtneGmd7a5ztrXG2t8bZ3hpne2uc7a1xtrfG2d4aZ3trnO2tcba3xtneGmd7a5ztrXG2t8bZ3hpne2uc7a1xtrfG2d4aZ3trnO2tcba3xtneGmd7v7OzvTL++N2//fnS/f9M+sYb6cVJ33gjvTjpG2+kFyfdmqRvvJFenPSNN9KLk77xRnpx0jfeSC9O+sYb6bVJ39nZfnFSzUZ6Z2f7xUk1G+mdne0XJ9VspHd2tl+cVLOR3tnZfnFSzUZ6Z2f7xUk1G+mdne0XJ9VspHd2tl+cVLOR3tnZfnFSzUZ6Z2f7xUk1G+mdne0XJ9VspHd2tl+cVLOR3tnZfnFSzUZ6Z2f7xUk1G+mdne0XJ9VspHd2tl+cVLORPrGzveIfSc/zXz9f1X9csTrjnx//9+mLe/rmnv7knn64pxf39OaePtTTn5/Ye37p6cE9Hdumzwe2TZ8PbJs+H9g2fT6wbfp8YNv0+cC26fPBbdPgtmlw2zS4bRrcNv3Euu5LT+e2aXDbNLhtGtw2DW6bJrdNk9umyW3T5LbpJ3ZYX3o6t02T26bJbdPktmly23Rx23Rx23Rx23Rx2/QTi50vPZ3bpovbpovbpovbpovbppvbppvbppvbppvbpp/Ydnzp6dw23dw23dw23dw23dw2fXLb9Mlt0ye3TZ/cNv3ECuBLT+e26ZPbpk9umz65bfrktunhtunhtunhtunhtukn9uJeejq3TQ+3TQ+3TQ+3TQ+3TYvbpsVt0+K2aXHb9BPLYi89ndumxW3T4rZpcdu0uG3a3DZtbps2t02b26af2KB66encNm1umza3TZvbps1t0+G26XDblGshPbkW0pNrIT25FtKTayE9uRbSk2shPbkW0uFaSIdrIR2uhXS4FtJ5YNv0cC2kw7WQDtdCOlwL6XAtpMO1kA7XQjpcC+lwLaTDtZAO10I6XAvpcC2kw7WQDtdCOlwL6XAtpMO1kA7XQjpcC+lwLaTDtZAO10I6XAvpcC2kw7WQDtdCOlwL6XAtpMO1kA7XQjpcC+lwLaTDtZAO10I6XAvpcC2kw7WQDtdCOlwL6XAtpMO1kA7XQjpcC+lwLaTDtZAO10I6XAvpcC2kw7WQDtdCOlwL6XAtpMO1kA7XQjpcC+lwLaTDtZAO10I6XAvpcC2kw7WQDtdCOlwL6XAtpMO1kA7XQjpcC+lwLaTDtZAO10I6XAvpcC2kw7WQDtdCOlwL6XAtpMO1kA7XQjpcC+lwLaTDtZAO10I6XAvpcC2kw7WQDtdCOlwL6XAtpMO1kA7XQjpcC+lwLaTDtZAO10IqroVUXAupuBZScS2kemDbtLgWUnEtpOJaSMW1kIprIRXXQiquhVRcC6m4FlJxLaTiWkjFtZCKayEV10IqroVUXAupuBZScS2k4lpIxbWQimshFddCKq6FVFwLqbgWUnEtpOJaSMW1kIprIRXXQiquhVRcC6m4FlJxLaTiWkjFtZCKayEV10IqroVUXAupuBZScS2k4lpIxbWQimshFddCKq6FVFwLqbgWUnEtpOJaSMW1kIprIRXXQiquhVRcC6m4FlJxLaTiWkjFtZCKayEV10IqroVUXAupuBZScS2k4lpIxbWQimshFddCKq6FVFwLqbgWUnEtpOJaSMW1kIprIRXXQiquhVRcC6m4FlJxLaTiWkjFtZCKayEV10IqroVUXAupuBZScS2k4lpIxbWQimshFddCKq6F1FwLqbkWUnMtpOZaSP3AtmlzLaTmWkjNtZCaayE110JqroXUXAupuRZScy2k5lpIzbWQmmshNddCaq6F1FwLqbkWUnMtpOZaSM21kJprITXXQmquhdRcC6m5FlJzLaTmWkjNtZCaayE110JqroXUXAupuRZScy2k5lpIzbWQmmshNddCaq6F1FwLqbkWUnMtpOZaSM21kJprITXXQmquhdRcC6m5FlJzLaTmWkjNtZCaayE110JqroXUXAupuRZScy2k5lpIzbWQmmshNddCaq6F1FwLqbkWUnMtpOZaSM21kJprITXXQmquhdRcC6m5FlJzLaTmWkjNtZCaayE110JqroXUXAupuRZScy2k5lpIzbWQmmshNddCaq6F1FwLqbkWUnMtpOZaSM21kJprITXXQmquhdRcC2m4FtJwLaThWkjDtZDmgW3T4VpIw7WQhmshDddCGq6FNFwLabgW0nAtpOFaSMO1kIZrIQ3XQhquhTRcC2m4FtJwLaThWkjDtZCGayEN10IaroU0XAtpuBbScC2k4VpIw7WQhmshDddCGq6FNFwLabgW0nAtpOFaSMO1kIZrIQ3XQhquhTRcC2m4FtJwLaThWkjDtZCGayEN10IaroU0XAtpuBbScC2k4VpIw7WQhmshDddCGq6FNFwLabgW0nAtpOFaSMO1kIZrIQ3XQhquhTRcC2m4FtJwLaThWkjDtZCGayEN10IaroU0XAtpuBbScC2k4VpIw7WQhmshDddCGq6FNFwLabgW0nAtpOFaSMO1kIZrIQ3XQhquhTRcC2m4FtJwLaThWkjDtZCGayEN10IaroU0XAtpsBZSPrAW0j2d2qb3dGqb3tOpbXpPp7bpPZ3apvd0apve06ltek+ntuk9ndumWAvpns5tU6yFdE/ntinWQrqnc9sUayHd07ltirWQ7uncNsVaSPd0bptiLaR7OrdNsRbSPZ3bplgL6Z7ObVOshXRP57Yp1kK6p3PbFGsh3dO5bYq1kO7p3DbFWkj3dG6bYi2kezq3TbEW0j2d26ZYC+mezm1TrIV0T+e2KdZCuqdz2xRrId3TuW2KtZDu6dw2xVpI93Rum2ItpHs6t02xFtI9ndumWAvpns5tU6yFdE/ntinWQrqnc9sUayHd07ltirWQ7uncNsVaSPd0bptiLaR7OrdNsRbSPZ3bplgL6Z7ObVOshXRP57Yp1kK6p3PbFGsh3dO5bYq1kO7p3DbFWkj3dG6bYi2kezq3TbEW0j2d26ZYC+meyG1TrIV0T+S2KdZCuidy2xRrId0TuW2KtZDuidg2Da6FFFwLKbgWUnAtpHhg2zS4FlJwLaTgWkjBtZCCayEF10IKroUUXAspuBZScC2k4FpIwbWQgmshBddCCq6FFFwLKbgWUnAtpOBaSMG1kIJrIQXXQgquhRRcCym4FlJwLaTgWkjBtZCCayEF10IKroUUXAspuBZScC2k4FpIwbWQgmshBddCCq6FFFwLKbgWUnAtpOBaSMG1kIJrIQXXQgquhRRcCym4FlJwLaTgWkjBtZCCayEF10IKroUUXAspuBZScC2k4FpIwbWQgmshBddCCq6FFFwLKbgWUnAtpOBaSMG1kIJrIQXXQgquhRRcCym4FlJwLaTgWkjBtZCCayEF10IKroUUXAspuBZScC2k4FpIwbWQgmshBddCCq6FFFwLKbgWUnAtpOBaSMG1kIJrIQXXQgquhZRcCym5FlJyLaTkWkj5wLZpci2k5FpIybWQkmshJddCSq6FlFwLKbkWUnItpORaSMm1kJJrISXXQkquhZRcCym5FlJyLaTkWkjJtZCSayEl10JKroWUXAspuRZSci2k5FpIybWQkmshJddCSq6FlFwLKbkWUnItpORaSMm1kJJrISXXQkquhZRcCym5FlJyLaTkWkjJtZCSayEl10JKroWUXAspuRZSci2k5FpIybWQkmshJddCSq6FlFwLKbkWUnItpORaSMm1kJJrISXXQkquhZRcCym5FlJyLaTkWkjJtZCSayEl10JKroWUXAspuRZSci2k5FpIybWQkmshJddCSq6FlFwLKbkWUnItpORaSMm1kJJrISXXQkquhZRcCym5FlJyLaTkWkjJtZCSayEl10JKroWUXAtpcS2kxbWQFtdCWlwLaT2wbbq4FtLiWkiLayEtroW0uBbS4lpIi2shLa6FtLgW0uJaSItrIS2uhbS4FtLiWkiLayEtroW0uBbS4lpIi2shLa6FtLgW0uJaSItrIS2uhbS4FtLiWkiLayEtroW0uBbS4lpIi2shLa6FtLgW0uJaSItrIS2uhbS4FtLiWkiLayEtroW0uBbS4lpIi2shLa6FtLgW0uJaSItrIS2uhbS4FtLiWkiLayEtroW0uBbS4lpIi2shLa6FtLgW0uJaSItrIS2uhbS4FtLiWkiLayEtroW0uBbSglpI98Nffvj4zTcf//rnb7774vOfPn737Y/3R++X/+PzHz5+/pdvvvr949c/f/vFP333p//8/o/v/PHz3//w3RdfffnzD1/99pv+9r376/8L","file_map":{"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"64":{"source":"use super::defaults::{BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK};\n\nuse crate::tables::{\n    BASE64_ENCODE_BE_TABLE, BASE64_ENCODE_BE_VAR_TABLE, BASE64URL_ENCODE_BE_TABLE,\n    BASE64URL_ENCODE_BE_VAR_TABLE,\n};\n\npub use crate::boundary_check::boundary_check;\n\nglobal CONVERT_MODULO3_TO_PADDING_BYTES: [u32; 3] = [0, 2, 1];\nglobal PAD_1: [Field; 3] = [0, 1, 1];\nglobal PAD_2: [Field; 3] = [0, 1, 0];\n\n// Encoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64EncodeBE {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * 3) + (((InputBytes % 3) / 2) * 2)] {\n        crate::encoder::encode::<InputBytes, 0, 1>(input)\n    }\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * 3) + (((MAX_INPUT_LEN % 3) / 2) * 2)> {\n        crate::encoder::encode_var::<_, 0, 1>(input)\n    }\n}\n\n// Encoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64EncodeBENoPad {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2)) + (((InputBytes % 3) / 2))] {\n        crate::encoder::encode::<InputBytes, 0, 0>(input)\n    }\n\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, (((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2)) + (((MAX_INPUT_LEN % 3) / 2)))> {\n        crate::encoder::encode_var::<_, 0, 0>(input)\n    }\n}\n\n// Encoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64EncodeBEUrlSafe {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2)) + (((InputBytes % 3) / 2))] {\n        crate::encoder::encode::<_, 1, 0>(input)\n    }\n\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, (((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2)) + (((MAX_INPUT_LEN % 3) / 2)))> {\n        crate::encoder::encode_var::<_, 1, 0>(input)\n    }\n}\n\n// Encoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64EncodeBEUrlSafeWithPad {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * 3) + (((InputBytes % 3) / 2) * 2)] {\n        crate::encoder::encode::<_, 1, 1>(input)\n    }\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * 3) + (((MAX_INPUT_LEN % 3) / 2) * 2)> {\n        crate::encoder::encode_var::<_, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Take an array of ASCII values and convert into base64 values\n * @tparam InputElements: The size of the array being encoded\n * @tparam UseUrlTable: are we encoding using the URL and Filename Safe Alphabet, or standard Base64 Alphabet? \n **/\nfn encode_elements<let InputElements: u32, let UseUrlTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; InputElements] {\n    let mut result: [u8; InputElements] = [0; InputElements];\n\n    for i in 0..InputElements {\n        let token: u8 = if UseUrlTable == 1 {\n            BASE64URL_ENCODE_BE_TABLE[input[i]]\n        } else {\n            BASE64_ENCODE_BE_TABLE[input[i]]\n        };\n        result[i] = token as u8;\n    }\n\n    result\n}\n\n/**\n * @brief Encode a variable-length ASCII string into Base64 values\n **/\nfn encode_var<let MAX_INPUT_LEN: u32, let UseURLTable: u1, let HasPadding: u32>(\n    input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))> {\n    assert((HasPadding == 0) | (HasPadding == 1), \"invalid HasPadding parameter\");\n    // The max number of output Base64 values can be derived from the max input size\n    let mut result_arr: [u8; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] = [\n        0; ((MAX_INPUT_LEN * 8) / 6)\n            + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2))\n            + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))\n    ];\n\n    // Note: is this correct?\n    let output_length = ((MAX_INPUT_LEN * 8) / 6)\n        + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2))\n        + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding));\n\n    // Step 1: convert the input into six-bit chunks. We can map each chunk into Base64 values.\n    let raw: [u8; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] =\n        crate::encoder::split_into_six_bit_chunks::<_, _, 1>(input.storage());\n\n    let real_length = input.len();\n    // The input length modulo 3 can be used to determine the number of padding bytes\n    let real_length_mod_3 = if HasPadding == 1 { real_length % 3 } else { 0 };\n    // encoded_length = the number of Base64 values minus padding\n    let encoded_length = ((real_length * 8) + 5) / 6;\n    let final_length = encoded_length\n        + if HasPadding == 1 {\n            CONVERT_MODULO3_TO_PADDING_BYTES[real_length_mod_3]\n        } else {\n            0\n        };\n\n    // Get an array of Field elements where boundary_flags[i] = 0 if i < encoded_length, otherwise i = 1.\n    // We use this array to determine if the result array should contain a valid Base64 encoded value, 0 or if an error state has been reached\n    let boundary_flags: [Field; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] =\n        boundary_check(encoded_length);\n\n    // Using 2 lookups is slightly cheaper than figuring out if the 1st/2nd padding byte is set from the padding length param... I think?\n    let has_first_padding_byte = if HasPadding == 1 {\n        PAD_1[real_length_mod_3]\n    } else {\n        0\n    };\n    let has_second_padding_byte = if HasPadding == 1 {\n        PAD_2[real_length_mod_3]\n    } else {\n        0\n    };\n\n    // If we have actual data to iterate through, populate the 1st result entry with the base64 encoding of `raw[0]`.\n    // Note: if `boundary_flags[0] = 1`, the `BASE64_ENCODE_BE_VAR_TABLE` lookup will output 0.\n    // Note: `MAX_INPUT_LEN` is known at compile time so this `if` statement should not incur constraints.\n    if MAX_INPUT_LEN > 0 {\n        result_arr[0] = BASE64_ENCODE_BE_VAR_TABLE[raw[0] as Field + boundary_flags[0] * 64] as u8;\n    }\n\n    let mut previous_was_first_padding_byte = 0;\n    for i in 1..output_length {\n        let exceed_length = boundary_flags[i];\n        // hit_limit = we are at the first location where a padding Base64 character *could* be enerated\n\n        let mut encoding_index: Field = 0;\n\n        if HasPadding == 1 {\n            let hit_limit: Field = (1 - boundary_flags[i - 1]) * boundary_flags[i];\n            // We need to write a padding byte if `i == encoding_length` and `has_first_padding_byte == 1`\n            let write_first_padding_byte: Field = hit_limit * has_first_padding_byte;\n            // We need to write a padding byte if `i == encoding_length + 1` and `has_second_padding_byte == 1`\n            let write_second_padding_byte =\n                previous_was_first_padding_byte * has_second_padding_byte;\n\n            // Look up the encoded Base64 value given an input 6-bit chunk.\n            // We have 2 edge cases that we need to handle efficiently (writing padding bytes or we have exceeded the input length)\n            // Instead of expensive conditional logic we apply lookup tables as a quasi state machine to handle these edge cases.\n            // CASE 1: `exceed_length = 0`, `write_first_padding_byte = 0`, `write_second_padding_byte = 0`\n            //      outcome: we map the 6-bit input value into a Base64 encoding\n            // CASE 2: `exceed_length = 1` AND `write_first_padding_byte = 0` AND `write_second_padding_byte = 0`\n            //      outcome: if `raw[i] = 0`, the returned value is 0. All other inputs for `raw[i]` return an error state\n            // CASE 3: `exceed_length = 1` AND ()`write_first_padding_byte = 1` OR `write_second_padding_byte = 1`)\n            //      outcome: if `raw[i] = 0`, the returned value is BASE64_PADDING_CHAR. All other inputs for `raw[i]` return an error state\n            // Note: due to how they are constructed, it is not possible for both `write_first_padding_byte` and `write_second_padding_byte` to equal 1.\n            //       Similarly, it is not possible for `exceed_length = 0` and either of `write_first_padding_byte` or `write_second_padding_byte` to equal 1.\n            encoding_index = raw[i] as Field\n                + (exceed_length + write_first_padding_byte + write_second_padding_byte) * 64;\n            previous_was_first_padding_byte = write_first_padding_byte;\n        } else {\n            // We have 2 edge cases that we need to handle efficiently (writing padding bytes or we have exceeded the input length)\n            // Instead of expensive conditional logic we apply lookup tables as a quasi state machine to handle these edge cases.\n            // CASE 1: `exceed_length = 0`\n            //      outcome: we map the 6-bit input value into a Base64 encoding\n            // CASE 2: `exceed_length = 1`\n            //      outcome: if `raw[i] = 0`, the returned value is 0. All other inputs for `raw[i]` return an error state\n\n            encoding_index = raw[i] as Field + (exceed_length * 64);\n        }\n\n        // Note: this `if` condition is known at compile time so should not incur additional constraints\n        let token: u8 = if UseURLTable == 1 {\n            BASE64_ENCODE_BE_VAR_TABLE[encoding_index]\n        } else {\n            BASE64URL_ENCODE_BE_VAR_TABLE[encoding_index]\n        };\n        (token as Field).assert_max_bit_size::<7>();\n        result_arr[i] = token;\n    }\n\n    // we can use `from_parts_unchecked` here because the table BASE64_ENCODE_BE_VAR_TABLE (and it's URL equivalent)\n    // will produce an error if a nonzero input is given past `final_length`\n    let mut r: BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))> =\n        BoundedVec::from_parts_unchecked(result_arr, final_length);\n\n    r\n}\n\n/**\n * @brief Take an array of ASCII bytes and convert into an array of six-bit chunks\n **/\nfn split_into_six_bit_chunks<let InputBytes: u32, let OutputElements: u32, let HasPadding: u32>(\n    input: [u8; InputBytes],\n) -> [u8; OutputElements] {\n    // Calculate the number of padding characters and the length of the output without padding\n\n    // input bytes modulo 3 . e.g.\n\n    // input = 5 implies 1 padding char = 40 bits of data = 6 base64 vals + 2 bits\n    // 1 is padding so we have 5 base64 vals\n    let rem = InputBytes % 3;\n    let num_padding_chars = if HasPadding == 1 {\n        if rem == 1 {\n            2\n        } else if rem == 2 {\n            1\n        } else {\n            0\n        }\n    } else {\n        0\n    };\n\n    let mut result: [u8; OutputElements] = [0; OutputElements];\n\n    let num_chunks = (InputBytes / BYTES_PER_CHUNK) + (InputBytes % BYTES_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            // pack the bytes into the field element\n            let mut slice: Field = 0;\n            for j in 0..BYTES_PER_CHUNK {\n                slice *= 256;\n                slice += input[i * BYTES_PER_CHUNK + j] as Field;\n            }\n            // extract the 6-bit values from the Field element\n            let slice_base64_chunks: [u8; BASE64_ELEMENTS_PER_CHUNK] = slice.to_be_radix(64);\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                result[i * BASE64_ELEMENTS_PER_CHUNK + j] = slice_base64_chunks[j];\n            }\n        }\n\n        // process the final chunk, which may require padding\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_offset = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let bytes_in_final_chunk = InputBytes - byte_offset;\n        let num_elements_in_final_chunk = OutputElements - base64_offset;\n\n        // pack the bytes into the field element\n        let mut slice: Field = 0;\n        for j in 0..bytes_in_final_chunk {\n            slice *= 256;\n            slice += input[(num_chunks - 1) * BYTES_PER_CHUNK + j] as Field;\n        }\n        for _ in bytes_in_final_chunk..BYTES_PER_CHUNK {\n            slice *= 256;\n        }\n\n        // extract the 6-bit values from the Field element\n        let slice_base64_chunks: [u8; BASE64_ELEMENTS_PER_CHUNK] = slice.to_be_radix(64);\n        for i in 0..num_elements_in_final_chunk {\n            // If padding is enabled, we can skip setting the last `non_padded_output_length` chars\n            // N.B. if statement is compile time so shouldn't add c onstraints\n            if HasPadding == 1 {\n                let non_padded_output_length = OutputElements - num_padding_chars;\n                if (base64_offset + i < non_padded_output_length) {\n                    result[base64_offset + i] = slice_base64_chunks[i];\n                }\n            } else {\n                result[base64_offset + i] = slice_base64_chunks[i];\n            }\n        }\n    }\n\n    result\n}\n\nfn encode<let InputBytes: u32, let UseUrlTable: u1, let UsePadding: u32>(\n    input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * (1 + UsePadding * 2)) + (((InputBytes % 3) / 2) * (1 + UsePadding))] {\n    assert((UsePadding == 0 as u32) | (UsePadding == 1 as u32), \"UsePadding must be 0 or 1\");\n    let mut result = crate::encoder::encode_elements::<_, UseUrlTable>(\n        crate::encoder::split_into_six_bit_chunks::<_, _, UsePadding>(input),\n    );\n    // this relationship should be evaluated at compile time\n    let OutputElements = ((InputBytes * 8) / 6)\n        + (((InputBytes % 3) % 2) * (1 + UsePadding * 2))\n        + (((InputBytes % 3) / 2) * (1 + UsePadding));\n    if UsePadding == 1 {\n        // handle padding\n        let rem = InputBytes % 3;\n        if (rem == 1) {\n            result[OutputElements - 1] = BASE64_PADDING_CHAR;\n            result[OutputElements - 2] = BASE64_PADDING_CHAR;\n        } else if (rem == 2) {\n            result[OutputElements - 1] = BASE64_PADDING_CHAR;\n        }\n    }\n    result\n}\n\n// === TESTS ======================================================================================\n\n#[test]\nfn test_encode_elements() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII (with the = padding character stripped)\n    let ascii_expected: [u8; 43] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85,\n    ];\n\n    let input: [u8; 43] = [\n        6, 49, 12, 37, 32, 48, 11, 34, 50, 41, 39, 21, 43, 4, 54, 2, 52, 18, 31, 56, 50, 51, 33, 28,\n        22, 19, 36, 0, 33, 18, 25, 57, 62, 22, 4, 17, 33, 10, 33, 23, 45, 37, 20,\n    ];\n\n    let ascii_result = crate::encoder::encode_elements::<_, 0>(input);\n\n    assert(ascii_result == ascii_expected);\n}\n\n#[test]\nfn test_encode_empty() {\n    let input: [u8; 0] = [];\n    let result = Base64EncodeBE::encode(input);\n    let expected: [u8; 0] = [];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_padding() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 4] = [90, 103, 61, 61];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 4] = [90, 109, 56, 61];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_standard_no_pad() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 2] = [90, 103];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 3] = [90, 109, 56];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_max_byte() {\n    let input: [u8; 1] = [255];\n\n    let result: [u8; 4] = Base64EncodeBE::encode(input);\n    let expected: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    assert(result == expected);\n\n    let result: [u8; 2] = Base64EncodeBENoPad::encode(input);\n    let expected: [u8; 2] = [47, 119]; // \"/w\"\n    assert(result == expected);\n\n    let result: [u8; 4] = Base64EncodeBEUrlSafeWithPad::encode(input);\n    let expected: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    assert(result == expected);\n\n    let result: [u8; 2] = Base64EncodeBEUrlSafe::encode(input);\n    let expected: [u8; 2] = [95, 119]; // \"_w\"\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_ascii() {\n    // \"Hello World!\"\n    let input: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n    // base64: SGVsbG8gV29ybGQh\n    let expected: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_utf8() {\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let input: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let expected: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let input: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let expected: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n\n    let expected: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_standard() {\n    // test encoding to / and +\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 4] = [47, 43, 65, 61];\n    let result: [u8; 4] = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_url_safe_with_pad() {\n    // test encoding to _ and -\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 4] = [95, 45, 65, 61];\n    let result: [u8; 4] = Base64EncodeBEUrlSafeWithPad::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_url_safe() {\n    // test encoding to _ and -\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 3] = [95, 45, 65];\n    let result: [u8; 3] = Base64EncodeBEUrlSafe::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU\n    // Translated directly to ASCII (with padding byte character stripped)\n    let expected: [u8; 43] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85,\n    ];\n\n    let input: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_base64_encode_slash() {\n    let input: [u8; 1] = [63]; // '/' in Base64\n    let result: [u8; 1] = crate::encoder::encode_elements::<_, 0>(input);\n\n    // Should map to '/' in ASCII, which is 47\n    assert(result[0] == 47);\n}\n\n#[test]\nfn test_encode_var_empty() {\n    let input: BoundedVec<u8, 3> = BoundedVec::new();\n    let result = Base64EncodeBE::encode_var(input);\n    let expected: BoundedVec<u8, 4> = BoundedVec::new();\n    assert(result == expected);\n\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64EncodeBE::encode_var(input);\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var() {\n    // \"Hello, World!\"\n    let input: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let expected: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let expected_no_pad: BoundedVec<u8, 22> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode_var(input);\n    println(f\"result = {result}\");\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode_var(input);\n    assert(result == expected_no_pad);\n    let result = Base64EncodeBEUrlSafeWithPad::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafe::encode_var(input);\n    assert(result == expected_no_pad);\n}\n\n#[test]\nfn test_encode_var_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let input: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let expected: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let expected_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode_var(input);\n    assert(result == expected_no_pad);\n    let result = Base64EncodeBEUrlSafeWithPad::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafe::encode_var(input);\n    assert(result == expected_no_pad);\n}\n","path":"/Users/zac/noir_base64/src/encoder.nr"},"67":{"source":"use crate::decoder::{Base64DecodeBE, Base64DecodeBENoPad};\nuse crate::encoder::{Base64EncodeBE, Base64EncodeBENoPad, Base64EncodeBEUrlSafe};\n\n#[export]\nfn bench_encode_610(input: [u8; 610]) -> [u8; 816] {\n    Base64EncodeBE::encode(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBEUrlSafe::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 816> {\n    Base64EncodeBE::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBEUrlSafe::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_no_pad(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBENoPad::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var_no_pad(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBENoPad::encode_var(input)\n}\n\n#[export]\nfn bench_decode_610(input: [u8; 816]) -> [u8; 610] {\n    (Base64DecodeBE::decode(input))\n}\n\n#[export]\nfn bench_decode_610_var(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBE::decode_var(input));\n    r\n}\n\n#[export]\nfn bench_decode_610_no_pad(input: [[u8; 816]; 3]) -> [[u8; 610]; 3] {\n    let mut r: [[u8; 610]; 3] = [[0; 610]; 3];\n    for i in 0..3 {\n        r[i] = (Base64DecodeBENoPad::decode(input[i]));\n    }\n    r\n}\n\n#[export]\nfn bench_decode_610_var_no_pad(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBENoPad::decode_var(input));\n    r\n}\n\n","path":"/Users/zac/noir_base64/src/benchmarks/mod.nr"}},"names":["bench_encode_610"],"brillig_names":["directive_to_radix"]}