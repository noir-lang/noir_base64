{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":13269652160651912711,"abi":{"parameters":[{"name":"input","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":610,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":814,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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su+VlnlHqhLLvlda5h2pSi77XmmZd6Qqwex7pWXekaoks++VlnlHqhLNvlda5h2pSjb7XmmZd6Qq4ex7pWXekaqks++VlnlHqhLPvlda5h2pSj77XmmZd6QqAe17pWXekaoktO+VlnlHqhLRvlda5h2pSkb7XmmZd6QqIe17pWXekaqktO+VlnlHqhLTvlda5h2pSk77XmmZd6QqQe17pWXekaokte+VlnlHqhLVvlda5h2pSlb7XmmZd6QqYe17pWXekaqkte+VlnlHqhLXvlda5h2pSl77XmmZd6Qqge17pWXekaoktu+VlnlHqhLZvlda5h2pSmb7XmmVd6RWprPdynS2W5nOdivT2W5PL3OlVd6RWpnOdivT2W5lOtutTGe7lelstzKd7Vams93KdLZbmc52K9PZbmU6261MZ7uV6Wy3Mp3tVqaz3cp0tluZznYr09luZTrbrUxnu5XpbLcyne1WprPdynS2W5nOdivT2W5lOtutTGe7lelstzKd7Vams93KdLZbmc52K9PZbmU6261MZ7uV6Wy3Mp3tVqaz3cp0tluZznYr09luZTrbrUxnu5XpbLcyne1WprPdynS2W5nOdivT2W5lOtutTGe7lelstzKd7Vams93KdLZbmc52K9PZbmU6261MZ7uV6Wy3Mp3tVqaz3cp0tluZznYr09luZTrbrUxnu5XpbLcyne1WprPdynS2W5nOdivT2W5lOtutTGe7lelstzKd7Vams93KdLZbmc52K9PZbmU6261MZ7uV6Wy3Mp3tVqaz3cp0tluZznYr09luZTrbrUxnu5XpbLcyne0o09mOMp3tKNPZjjKd7Xh6mSut8o4UZTrbUaazHWU621Gmsx1lOttRprMdZTrbUaazHWU621Gmsx1lOttRprMdZTrbUaazHWU621Gmsx1lOttRprMdZTrbUaazHWU621Gmsx1lOttRprMdZTrbUaazHWU621Gmsx1lOttRprMdZTrbUaazHWU621Gmsx1lOttRprMdZTrbUaazHWU621Gmsx1lOttRprMdZTrbUaazHWU621Gmsx1lOttRprMdZTrbUaazHWU621Gmsx1lOttRprMdZTrbUaazHWU621Gmsx1lOttRprMdZTrbUaazHWU621Gmsx1lOttRprMdZTrbUaazHWU621Gmsx1lOttRprMdZTrbUaazHWU6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","file_map":{"7":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"64":{"source":"use super::defaults::{BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK};\n\nuse crate::tables::{\n    BASE64_ENCODE_BE_TABLE, BASE64_ENCODE_BE_VAR_TABLE, BASE64URL_ENCODE_BE_TABLE,\n    BASE64URL_ENCODE_BE_VAR_TABLE,\n};\n\npub use crate::boundary_check::boundary_check;\n\nglobal CONVERT_MODULO3_TO_PADDING_BYTES: [u32; 3] = [0, 2, 1];\nglobal PAD_1: [Field; 3] = [0, 1, 1];\nglobal PAD_2: [Field; 3] = [0, 1, 0];\n\n// Encoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64EncodeBE {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * 3) + (((InputBytes % 3) / 2) * 2)] {\n        crate::encoder::encode::<InputBytes, 0, 1>(input)\n    }\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * 3) + (((MAX_INPUT_LEN % 3) / 2) * 2)> {\n        crate::encoder::encode_var::<_, 0, 1>(input)\n    }\n}\n\n// Encoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64EncodeBENoPad {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2)) + (((InputBytes % 3) / 2))] {\n        crate::encoder::encode::<InputBytes, 0, 0>(input)\n    }\n\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, (((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2)) + (((MAX_INPUT_LEN % 3) / 2)))> {\n        crate::encoder::encode_var::<_, 0, 0>(input)\n    }\n}\n\n// Encoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64EncodeBEUrlSafe {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2)) + (((InputBytes % 3) / 2))] {\n        crate::encoder::encode::<_, 1, 0>(input)\n    }\n\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, (((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2)) + (((MAX_INPUT_LEN % 3) / 2)))> {\n        crate::encoder::encode_var::<_, 1, 0>(input)\n    }\n}\n\n// Encoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64EncodeBEUrlSafeWithPad {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * 3) + (((InputBytes % 3) / 2) * 2)] {\n        crate::encoder::encode::<_, 1, 1>(input)\n    }\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * 3) + (((MAX_INPUT_LEN % 3) / 2) * 2)> {\n        crate::encoder::encode_var::<_, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Take an array of ASCII values and convert into base64 values\n * @tparam InputElements: The size of the array being encoded\n * @tparam UseUrlTable: are we encoding using the URL and Filename Safe Alphabet, or standard Base64 Alphabet? \n **/\nfn encode_elements<let InputElements: u32, let UseUrlTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; InputElements] {\n    let mut result: [u8; InputElements] = [0; InputElements];\n\n    for i in 0..InputElements {\n        let token: u8 = if UseUrlTable == 1 {\n            BASE64URL_ENCODE_BE_TABLE[input[i]]\n        } else {\n            BASE64_ENCODE_BE_TABLE[input[i]]\n        };\n        result[i] = token as u8;\n    }\n\n    result\n}\n\n/**\n * @brief Encode a variable-length ASCII string into Base64 values\n **/\nfn encode_var<let MAX_INPUT_LEN: u32, let UseURLTable: u1, let HasPadding: u32>(\n    input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))> {\n    assert((HasPadding == 0) | (HasPadding == 1), \"invalid HasPadding parameter\");\n    // The max number of output Base64 values can be derived from the max input size\n    let mut result_arr: [u8; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] = [\n        0; ((MAX_INPUT_LEN * 8) / 6)\n            + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2))\n            + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))\n    ];\n\n    // Note: is this correct?\n    let output_length = ((MAX_INPUT_LEN * 8) / 6)\n        + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2))\n        + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding));\n\n    // Step 1: convert the input into six-bit chunks. We can map each chunk into Base64 values.\n    let raw: [u8; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] =\n        crate::encoder::split_into_six_bit_chunks::<_, _, 1>(input.storage());\n\n    let real_length = input.len();\n    // The input length modulo 3 can be used to determine the number of padding bytes\n    let real_length_mod_3 = if HasPadding == 1 { real_length % 3 } else { 0 };\n    // encoded_length = the number of Base64 values minus padding\n    let encoded_length = ((real_length * 8) + 5) / 6;\n    let final_length = encoded_length\n        + if HasPadding == 1 {\n            CONVERT_MODULO3_TO_PADDING_BYTES[real_length_mod_3]\n        } else {\n            0\n        };\n\n    // Get an array of Field elements where boundary_flags[i] = 0 if i < encoded_length, otherwise i = 1.\n    // We use this array to determine if the result array should contain a valid Base64 encoded value, 0 or if an error state has been reached\n    let boundary_flags: [Field; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] =\n        boundary_check(encoded_length);\n\n    // Using 2 lookups is slightly cheaper than figuring out if the 1st/2nd padding byte is set from the padding length param... I think?\n    let has_first_padding_byte = if HasPadding == 1 {\n        PAD_1[real_length_mod_3]\n    } else {\n        0\n    };\n    let has_second_padding_byte = if HasPadding == 1 {\n        PAD_2[real_length_mod_3]\n    } else {\n        0\n    };\n\n    // If we have actual data to iterate through, populate the 1st result entry with the base64 encoding of `raw[0]`.\n    // Note: if `boundary_flags[0] = 1`, the `BASE64_ENCODE_BE_VAR_TABLE` lookup will output 0.\n    // Note: `MAX_INPUT_LEN` is known at compile time so this `if` statement should not incur constraints.\n    if MAX_INPUT_LEN > 0 {\n        result_arr[0] = BASE64_ENCODE_BE_VAR_TABLE[raw[0] as Field + boundary_flags[0] * 64] as u8;\n    }\n\n    let mut previous_was_first_padding_byte = 0;\n    for i in 1..output_length {\n        let exceed_length = boundary_flags[i];\n        // hit_limit = we are at the first location where a padding Base64 character *could* be enerated\n\n        let mut encoding_index: Field = 0;\n\n        if HasPadding == 1 {\n            let hit_limit: Field = (1 - boundary_flags[i - 1]) * boundary_flags[i];\n            // We need to write a padding byte if `i == encoding_length` and `has_first_padding_byte == 1`\n            let write_first_padding_byte: Field = hit_limit * has_first_padding_byte;\n            // We need to write a padding byte if `i == encoding_length + 1` and `has_second_padding_byte == 1`\n            let write_second_padding_byte =\n                previous_was_first_padding_byte * has_second_padding_byte;\n\n            // Look up the encoded Base64 value given an input 6-bit chunk.\n            // We have 2 edge cases that we need to handle efficiently (writing padding bytes or we have exceeded the input length)\n            // Instead of expensive conditional logic we apply lookup tables as a quasi state machine to handle these edge cases.\n            // CASE 1: `exceed_length = 0`, `write_first_padding_byte = 0`, `write_second_padding_byte = 0`\n            //      outcome: we map the 6-bit input value into a Base64 encoding\n            // CASE 2: `exceed_length = 1` AND `write_first_padding_byte = 0` AND `write_second_padding_byte = 0`\n            //      outcome: if `raw[i] = 0`, the returned value is 0. All other inputs for `raw[i]` return an error state\n            // CASE 3: `exceed_length = 1` AND ()`write_first_padding_byte = 1` OR `write_second_padding_byte = 1`)\n            //      outcome: if `raw[i] = 0`, the returned value is BASE64_PADDING_CHAR. All other inputs for `raw[i]` return an error state\n            // Note: due to how they are constructed, it is not possible for both `write_first_padding_byte` and `write_second_padding_byte` to equal 1.\n            //       Similarly, it is not possible for `exceed_length = 0` and either of `write_first_padding_byte` or `write_second_padding_byte` to equal 1.\n            encoding_index = raw[i] as Field\n                + (exceed_length + write_first_padding_byte + write_second_padding_byte) * 64;\n            previous_was_first_padding_byte = write_first_padding_byte;\n        } else {\n            // We have 2 edge cases that we need to handle efficiently (writing padding bytes or we have exceeded the input length)\n            // Instead of expensive conditional logic we apply lookup tables as a quasi state machine to handle these edge cases.\n            // CASE 1: `exceed_length = 0`\n            //      outcome: we map the 6-bit input value into a Base64 encoding\n            // CASE 2: `exceed_length = 1`\n            //      outcome: if `raw[i] = 0`, the returned value is 0. All other inputs for `raw[i]` return an error state\n\n            encoding_index = raw[i] as Field + (exceed_length * 64);\n        }\n\n        // Note: this `if` condition is known at compile time so should not incur additional constraints\n        let token: u8 = if UseURLTable == 1 {\n            BASE64_ENCODE_BE_VAR_TABLE[encoding_index]\n        } else {\n            BASE64URL_ENCODE_BE_VAR_TABLE[encoding_index]\n        };\n        (token as Field).assert_max_bit_size::<7>();\n        result_arr[i] = token;\n    }\n\n    // we can use `from_parts_unchecked` here because the table BASE64_ENCODE_BE_VAR_TABLE (and it's URL equivalent)\n    // will produce an error if a nonzero input is given past `final_length`\n    let mut r: BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))> =\n        BoundedVec::from_parts_unchecked(result_arr, final_length);\n\n    r\n}\n\n/**\n * @brief Take an array of ASCII bytes and convert into an array of six-bit chunks\n **/\nfn split_into_six_bit_chunks<let InputBytes: u32, let OutputElements: u32, let HasPadding: u32>(\n    input: [u8; InputBytes],\n) -> [u8; OutputElements] {\n    // Calculate the number of padding characters and the length of the output without padding\n\n    // input bytes modulo 3 . e.g.\n\n    // input = 5 implies 1 padding char = 40 bits of data = 6 base64 vals + 2 bits\n    // 1 is padding so we have 5 base64 vals\n    let rem = InputBytes % 3;\n    let num_padding_chars = if HasPadding == 1 {\n        if rem == 1 {\n            2\n        } else if rem == 2 {\n            1\n        } else {\n            0\n        }\n    } else {\n        0\n    };\n\n    let mut result: [u8; OutputElements] = [0; OutputElements];\n\n    let num_chunks = (InputBytes / BYTES_PER_CHUNK) + (InputBytes % BYTES_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            // pack the bytes into the field element\n            let mut slice: Field = 0;\n            for j in 0..BYTES_PER_CHUNK {\n                slice *= 256;\n                slice += input[i * BYTES_PER_CHUNK + j] as Field;\n            }\n            // extract the 6-bit values from the Field element\n            let slice_base64_chunks: [u8; BASE64_ELEMENTS_PER_CHUNK] = slice.to_be_radix(64);\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                result[i * BASE64_ELEMENTS_PER_CHUNK + j] = slice_base64_chunks[j];\n            }\n        }\n\n        // process the final chunk, which may require padding\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_offset = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let bytes_in_final_chunk = InputBytes - byte_offset;\n        let num_elements_in_final_chunk = OutputElements - base64_offset;\n\n        // pack the bytes into the field element\n        let mut slice: Field = 0;\n        for j in 0..bytes_in_final_chunk {\n            slice *= 256;\n            slice += input[(num_chunks - 1) * BYTES_PER_CHUNK + j] as Field;\n        }\n        for _ in bytes_in_final_chunk..BYTES_PER_CHUNK {\n            slice *= 256;\n        }\n\n        // extract the 6-bit values from the Field element\n        let slice_base64_chunks: [u8; BASE64_ELEMENTS_PER_CHUNK] = slice.to_be_radix(64);\n        for i in 0..num_elements_in_final_chunk {\n            // If padding is enabled, we can skip setting the last `non_padded_output_length` chars\n            // N.B. if statement is compile time so shouldn't add c onstraints\n            if HasPadding == 1 {\n                let non_padded_output_length = OutputElements - num_padding_chars;\n                if (base64_offset + i < non_padded_output_length) {\n                    result[base64_offset + i] = slice_base64_chunks[i];\n                }\n            } else {\n                result[base64_offset + i] = slice_base64_chunks[i];\n            }\n        }\n    }\n\n    result\n}\n\nfn encode<let InputBytes: u32, let UseUrlTable: u1, let UsePadding: u32>(\n    input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * (1 + UsePadding * 2)) + (((InputBytes % 3) / 2) * (1 + UsePadding))] {\n    assert((UsePadding == 0 as u32) | (UsePadding == 1 as u32), \"UsePadding must be 0 or 1\");\n    let mut result = crate::encoder::encode_elements::<_, UseUrlTable>(\n        crate::encoder::split_into_six_bit_chunks::<_, _, UsePadding>(input),\n    );\n    // this relationship should be evaluated at compile time\n    let OutputElements = ((InputBytes * 8) / 6)\n        + (((InputBytes % 3) % 2) * (1 + UsePadding * 2))\n        + (((InputBytes % 3) / 2) * (1 + UsePadding));\n    if UsePadding == 1 {\n        // handle padding\n        let rem = InputBytes % 3;\n        if (rem == 1) {\n            result[OutputElements - 1] = BASE64_PADDING_CHAR;\n            result[OutputElements - 2] = BASE64_PADDING_CHAR;\n        } else if (rem == 2) {\n            result[OutputElements - 1] = BASE64_PADDING_CHAR;\n        }\n    }\n    result\n}\n\n// === TESTS ======================================================================================\n\n#[test]\nfn test_encode_elements() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII (with the = padding character stripped)\n    let ascii_expected: [u8; 43] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85,\n    ];\n\n    let input: [u8; 43] = [\n        6, 49, 12, 37, 32, 48, 11, 34, 50, 41, 39, 21, 43, 4, 54, 2, 52, 18, 31, 56, 50, 51, 33, 28,\n        22, 19, 36, 0, 33, 18, 25, 57, 62, 22, 4, 17, 33, 10, 33, 23, 45, 37, 20,\n    ];\n\n    let ascii_result = crate::encoder::encode_elements::<_, 0>(input);\n\n    assert(ascii_result == ascii_expected);\n}\n\n#[test]\nfn test_encode_empty() {\n    let input: [u8; 0] = [];\n    let result = Base64EncodeBE::encode(input);\n    let expected: [u8; 0] = [];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_padding() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 4] = [90, 103, 61, 61];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 4] = [90, 109, 56, 61];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_standard_no_pad() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 2] = [90, 103];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 3] = [90, 109, 56];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_max_byte() {\n    let input: [u8; 1] = [255];\n\n    let result: [u8; 4] = Base64EncodeBE::encode(input);\n    let expected: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    assert(result == expected);\n\n    let result: [u8; 2] = Base64EncodeBENoPad::encode(input);\n    let expected: [u8; 2] = [47, 119]; // \"/w\"\n    assert(result == expected);\n\n    let result: [u8; 4] = Base64EncodeBEUrlSafeWithPad::encode(input);\n    let expected: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    assert(result == expected);\n\n    let result: [u8; 2] = Base64EncodeBEUrlSafe::encode(input);\n    let expected: [u8; 2] = [95, 119]; // \"_w\"\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_ascii() {\n    // \"Hello World!\"\n    let input: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n    // base64: SGVsbG8gV29ybGQh\n    let expected: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_utf8() {\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let input: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let expected: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let input: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let expected: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n\n    let expected: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_standard() {\n    // test encoding to / and +\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 4] = [47, 43, 65, 61];\n    let result: [u8; 4] = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_url_safe_with_pad() {\n    // test encoding to _ and -\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 4] = [95, 45, 65, 61];\n    let result: [u8; 4] = Base64EncodeBEUrlSafeWithPad::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_url_safe() {\n    // test encoding to _ and -\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 3] = [95, 45, 65];\n    let result: [u8; 3] = Base64EncodeBEUrlSafe::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU\n    // Translated directly to ASCII (with padding byte character stripped)\n    let expected: [u8; 43] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85,\n    ];\n\n    let input: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_base64_encode_slash() {\n    let input: [u8; 1] = [63]; // '/' in Base64\n    let result: [u8; 1] = crate::encoder::encode_elements::<_, 0>(input);\n\n    // Should map to '/' in ASCII, which is 47\n    assert(result[0] == 47);\n}\n\n#[test]\nfn test_encode_var_empty() {\n    let input: BoundedVec<u8, 3> = BoundedVec::new();\n    let result = Base64EncodeBE::encode_var(input);\n    let expected: BoundedVec<u8, 4> = BoundedVec::new();\n    assert(result == expected);\n\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64EncodeBE::encode_var(input);\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var() {\n    // \"Hello, World!\"\n    let input: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let expected: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let expected_no_pad: BoundedVec<u8, 22> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode_var(input);\n    println(f\"result = {result}\");\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode_var(input);\n    assert(result == expected_no_pad);\n    let result = Base64EncodeBEUrlSafeWithPad::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafe::encode_var(input);\n    assert(result == expected_no_pad);\n}\n\n#[test]\nfn test_encode_var_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let input: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let expected: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let expected_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode_var(input);\n    assert(result == expected_no_pad);\n    let result = Base64EncodeBEUrlSafeWithPad::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafe::encode_var(input);\n    assert(result == expected_no_pad);\n}\n","path":"/Users/zac/noir_base64/src/encoder.nr"},"65":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let r = unsafe {\n        //@safety r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n        __boundary_check(limit)\n    };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/zac/noir_base64/src/boundary_check.nr"},"67":{"source":"use crate::decoder::{Base64DecodeBE, Base64DecodeBENoPad};\nuse crate::encoder::{Base64EncodeBE, Base64EncodeBENoPad, Base64EncodeBEUrlSafe};\n\n#[export]\nfn bench_encode_610(input: [u8; 610]) -> [u8; 816] {\n    Base64EncodeBE::encode(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBEUrlSafe::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 816> {\n    Base64EncodeBE::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBEUrlSafe::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_no_pad(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBENoPad::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var_no_pad(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBENoPad::encode_var(input)\n}\n\n#[export]\nfn bench_decode_610(input: [u8; 816]) -> [u8; 610] {\n    (Base64DecodeBE::decode(input))\n}\n\n#[export]\nfn bench_decode_610_var(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBE::decode_var(input));\n    r\n}\n\n#[export]\nfn bench_decode_610_no_pad(input: [[u8; 816]; 3]) -> [[u8; 610]; 3] {\n    let mut r: [[u8; 610]; 3] = [[0; 610]; 3];\n    for i in 0..3 {\n        r[i] = (Base64DecodeBENoPad::decode(input[i]));\n    }\n    r\n}\n\n#[export]\nfn bench_decode_610_var_no_pad(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBENoPad::decode_var(input));\n    r\n}\n\n","path":"/Users/zac/noir_base64/src/benchmarks/mod.nr"}},"names":["bench_encode_610_url_safe_var"],"brillig_names":["__boundary_check","directive_to_radix","directive_integer_quotient"]}