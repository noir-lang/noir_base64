{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":7279570995152380694,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":610,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":814,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+29BXScSZa0LZNkZmZmyDQzMzMzNZmZmZmZmZmZmZmZmRn+qB571lZfWVWqqznf7f/WOc96N2Y2+g1Hy6pMhaUAHv95FQjp4dE85H/+9wAg0LdfHa+g3rQAhBaQ0AIRWmBCC0JonoTmRWhBCS0YoQUntBCEFpLQQhFaaEILQ2hhCS0coYUntAiEFpHQIhFaZEKLQmhRCS0aoUUntBiEFpPQYhFabEKLQ2hxCS0eocUntASElpDQEhFaYkJLQmhJCS0ZoSUntBSElpLQUhFaakJLQ2iG0CyhpSW0dISWntAyEFpGQstEaJkJLQuhZSW0bISWndByEFpOQstFaLkJLQ+h5SW0fISWn9AKEFpBQitEaIUJrQihFSW0YoRWnNBKEFpJQitFaKUJrQyhlSW0coRWntAqEFpFQqtEaJUJrQqhVSW0aoRWndBqEFpNQqtFaLUJrQ6h1SW0eoRWn9AaEFpDQvuN0H4ntD8I7U9C+4vQGhFaY0JrQmhNCa0ZoTUntBaE1pLQWhFaa0JrQ2htCa0dobUntA6E1pHQOhFaZ0LrQmhdCa0boXUntB6E1pPQehFab0LrQ2h9Ca0fofUntAGENpDQBhHaYEIbQmhDCW0YoQ0ntBGENpLQRhHaaEIbQ2hjCW0coY0ntAmENpHQJhHaZEKbQmhTCW0aoU0ntBmENpPQZhHabEKbQ2hzCW0eoc0ntAWEtpDQFhHaYkJbQmhLCW0ZoS0ntBWEtpLQVhHaakJbQ2hrCW0doa0ntA2EtpHQNhHaZkLbQmhbCW0boW0ntB2EtpPQdhHabkLbQ2h7CW0foe0ntAOEdpDQDhHaYUI7QmhHCe0YoR0ntBOEdpLQThHaaUI7Q2hnCe0coZ0ntAuEdpHQLhHaZUK7QmhXCe0aoV0ntBuEdpPQbhHabUK7Q2h3Ce0eod0ntAeE9pDQHhHaY0J7QmhPCe0ZoT0ntBeE9pLQXhHaa0J7Q2hvCe0dob0ntA+E9pHQPhHaZ0L7QmhfCc3xP7xrAQgtIKEFIrTAhBaE0DwJzYvQghJaMEILTmghCC0koYUitNCEFobQwhJaOEILT2gRCC0ioUUitMiEFoXQohJaNEKLTmgxCC0mocUitNiEFofQ4hJaPEKLT2gJCC0hoSUitMSEloTQkhJaMkJLTmgpCC0loaUitNSElobQDKFZQktLaOkILT2hZSC0jISWidAyE1oWQstKaNkILTuh5SC0nISWi9ByE1oeQstLaPkILT+hFSC0goRWiNAKE1oRQitKaMUIrTihlSC0koRWitBKE1oZQitLaOUIrTyhVSC0ioRWidAqE1oVQqtKaNUIrTqh1SC0moRWi9BqE1odQqtLaPUIrT6hNSC0hoT2G6H9Tmh/ENqfhPYXoTUitMaE1oTQmhJaM0JrTmgtCK0lobUitNaE1obQ2hJaO0JrT2gdCK0joXUitM6E1oXQuhJaN0LrTmg9CK0nofUitN6E1ofQ+hJaP0LrT2gDCG0goQ0itMGENoTQhhLaMEIbTmgjCG0koY0itNGENobQxhLaOEIbT2gTCG0ioU0itMmENoXQphLaNEKbTmgzCG0moc0itNmENofQ5hLaPEKbT2gLCG0hoS0itMWEtoTQlhLaMkJbTmgrCG0loa0itNWEtobQ1hLaOkJbT2gbCG0joW0itM2EtoXQthLaNkLbTmg7CG0noe0itN2EtofQ9hLaPkLbT2gHCO0goR0itMOEdoTQjhLaMUI7TmgnCO0koZ0itNOEdobQzhLaOUI7T2gXCO0ioV0itMuEdoXQrhLaNUK7Tmg3CO0mod0itNuEdofQ7hLaPUK7T2gPCO0hoT0itMeE9oTQnhLaM0J7TmgvCO0lob0itNeE9obQ3hLaO0J7T2gfCO0joX0itM+E9oXQvhKaY9jnXQtAaAEJLRChBSa0IITmSWhehBaU0IIRWnBCC0FoIQktFKGFJrQwhBaW0MIRWnhCi0BoEQktEqFFJrQohBaV0KIRWnRCi0FoMQktFqHFJrQ4hBaX0OIRWnxCS0BoCQktEaElJrQkhJaU0JIRWnJCS0FoKQktFaGlJrQ0hGYIzRJaWkJLR2jpCS0DoWUktEyElpnQshBaVkLLRmjZCS0HoeUktFyElpvQ8hBaXkLLR2j5Ca0AoRUktEKEVpjQihBaUUIrRmjFCa0EoZUktFKEVprQyhBaWUIrR2jlCa0CoVUktEqEVpnQqhBaVUKrRmjVCa0GodUktFqEVpvQ6nzTHFt6j2+691fsb7/m/varcbys8fPrH15uuAX4p5ef3QJSXn50C0R7+cktsE9efnAL4rOXy26ev/Jy0c3r114uuQX1zcsFt2C+ezntFtwZLyfdQjjn5ZRbSGe9nHAL5byXr26hXfHyxS2Ma16/dAvrqtcv3MK57uWjW3i/ePngFsFvXqRbRL96EW6R/O71D7fI7nh5c4vintdPblHd9frBLZr7Xv91i87h9c0tBo/X324xubzgFovPy3gQLx7vtJn9zzv93++pHK+/z6Tf/vdheOMwHIwAI8EoMBqMAWPBODAeTAATwSQwGUwBU8E0MB3MADPBLDAbzAFzwTwwHywAC8EisBgsAUvBMrAcrAArwSqwGqwBa4N4/Pym1vGwnt604YQ2gtBGEtooQhtNaGMIbSyhjSO08YQ2gdAmEtokQptMaFMIbSqhTSO06YQ2g9BmEtosQptNaHMIbS6hzSO0+YS2gNAWEtoiQltMaEsIbSmhLSO05YS2gtBWEtoqQltNaGsIbe037cdXwW+/5v72698f93qg++VLD3R6oPP+0gOda256oHPNTQ90rrnpgc41t/+/HejSmYzp0zfIlLaBTWfrmLRZ6mbOYNJnqJsxs81sM2TOUD9t5nTpGmROnzlTlrpZMpksNn26BrZhhizpGn4zc5wr3PVq0NDxqmeHc3kh4wger3qO36+RLF7/+b0fxeBV91uPo932yvy9RzvGXS/7338n7Fj3vMwP/37ZcW551fnx31U73g2vdD//e28n+Nkrc31vH0N2oh+9Mjb8x8ejneRHr3T//Ni2k/3kVYf6c8JO8YtXBvLPHDvVda9MPvz5Zae57GV8+rPQTnfRq77Pf67aGS55pW34iz+j7UxXvDL98s97O8t5r3oNfv25w8522iu9b5+H7BxnvdL7+jnNznXOyzjx+dHOc8orvTOfa+18J7wyOfd52y7w3Sutk+8B7ELfvNI7/X7CLvLFyzj/3sQu/qVXelfe59glv/JK79J7JrvUZ6/MLr7/sst88MrSsIGr7+Xscp+8XH9faFeQXmnr++E9pl1JeRk/vV+1qwivOn5772tX/8Mro1/fR9s13r3q+Pk9uV0bhO2sYP6XI5jYHnx3pnE8+O5M43rw3ZnG8+C7M43vwXdnmsCD7840oQffnWkiD74708Qevn5cOO2WxMOJjzEn3ZJ6OPXx6pRbMue8nHJL7qyXE24pnPfy1S2lK16+uKVyzeuXbqld9fqFWxrXvXx284uXD27Wb16kW1q/ehFu6fzu9Q+39O54eXPL4J7XT24Z3fX6wS2T+17/dcvM4fXNLQuP199uWbm84JaNz+tfNYJZh/ea68EGsBFsApvBFrAVbAPbwQ6wE+wCu8EesBfsA/vBAXAQHAKHwRFwFBwDx8EJcBKcAqfBGXAWnAPnwQVwEVwCl8EVcNX7CGYdMQZYT2gbCG0joW0itM2EtoXQthLaNkLbTmg7CG0noe0itN2EtofQ9hLaPkLbT2gHCO0goR0itMOEdoTQjhLaMUI7TmgnCO0koZ0itNOEdobQzhLaOUI7T2gXCO0ioV0itMuEdoXQrgbx/xGMHuhce+mBzuiBzttLD3SuuemBzjU3PdC55qYHOtfcJBzo3B3BrAvivtf3Ecx6xhHMBsYRzEbGEcwmxhHMZsYRzBbGEcxWxhHMNsYRzHbGEcwOxhHMTsYRzC7GEcxuxhHMHsYRzF7GEcw+xhHMfsYRzAHGEcxBxhHMIcYRzGHGEcwRxhHMUcYRzDHGEcxxxhHMCcYRzEnGEcwpxhHMacYRzBnGEcxZxhHMOcYRzHnGEcwFxhHMRcYRzCXGEcxlxhHMFcYRzFWhI5jsHnx3pjk8+O5Mc3rw3Znm8uC7M83twXdnmseD7840rwffnWk+D7470/wevn5cOO1WwMOJjzEn3Qp6OPXx6pRbIee8nHIr7KyXE25FnPfy1a2oK16+uBVzzeuXbsVd9fqFWwnXvXx0K+kXLx/cSvnNi3Qr7Vcvwq2M373+4VbWHS9vbuXc8/rJrby7Xj+4VXDf679uFTm8vrlV4vH6260ylxfcqvB5/atGMNfwXvM6uAFuglvgNrgD7oJ74D54AB6CR+AxeAKegmfgOXgBXoJX4DV4A96Cd+A9+AA+gk/gM/gCvjpGLvhCfgAQEAQCgUEQ4Am8vH/h/xoxBrhOaDcI7Sah3SK024R2h9DuEto9QrtPaA8I7SGhPSK0x4T2hNCeEtozQntOaC8I7SWhvSK014T2htDeEto7QntPaB8I7SOhfSK0z4T2hdC+EppD8K4FILSAhBaI0AITWhBC8yQ0L0//H8Hogc61V24PPdDpge7nlx7oXHPTA51rbnqgc81ND3SuuUk40Lk7grkWxH2v7yOY64wjmBuMI5ibjCOYW4wjmNuMI5g7jCOYu4wjmHuMI5j7jCOYB4wjmIeMI5hHjCOYx4wjmCeMI5injCOYZ4wjmOeMI5gXjCOYl4wjmFeMI5jXjCOYN4wjmLeMI5h3jCOY94wjmA+MI5iPjCOYT4wjmM+MI5gvjCOYr4wjGMdFFuXllxFMAJ+8/DDECOjJN4IJ5Mk3ggnsyTeCCeLJN4Lx9OQbwXh5sp0V/qcjmKoefHem1Tz47kyre/Ddmdbw4LszrenBd2day4PvzrS2B9+daR0PvjvTuh6+flw47VbPw4mPMSfd6ns49fHqlFsD57yccmvorJcTbr857+Wr2++uePni9odrXr90+9NVr1+4/eW6l49ujfzi5YNbY795kW5N/OpFuDX1u9c/3Jq54+XNrbl7Xj+5tXDX6we3lu57/detFYfXN7fWPF5/u7Xh8oJbWz6vf9UIJijeawYDwUEIEBKEAqFBGBAWhAPhQQQQEUQCkUEUEBVEA9FBDBATxAKxQRwQF8QD8UECkBAkAolBEpAUJAPJQQqQEqQCqUEa71/4D0qMAYIRWnBCC0FoIQktFKGFJrQwhBaW0MIRWnhCi0BoEQktEqFFJrQohBaV0KIRWnRCi0FoMQktFqHFJrQ4hBaX0OIRWnxCS0BoCQktEaElJrQkhJaU0JIRWnJCS0FoKQktFaGlJrQ0nv4/gtEDnWsvPdAZPdB5e+mBzjU3PdC55qYHOtfc9EDnmpuEA527I5ignnwjmGBcXsgYnMfr7xFMCBav//zeh2Tw+j6CCeW21/+NYEK76/XDCCaMe14/jWDCuuX18wgmnBte3kcw4f3s9c8RTAQ/elEjmIh+9KJGMJH85EWPYCL7xcuHEUwU1718HMFEddnL5xFMNBe9fjWCie6S169HMDFc8fJlBBPTeS9fRzCxnPbyfQQT21kvJ0YwcZzzcmoEE9cpL+dGMPGc8HJ2BBPfdy+nRzAJfPNyYQST0JNvBJPIk28Ek9iTbwSTxJNvBJPUk28Ek8wnLz8MMZJ78o1gUnjyjWBSevKNYFJ58o1gUnvyjWDSeLKdFf6nI5h2Hnx3pu09+O5MO3jw3Zl29OC7M+3kwXdn2tmD7860iwffnWlXD747024evn5cOO3W3cOJjzEn3Xp4OPXx6pRbT+e8nHLr5ayXE269nffy1a2PK16+uPV1zeuXbv1c9fqFW3/XvXx0G+AXLx/cBvrNi3Qb5Fcvwm2w373+4TbEHS9vbkPd8/rJbZi7Xj+4DXff679uIzi8vrmN5PH6220UlxfcRvN5/atGMAbvNS1IC9KB9CADyAgygcwgC8gKsoHsIAfICXI53qeCPCAvyAfygwKgICgECoMioCgoBoqDEqAkKAVKgzKgLCgHyoMKoCKo5P0L/4YYA1hCS0to6QgtPaFlILSMhJaJ0DITWhZCy0po2QgtO6HlILSchJaL0HITWh5Cy0to+QgtP6EVILSChFaI0AoTWhFCK0poxQitOKGVILSShFaK0EoTWhlCK0to5QitPKFVILSKhFbJ0/9HMHqgc+2lBzqjBzpvLz3QueamBzrX3PRA55qbHuhcc5NwoHN3BGM8+UYwlssLGdPyeP09gknH4vWf3/v0DF7fRzAZ3Pb6vxFMRne9fhjBZHLP66cRTGa3vH4ewWRxw8v7CCarn73+OYLJ5kcvagST3Y9e1Agmh5+86BFMTr94+TCCyeW6l48jmNwue/k8gsnjotevRjB5XfL69Qgmnytevoxg8jvv5esIpoDTXr6PYAo66+XECKaQc15OjWAKO+Xl3AimiBNezo5givru5fQIpphvXi6MYIp78o1gSnjyjWBKevKNYEp58o1gSnvyjWDK+OTlhyFGWU++EUw5T74RTHlPvhFMBU++EUxFT74RTCVPtrPC/3QEM8aD7850rAffnek4D7470/EefHemEzz47kwnevDdmU7y4LsznezBd2c6xcPXjwun3aZ6OPEx5qTbNA+nPl6dcpvunJdTbjOc9XLCbabzXr66zXLFyxe32a55/dJtjqtev3Cb67qXj27z/OLlg9t8v3mRbgv86kW4LfS71z/cFrnj5c1tsXteP7ktcdfrB7el7nv9120Zh9c3t+U8Xn+7reDygttKPq9/1QimMt5rVgFVQTVQHdQANUEtUBvUAXVBPVAfNAANwW/gd/AH+BP8BRqBxqAJaAqageagBWgJWoHWoA1oC9qB9qAD6Ag6gc6gC+jq/Qv/lYkxQBVCq0po1QitOqHVILSahFaL0GoTWh1Cq0to9QitPqE1ILSGhPYbof1OaH8Q2p+E9hehNSK0xoTWhNCaElozQmtOaC0IrSWhtSK01oTWhtDaElo7QmtPaB0IrSOhdSK0zoTWhdC6evr/CEYPdK699EBn9EDn7TXdOS890H176YHONTc90Lnmpgc619wkHOjcHcFU9uQbwVTh8kLGqjxef49gqrF4/ef3vjqD1/cRTA23vf5vBFPTXa8fRjC13PP6aQRT2y2vn0cwddzw8j6Cqetnr3+OYOr50YsawdT3oxc1gmngJy96BNPQL14+jGB+c93LxxHM7y57+TyC+cNFr1+NYP50yevXI5i/XPHyZQTTyHkvX0cwjZ328n0E08RZLydGME2d83JqBNPMKS/nRjDNnfBydgTTwncvp0cwLX3zcmEE08qTbwTT2pNvBNPGk28E09aTbwTTzpNvBNPeJy8/DDE6ePKNYDp68o1gOnnyjWA6e/KNYLp48o1gunqynRX+pyOYVR58d6arPfjuTNd48N2ZrvXguzNd58F3Z7reg+/OdIMH353pRg++O9NNHr5+XDjtttnDiY8xJ922eDj18eqU21bnvJxy2+aslxNu25338tVthytevrjtdM3rl267XPX6hdtu1718dNvjFy8f3Pb6zYt02+dXL8Jtv9+9/uF2wB0vb24H3fP6ye2Qu14/uB123+u/bkc4vL65HeXx+tvtGJcX3I7zef2rRjDd8F6zO+gBeoJeoDfoA/qCfqA/GAAGgkFgMBgChoJhYDgYAUaCUWA0GAPGgnFgPJgAJoJJYDKYAqaCaWA6mAFmgllgNpgD5nr/wn83YgzQndB6EFpPQutFaL0JrQ+h9SW0foTWn9AGENpAQhtEaIMJbQihDSW0YYQ2nNBGENpIQhtFaKMJbQyhjSW0cYQ2ntAmENpEQptEaJMJbQqhTSW0aYQ2ndBmENpMQptFaLMJbQ6hzfX0/xGMHuhce+mBzuiBzttLD3SuuemBzjU3PdC55qYHOtfcJBzo3B3BdPPkG8F05/JCxh48Xn+PYHqyeP3n974Xg9f3EUxvt73+bwTTx12vH0Ywfd3z+mkE088tr59HMP3d8PI+ghngZ69/jmAG+tGLGsEM8qMXNYIZ7CcvegQzxC9ePoxghrru5eMIZpjLXj6PYIa76PWrEcwIl7x+PYIZ6YqXLyOYUc57+TqCGe20l+8jmDHOejkxghnrnJdTI5hxTnk5N4IZ74SXsyOYCb57OT2CmeiblwsjmEmefCOYyZ58I5gpnnwjmKmefCOYaZ58I5jpPnn5YYgxw5NvBDPTk28EM8uTbwQz25NvBDPHk28EM9eT7azwPx3BnPDguzM96cF3Z3rKg+/O9LQH353pGQ++O9OzHnx3puc8+O5Mz3vw3Zle8PD148Jpt4seTnyMOel2ycOpj1en3C475+WU2xVnvZxwu+q8l69u11zx8sXtumtev3S74arXL9xuuu7lo9stv3j54Hbbb16k2x2/ehFud/3u9Q+3e+54eXO7757XT24P3PX6we2h+17/dXvE4fXN7TGP199uT7i84PaUz+tfNYKZh/ea88ECsBAsAovBErAULAPLwQqwEqwCq8EasBasA+vBBrARbAKbwRawFWwD28EOsBPsArvBHrAX7AP7wQFwEBwCh8ERcNT7F/7nEWOA+YS2gNAWEtoiQltMaEsIbSmhLSO05YS2gtBWEtoqQltNaGsIbS2hrSO09YS2gdA2EtomQttMaFsIbSuhbSO07YS2g9B2EtouQttNaHsIbS+h7SO0/YR2gNAOEtohQjtMaEcI7ain/49g9EDn2ksPdEYPdN5eeqBzze26a156oPOblx7o/OalBzo33PzrQOfuCGaeJ98IZj6XFzIu4PH6ewSzkMXrP7/3ixi8vo9gFrvt9X8jmCXuev0wglnqntdPI5hlbnn9PIJZ7oaX9xHMCj97/XMEs9KPXtQIZpUfvagRzGo/edEjmDV+8fJhBLPWdS8fRzDrXPbyeQSz3kWvX41gNrjk9esRzEZXvHwZwWxy3svXEcxmp718H8FscdbLiRHMVue8nBrBbHPKy7kRzHYnvJwdwezw3cvpEcxO37xcGMHs8uQbwez25BvB7PHkG8Hs9eQbwezz5BvB7PfJyw9DjAOefCOYg558I5hDnnwjmMOefCOYI558I5ijnmxnhf/pCOaZB9+d6XMPvjvTFx58d6YvPfjuTF958N2ZvvbguzN948F3Z/rWg+/O9J2Hrx8XTru993DiY8xJtw8eTn28OuX20Tkvp9w+OevlhNtn5718dfviipcvbl9d8/qlm+OLSy55/cItgOteProF9IuXD26B/OZFugX2qxfhFsTvXv9w83THy5ubl3teP7kFddfrB7dg7nv91y04h9c3txA8Xn+7heTyglsoPq9/1QjmGN5rHgcnwElwCpwGZ8BZcA6cBxfARXAJXAZXwFVwDVwHN8BNcAvcBnfAXXAP3AcPwEPwCDwGT8BT8Aw8By/AS/AKvAZvwFvvX/g/RowBjhPaCUI7SWinCO00oZ0htLOEdo7QzhPaBUK7SGiXCO0yoV0htKuEdo3QrhPaDUK7SWi3CO02od0htLuEdo/Q7hPaA0J7SGiPCO0xoT0htKeE9ozQnhPaC0J7SWivCO01ob0htLee/j+C0QOday890Bk90Hl76YHONTc90Lnmpgc619z0QOeam4QDnbsjmGOefCOY41xeyHiCx+vvEcxJFq///N6fYvD6PoI57bbX/41gzrjr9cMI5qx7Xj+NYM655fXzCOa8G17eRzAX/Oz1zxHMRT96USOYS370okYwl/3kRY9grvjFy4cRzFXXvXwcwVxz2cvnEcx1F71+NYK54ZLXr0cwN13x8mUEc8t5L19HMLed9vJ9BHPHWS8nRjB3nfNyagRzzykv50Yw953wcnYE88B3L6dHMA9983JhBPPIk28E89iTbwTzxJNvBPPUk28E88yTbwTz3CcvPwwxXnjyjWBeevKNYF558o1gXnvyjWDeePKNYN56sp0V/qcjmNAB+O5MwwTguzMNG4DvzjRcAL470/AB+O5MIwTguzONGIDvzjSSb+deF9wi+36GdtotijPncSfdojp3tnfKLZqz9wROuEV3/s7BV7cYrtxf+OIW07W7kF+6xXL1XuUXbrEZ70zjMN6ZxmW8M43HeGcan/HONAHjnWlCxjvTRIx3pokZ70yTMN6ZJmW8M03GeGeanPHONAWf179qBPMO7zXfgw/gI/gEPoMv4Kvji+xe+O+DgCAQCAyCAE/gBYKCYCA4CAFCglAgNAgDwoJwIDyIACKCSCAyiAKigmggOogBYoJYIDaI4+Xx8xf+3xFjgPeE9oHQPhLaJ0L7TGhfCO0roTl+s7xrAQgtIKEFIrTAhBaE0DwJzYvQghJaMEILTmghCC0koYUitNCEFobQwhJaOEILT2gRCC0ioUUitMiEFoXQohJaNEKLTmgxCC0mocUitNiEFsfL/0cweqBz7aUHOqMHOm8vPdC55qYHOtfc9EDnmpse6Fxzk3Cgc3cE887Tfa/vI5j3jCOYD4wjmI+MI5hPjCOYz4wjmC+MI5ivjCMYx7nQ714/j2ACuOHlfQQT0M9e/xzBBPKjFzWCCexHL2oEE8RPXvQIxtMvXj6MYLxc9/JxBBPUZS+fRzDBXPT61QgmuEtevx7BhHDFy5cRTEjnvXwdwYRy2sv3EUxoZ72cGMGEcc7LqRFMWKe8nBvBhHPCy9kRTHjfvZwewUTwzcuFEUxEL74RTCQvvhFMZC++EUwUL74RTFQvvhFMNJ+8/DDEiO7FN4KJ4cU3gonpxTeCieXFN4KJ7cU3gonjxXZW+J+OYFIy3pmmYrwzTc14Z5qG8c7UMN6ZWsY707SMd6bpGO9M0zPemWZgvDPNyHhnmonxzjQz451pFsY706yMd6bZGO9MszPemeZgvDPNyXhnmovxzjQ3451pHsY707yMd6b5GO9M8zPemRZgvDMtyHhnWojxzrQw451pET6vf9UIJi7ea8YD8UECkBAkAolBEpAUJAPJQQqQEqQCqUEaYIAFaUE6kB5kABlBJpAZZAFZQTaQHeQAOUEux/tckAfkBflAflAAFASFvI9g4hJjgHiEFp/QEhBaQkJLRGiJCS0JoSUltGSElpzQUhBaSkJLRWipCS0NoRlCs4SWltDSEVp6QstAaBkJLROhZSa0LISWldCyEVp2QstBaDkJLReh5Sa0PISWl9DyEVp+QitAaAUJrZCX/49g9EDn4ksPdHqg8/bSA51rbnqgc81ND3SuuemBzjU3CQc6d0cwcb3c9/o+gonH5YWM8Xm8/h7BJGDx+s/vfUIGr+8jmERue/3fCCaxu14/jGCSuOf10wgmKeMIJhnjCCY54wgmBeMIJiXjCCYV4wgmNeMIJg3jCMYwjmAs4wgmLeMIJh3jCCY94wgmA+MIJiPjCCYT4wgmM+MIJgvjCCYr4wgmG+MIJjvjCCYH4wgmJ+MIJhfjCCY34wgmD+MIJi/jCCYf4wgmP+MIpgDjCKYg4wimkNARTFHGO9NijHemxRnvTEsw3pmWZLwzLcV4Z1qa8c60DOOdaVnGO9NyjHem5RnvTCsw3plWZLwzrcR4Z1qZ8c60CuOdaVXGO9NqjHem1RnvTGsw3pnWZLwzrcV4Z1qb8c60DuOdaV3GO9N6jHem9RnvTBsw3pk2ZLwz/Y3P6181gimM95pFQFFQDBQHJUBJUAqUBmVAWVAOlAcVQEVQCVQGVUBVUA1UBzVATVAL1AZ1QF1QD9QHDUBD8Bv4HfwB/gR/gUagMWgCmnofwRQmxgBFCK0ooRUjtOKEVoLQShJaKUIrTWhlCK0soZUjtPKEVoHQKhJaJUKrTGhVCK0qoVUjtOqEVoPQahJaLUKrTWh1CK0uodUjtPqE1oDQGhLab4T2O6H9QWh/EtpfhNaI0BoTWhNCa+rl/yMYPdC59tIDndEDnbeXHuhcc9MDnWtueqBzzU0PdK65STjQuTuCKezlvtf3EUwRxhFMUcYRTDHGEUxxxhFMCcYRTEnGEUwpxhFMacYRTBnGEUxZxhFMOcYRTHnGEUwFxhFMRcYRTCXGEUxlxhFMFcYRTFXGEUw1xhFMdcYRTA3GEUxNxhFMLcYRTG3GEUwdxhFMXcYRTD3GEUx9xhFMA8YRTEPGEcxvjCOY3xlHMH8wjmD+ZBzB/MU4gmnEOIJpzDiCacI4gmkqdATzO+Od6R+Md6Z/Mt6Z/sV4Z9qI8c60MeOdaRPGO9OmjHemzRjvTJsz3pm2YLwzbcl4Z9qK8c60NeOdaRvGO9O2jHem7RjvTNsz3pl2YLwz7ch4Z9qJ8c60M+OdaRfGO9OujHem3RjvTLsz3pn2YLwz7cl4Z9qL8c60N5/Xv2oE0wzvNZuDFqAlaAVagzagLWgH2oMOoCPoBDqDLqAr6Aa6gx6gJ+gFeoM+oC/oB/qDAWAgGAQGgyFgKBgGhoMRYCQYBUaDMWCs9xFMM2IM0JzQWhBaS0JrRWitCa0NobUltHaE1p7QOhBaR0LrRGidCa0LoXUltG6E1p3QehBaT0LrRWi9Ca0PofUltH6E1p/QBhDaQEIbRGiDCW0IoQ0ltGGENpzQRhDaSEIbRWijCW0MoY318v8RjB7oXHvpgc7ogc7bSw90rrnpgc41Nz3QueamBzrX3CQc6NwdwTTzct/r+wimOeMIpgXjCKYl4wimFeMIpjXjCKYN4wimLeMIph3jCKY94wimA+MIpiPjCKYT4wimM+MIpgvjCKYr4wimG+MIpjvjCKYH4wimJ+MIphfjCKY34wimD+MIpi/jCKYf4wimP+MIZgDjCGYg4whmEOMIZjDjCGYI4whmKOMIZhjjCGY44whmBOMIZiTjCGYU4whmNOMIZgzjCGas0BFMH8Y7076Md6b9GO9M+zPemQ5gvDMdyHhnOojxznQw453pEMY706GMd6bDGO9MhzPemY5gvDMdyXhnOorxznQ0453pGMY707GMd6bjGO9MxzPemU5gvDOdyHhnOonxznQy453pFMY706mMd6bTGO9MpzPemc5gvDOdyef1rxrBjMN7zfFgApgIJoHJYAqYCqaB6WAGmAlmgdlgDpgL5oH5YAFYCBaBxWAJWAqWgeVgBVgJVoHVYA1YC9aB9WAD2Ag2gc1gC9jqfQQzjhgDjCe0CYQ2kdAmEdpkQptCaFMJbRqhTSe0GYQ2k9BmEdpsQptDaHMJbR6hzSe0BYS2kNAWEdpiQltCaEsJbRmhLSe0FYS2ktBWEdpqQltDaGsJbR2hrSe0DYS2kdA2EdpmQttCaFu9/H8Eowc61156oDN6oPP20gOda256oHPNTQ90rrnpgc41NwkHOndHMOO83Pf6PoIZzziCmcA4gpnIOIKZxDiCmcw4gpnCOIKZyjiCmcY4gpnOOIKZwTiCmck4gpnFOIKZzTiCmcM4gpnLOIKZxziCmc84glnAOIJZyDiCWcQ4glnMOIJZwjiCWco4glnGOIJZzjiCWcE4glnJOIJZxTiCWc04glnDOIJZyziCWcc4glnPOILZwDiC2cg4gtnEOILZzDiC2cI4gtkqdAQzi/HOdDbjnekcxjvTuYx3pvMY70znM96ZLmC8M13IeGe6iPHOdDHjnekSxjvTpYx3pssY70yXM96ZrmC8M13JeGe6ivHOdDXjnekaxjvTtYx3pusY70zXM96ZbmC8M93IeGe6ifHOdDPjnekWxjvTrYx3ptsY70y383n9q0Yw2/BeczvYAXaCXWA32AP2gn1gPzgADoJD4DA4Ao6CY+A4OAFOglPgNDgDzoJz4Dy4AC6CS+AyuAKugmvgOrgBboJb4Da4A+56H8FsI8YA2wltB6HtJLRdhLab0PYQ2l5C20do+wntAKEdJLRDhHaY0I4Q2lFCO0ZoxwntBKGdJLRThHaa0M4Q2llCO0do5wntAqFdJLRLhHaZ0K4Q2lVCu0Zo1wntBqHdJLRbhHab0O4Q2l0v/x/B6IHOtZce6Iwe6Ly99EDnmpse6Fxz0wOda256oHPNTcKBzt0RzDYv972+j2C2M45gdjCOYHYyjmB2MY5gdjOOYPYwjmD2Mo5g9jGOYPYzjmAOMI5gDjKOYA4xjmAOM45gjjCOYI4yjmCOMY5gjjOOYE4wjmBOMo5gTjGOYE4zjmDOMI5gzjKOYM4xjmDOM45gLjCOYC4yjmAuMY5gLjOOYK4wjmCuMo5grjGOYK4zjmBuMI5gbjKOYG4xjmBuM45g7jCOYO4KHcHsYLwz3cl4Z7qL8c50N+Od6R7GO9O9jHem+xjvTPcz3pkeYLwzPch4Z3qI8c70MOOd6RHGO9OjjHemxxjvTI8z3pmeYLwzPcl4Z3qK8c70NOOd6RnGO9OzjHem5xjvTM8z3pleYLwzvch4Z3qJ8c70MuOd6RXGO9OrfF7/qhHMPbzXvA8egIfgEXgMnoCn4Bl4Dl6Al+AVeA3egLfgHXgPPoCP4BP4DL6Ar44RS1D880BAEAgEBkGAJ/ACQUEwEByEACFBKBAahAnq8fMX/u8RY4D7hPaA0B4S2iNCe0xoTwjtKaE9I7TnhPaC0F4S2itCe01obwjtLaG9I7T3hPaB0D4S2idC+0xoXwjtK6E5/mXxrgUgtICEFojQAhNaEELzJDQvQgtKaMEILTihhSC0kIQWitBCE1qYoP4/gtEDnWsvPdAZPdB5e+mBzjU3PdC55qYHOtfc9EDnmpuEA527I5h7Xu57fR/B3GccwTxgHME8ZBzBPGIcwTxmHME8YRzBPGUcwTxjHME8ZxzBvGAcwbxkHMG8YhzBvGYcwbxhHMG8ZRzBvGMcwbxnHMF8YBzBfGQcwXxiHMF8ZhzBfGEcwXxlHME47mV893JuBBPACS9nRzABffdyegQTyDcvF0YwgYPyjWCCBOUbwXgG5RvBeAXlG8EEDco3ggnmk5cfhhjBg/KNYEIE5RvBhAzKN4IJFZRvBBM6KN8IJkxQtrPC/3QEc43xzvQ6453pDcY705uMd6a3GO9MbzPemd5hvDO9y3hneo/xzvQ+453pA8Y704eMd6aPGO9MHzPemT5hvDN9ynhn+ozxzvQ5453pC8Y705eMd6avGO9MXzPemb5hvDN9y3hn+o7xzvQ9453pB8Y704+Md6afGO9MP/N5/atGMGHxXjMcCA8igIggEogMooCoIBqIDmKAmCAWiA3igLggHogPEoCEIBFIDJKApCAZSA5SgJQgFUgN0gADLEgL0oH0IAPICDJ5H8GEJcYA4QgtPKFFILSIhBaJ0CITWhRCi0po0QgtOqHFILSYhBaL0GITWhxCi0to8QgtPqElILSEhJaI0BITWhJCS0poyQgtOaGlILSUhJaK0FITWhpCM4RmCS0toaUjtPSEloHQMhJapqD+P4K5pgc6l156oDN6oPP20gOda256oHPNTQ90rrnpgc41NwkHOndHMGGDuu/1fQQTjssLGcPzeP09gonA4vWf3/uIDF7fRzCR3Pb6vxFMZHe9fhjBRHHP66cRTFS3vH4ewURzw8v7CCa6n73+OYKJ4UcvagQT049e1Agmlp+86BFMbL94+TCCieO6l48jmLgue/k8gonnotevRjDxXfL69QgmgStevoxgEjrv5esIJpHTXr6PYBI76+XECCaJc15OjWCSMo5gkjGOYJIzjmBSMI5gUjKOYFIxjmBSM45g0jCOYAzjCMYyjmDSMo5g0jGOYNIzjmAyMI5gMjKOYDIJHcF8Ybwz/cp4Z+oRkO/ONEBAvjvTgAH57kwDBeS7Mw0ckO/ONEhAvjtTz4C+flw47eYV0ImPMSfdgjrj5aRbMOe8nHIL7qyXE24hnPfy1S2kK16+uIVyzeuXbqFd9fqFWxjXvXx0C+sXLx/cwvnNi3QL71cvwi2C373+4RbRHS9vbpHc8/rJLbK7Xj+4RXHf679uUTm8vrlF4/H62y06l5fjjobP6181gsmM95pZQFaQDWQHOUBOkMvxPhTkAXlBPpAfFAAFQSFQGBQBRUExUByUACVBKVAalAFlQTlQHlQAFUElUBlUAVVBNVAd1AA1QS3vI5jMxBggC6FlJbRshJad0HIQWk5Cy0VouQktD6HlJbR8hJaf0AoQWkFCK0RohQmtCKEVJbRihFac0EoQWklCK0VopQmtDKGVJbRyhFae0CoQWkVCq0RolQmtCqFVJbRqhFad0GoQWk1CqxXU/0cweqBz7aUHOqMHOm8vPdC55qYHOtfc9EDnmpse6Fxzk3Cgc3cEkzmo+17fRzBZGEcwWRlHMNkYRzDZGUcwORhHMDkZRzC5GEcwuRlHMHkYRzB5GUcw+RhHMPkZRzAFGEcwBRlHMIUYRzCFGUcwRRhHMEUZRzDFGEcwxRlHMCUYRzAlGUcwpRhHMKUZRzBlGEcwZRlHMOUYRzDlGUcwFRhHMBUZRzCVGEcwlRlHMFUYRzBVGUcw1RhHMNUZRzA1GEcwNRlHMLWEjmBiBuS7M40VkO/ONDbjnWkcxjvTuIx3pvEY70zjM96ZJvDt3OuCW0Lfz9BOuyVy5jzupFti5872TrklcfaewAm3pM7fOfjqlsyV+wtf3JK74uWLWwrXvH7pltJVr1+4pXLdy0e31H7x8sEtjd+8aDe/ehFu1u9e/3BL646XN7d07nn95JbeXa8f3DK47/Vft4wcXt/cMvF4/e2WmcsLbln4vP5VI5jaeK9ZB9QF9UB90AA0BL+B38Ef4E/wF2gEGoMmoCloBpqDFqAlaAVagzagLWgH2oMOoCPoBDqDLqAr6Aa6gx6gJ+gFeoM+oK/3EUxtYgxQh9DqElo9QqtPaA0IrSGh/UZovxPaH4T2J6H9RWiNCK0xoTUhtKaE1ozQmhNaC0JrSWitCK01obUhtLaE1o7Q2hNaB0LrSGidCK0zoXUhtK6E1o3QuhNaD0LrSWi9CK03ofUhtL5B/X8Eowc61156oDN6oPP20gOda256oHPNTQ90rrnpgc41NwkHOndHMLWDuu/1fQRTh3EEU5dxBFOPcQRTn3EE04BxBNOQcQTzG+MI5nfGEcwfjCOYPxlHMH8xjmAaMY5gGjOOYJowjmCaMo5gmjGOYJozjmBaMI5gWjKOYFoxjmBaM45g2jCOYNoyjmDaMY5g2jOOYDowjmA6Mo5gOjGOYDozjmC6MI5gujKOYLoxjmC6M45gejCOYHoyjmB6MY5gejOOYPowjmD6Ch3BZGW8M83GeGeanfHONAfjnWlOxjvTXIx3prkZ70zz+HbudcEtr+9naKfd8jlzHnfSLb9zZ3un3Ao4e0/ghFtB5+8cfHUr5Mr9hS9uhV3x8sWtiGtev3Qr6qrXL9yKue7lo1txv3j54FbCb16kW0m/ehFupfzu9Q+30u54eXMr457XT25l3fX6wa2c+17/dSvP4fXNrQKP199uFbm84FaJz+tfNYLph/ea/cEAMBAMAoPBEDAUDAPDwQgwEowCo8EYMBaMA+PBBDARTAKTwRQwFUwD08EMMBPMArPBHDAXzAPzwQKwECwCi8ESsNT7CKYfMQboT2gDCG0goQ0itMGENoTQhhLaMEIbTmgjCG0koY0itNGENobQxhLaOEIbT2gTCG0ioU0itMmENoXQphLaNEKbTmgzCG0moc0itNmENofQ5hLaPEKbT2gLCG0hoS0itMWEtoTQlgb1/xGMHuhce+mBzuiBzttLD3SuuemBzjU3PdC55qYHOtfcJBzo3B3B9Avqvtf3EUx/xhHMAMYRzEDGEcwgxhHMYMYRzBDGEcxQxhHMMMYRzHDGEcwIxhHMSMYRzCjGEcxoxhHMGMYRzFjGEcw4xhHMeMYRzATGEcxExhHMJMYRzGTGEcwUxhHMVMYRzDTGEcx0xhHMDMYRzEzGEcwsxhHMbMYRzBzGEcxcxhHMPMYRzHzGEcwCxhHMQsYRzCLGEcxixhHMEsYRzNL/0Qgm+Ldff/pnuXFnWpnxzrQK451pVcY702qMd6bVGe9MazDemdZkvDOt5du51wW32r6foZ12q8N3Hv9XfVF0Gf7sWQ5WgJVgFVgN1oC1YB1YDzaAjWAT2Ay2gK1gG9gOdoCdYBfYDfaAvWAf2A8OgIPgEDgMjoCj4Bg4Dk6Ak+AUOA3OgLPevyi6jPji0HJCW0FoKwltFaGtJrQ1hLaW0NYR2npC20BoGwltE6FtJrQthLaV0LYR2nZC20FoOwltF6HtJrQ9hLaX0PYR2n5CO0BoBwntEKEdJrQjhHaU0I4R2nFCO0FoJwntFKGdJrQzhHY26D+/KJr226+5v/3698e9foL/5Us/wf/7PsG7e0m+LKj7Xt8vyZczXpKvYLwkX8l4Sb6K8ZJ8NeMl+RrGS/K1jJfk6xgvydczXpJvYLwk38h4Sb6J8ZJ8M+Ml+RbGS/KtjJfk2xgvybczXpLvYLwk38l4Sb6L8ZJ8N+Ml+R7GS/K9jJfk+xgvyfczXpIfYLwkP8h4SX6I8ZL8MOMl+RHGS/KjjJfkxxgvyY8zXpKfYLwkP8l4SX6K8ZL8NOMl+RnGS/KzjJfkHj+8vl+K5Xbqz2zfzw7n2J4zvfXP5zzP95xp/fM5L/A9Zzr/fM6LfM+Z3j+f8xLfc2bwz+e8zPecGf3zOa/wPWcm/3zOq3zPmdk/n/Ma33Nm8c/nvM73nHX88zlv8D1nXf98zpt8z1nPP5/zFt9z1vfP57zN95wN/PM57/A9Z0P/fM67bM+ZwV/ff97je05/ff95n+85/fX95wO+5/TX958P+Z7TX99/PuJ7Tn99//mY7zn99f3nE77n9Nf3n0/5ntNf338+43tOf33/+ZzvOf31/ecLtufM6K+fj17yPae/fj56xfec/vr56DXfc/rr56M3fM/pr5+P3vI9p79+PnrH95z++vnoPd9z+uvnow98z+mvn48+8j2nv34++sT3nP56H/KZ7zn99T7kC99z+ut9yFe+5/TX+xCPYGzP6a/3IQHYnjOTv96HBOR7Tn99/xmI7zn99f1nYL7n9Nf3n0H4ntNf33968j2nv77/9OJ7Tn99/xmU7zn99f1nML7n9Nf3n8H5ntNf33+G4HtOf33/GZLtOdP56+fNUHzP6a+fN0PzPae/ft4Mw/ec/vp5Myzfc/rr581wfM/pr583w/M9p79+3ozA95z++nkzIt9z+uvnzUh8z+mvnzcjsz1nWn89v0dhe84MDR1/hzLyD8/m2Gw69pCOraFjx+fYyDn2Z45tl2M35dgkOfY+ji2NY6fi2IA49hWO7YJjF+D4mrvj69mOrxU7vg7r+Bqn4+uHjq/NOb7u5fiakuPrNY6vhTi+zuC4w3fcjzvunh33uo47U8d9pOOuz3GP5rijctz/OO5WHPcWjjsBx3nbcZZ1nBMdZzDH+cZxdnC8L3e853W8n3S8V3O8D3K8x3B8/nZ8bnR83nH8me7489LxZ5Hj49zxMeT499PRveP31fEK+O33xPuL5/f8/za3AXh97dog/+8/Y9RgjM8otag1AoqKpkUZu1pAUdG1KGNXCSgqhhZl7EoBRcXUooxdIaCoWFqUscsFFBVbizJ2mYCi4mhRxi4VUFRcLcrYJQKKiqdFGbtYQFHxtShjFwkoKoEWZexCAUUl1KKMXSCgqERalLHzBRSVWIsydp6AopJoUcbOFVBUUi3K2DkCikqmRRk7W0BRybUoY2cJKCqFFmXsTAFFpdSijJ0hoKhUWpSx0wUUlVqLMnaagKLSaFHGThVQlNGijJ0ioCirRRk7WUBRabUoYycJKCqdFmXsRAFFpdeijJ0goKgMWpSx4wUUlVGLMnacgKIyaVHGjhVQVGYtytgxAorKokUZO1pAUVm1KGNHCSgqmxZl7EgBRWXXoowdIaCoHFqUscMFFJVTizJ2mICicmlRxl4VUFRuLcrYKwKKyqNFGXtZQFF5tShjLwkoKp8WZexFAUXl16KMvSCgqAJalLHnBRRVUIsy9pyAogppUcaeFVBUYS3K2DMCiiqiRRl7WkBRRbUoY08JKKqYFmXsSQFFFdeijD0hoKgSWpSxxwUUVVKLMvaYgKJKaVHGHhVQVGktytgjAooqo0UZe1hAUWW1KGMPCSiqnBZl7EEBRZXXoow9IKCoClqUsfsFFFVRizJ2n4CiKmlRxu4VUFRlLcrYPQKKqqJFGbtbQFFVtShjdwkoqpoWZexOAUVV16KM3SGgqBpalLHbBRRVU4sydpuAomppUcZuFVBUbS3K2C0CiqqjRRm7WUBRdbUoYzcJKKqeFmXsRgFF1deijN0goKgGWpSx6wUU1VCLMnadgKJ+06KM9fL8f/8Zf9eijPUUUNQfWpSxQQQU9acWZWxgAUX9pUUZG0hAUY20KGMDCiiqsRZlbAABRTXRooz1EFBUUy3K2K8CDrzNtChjvwgoqrkWZexnAUW10KKM/SSgqJZalLEfBRTVSosy9oOAolprUca+F1BUGy3K2HcCimqrRRn7VkBR7bQoY98IKKq9FmXsawFFddCijH0loKiOWpSxLwUU1UmLMvaFgKI6a1HGPhdQVBctythnAorqqkUZ+1RAUd20KGOfCCiquxZl7GMBRfXQoox9JKConlqUsQ8FFNVLizL2gYCiemtRxt4XUFQfLcrYewKK6qtFGXtXQFH9tChj7wgoqr8WZextAUUN0KKMvSWgqIFalLE3BRQ1SIsy9oaAogZrUcZeF1DUEC3K2GsCihqqRRmbRsBfZBumRRmbWkBRw7UoY1MJKGqEFmVsSgFFjdSijE0hoKhRWpSxyQUUNVqLMjaZgKLGaFHGJhVQ1FgtytgkAooap0UZm1hAUeO1KGMTCShqghZlbEIBRU3UooxNIKCoSVqUsfEFFDVZizI2noCipmhRxsYVUNRULcrYOAKKmqZFGRtbQFHTtShjYwkoaoYWZWxMAUXN1KKMjSGgqFlalLHRBRQ1W4syNpqAouZoUcZGFVDUXC3K2CgCipqnRRkbWUBR87UoYyMJKGqBFmVsRAFFLdSijI0goKhFWpSx4QUUtViLMjacgKKWaFHGhhVQ1FItytgwAopapkUZG1pAUcu1KGNDCShqhRZlbEgBRa3UoowNIaCoVVqUscEFFLVaizI2mICi1mhRxgYVUNRaLcrYSgKKWqdFGVtRQFHrtShjKwgoaoMWZWx5AUVt1KKMLSegqE1alLFlBRS1WYsytoyAorZoUcaWFlDUVi3K2FICitqmRRlbUkBR27UoY0sIKGqHFmVscQFF7dSijC0moKhdWpSxRQUUtVuLMraIgKL2aFHGFhZQ1F4tythCAorap0UZW1BAUfu1KGMLCCjqgBZlbH4BRR3UoozNJ6CoQ1qUsXkFFHVYizI2j4CijmhRxuYWUNRRLcrYXAKKOqZFGZtTQFHHtShjcwgo6oQWZWx2AUWd1KKMzSagqFNalLFZBRR1WosyNouAos5oUcZmFlDUWS3K2EwCijqnRRmbUUBR57UoYzMIKOqCFmVsegFFXdSijE0noKhLWpSxaQUUdVmLMtYKKOqKFmWsEVDUVS3K2K4CirqmRRnbRUBR17UoYzsLKOqGFmVsJwFF3dSijO0ooKhbWpSxHQQUdVuLMra9gKLuaFHGthNQ1F0tyti2Aoq6p0UZ20ZAUfe1KGNbCyjqgRZlbCsBRT3UooxtKaCoR1qUsS0EFPVYizK2uYCinmhRxjYTUNRTLcrYpgKKeqZFGdtEQFHPtShjGwso6oUWZWwjAUW91KKM/UtAUa+0KGP/FFDUay3K2D8EFPVGizL2dwFFvdWijP1NQFHvtChjGwoo6r0WZWwDAUV90KKMrS+gqI9alLH1BBT1SYsytq6Aoj5rUcbWEVDUFy3K2NoCivqqRRlbS0BRHsG1KFtTQFEBtChjawgoKqAWZWx1AUUF0qKMrSagqMBalLFVBRQVRIsytoqAojy1KGMrCyjKS4sydq6AooJqUcbOEVBUMC3K2NkCigquRRk7S0BRIbQoY2cKKCqkFmXsDAFFhdKijJ0uoKjQWpSx0wQUFUaLMnaqgKLCalHGThFQVDgtytjJAooKr0UZO0lAURG0KGMnCigqohZl7AQBRUXSoowdL6CoyFqUseMEFBVFizJ2rICiompRxo4RUFQ0LcrY0QKKiq5FGTtKQFExtChjRwooKqYWZewIAUXF0qKMHS6gqNhalLHDBBQVR4sydqiAouJqUcYOEVBUPC3K2MECioqvRRk7SEBRCbQoYwcKKCqhFmXsAAFFJdKijO0voKjEWpSx/QQUlUSLMravgKKSalHG9hFQVDItytjeAopKrkUZ20tAUSm0KGN7CigqpRZlbA8BRaXSooztLqCo1FqUsd0EFJVGizL2qICijBZl7BEBRVktytjDAopKq0UZe0hAUem0KGMPCigqvRZl7AEBRWXQoozdL6CojFqUsfsEFJVJizJ2r4CiMmtRxu4RUFQWLcrY3QKKyqpFGbtLQFHZtChjdwooKrsWZewOAUXl0KKM3S6gqJxalLHbBBSVS4sydquAonJrUcZuEVBUHi3K2M0CisqrRRm7SUBR+bQoYzcKKCq/FmXsBgFFFdCijF0voKiCWpSx6wQUVUiLMnatgKIKa1HGrhFQVBEtytjVAooqqkUZu0pAUcW0KGNXCiiquBZl7AoBRZXQooxdLqCoklqUscsEFFVKizJ2qYCiSmtRxi4RUFQZLcrYxQKKKqtFGbtIQFHltChjFwooqrwWZewCAUVV0KKMnS+gqIpalLHzBBRVSYsy9q2AoiprUca+EVBUFS3K2NcCiqqqRRn7SkBR1bQoY18KKKq6FmXsCwFF1dCijH0uoKiaWpSxzwQUVUuLMvapgKJqa1HGPhFQVB0tytjHAoqqq0UZ+0hAUfW0KGMfCiiqvhZl7AMBRTXQooy9L6CohlqUsfcEFPWbFmXsXQFF/a5FGXtHQFF/aFHG3hZQ1J9alLG3BBT1lxZl7E0BRTXSooy9IaCoxlqUsdcFFNVEizL2moCimmpRxl4VUFQzLcrYKwKKaq5FGXtZQFEttChjLwkoqqUWZexFAUW10qKMvSCgqNZalLHnBRTVRosy9pyAotpqUcaeFVBUOy3K2DMCimqvRRl7WkBRHbQoY08JKKqjFmXsSQFFddKijD0hoKjOWpSxxwUU1UWLMvaYgKK6alHGxvH6f/8Zu2lRxsYWUFR3LcrYWAKK6qFFGRtTQFE9tShjYwgoqpcWZWx0AUX11qKMjSagqD5alLFRBRTVV4syNoqAovppUcZGFlBUfy3K2EgCihqgRRkbUUBRA7UoYyMIKGqQFmVseAFFDdaijA0noKghWpSxYQUUNVSLMjaMgKKGaVHGhhZQ1HAtythQAooaoUUZG1JAUSO1KGNDCChqlBZlbHABRY3WoowNJqCoMVqUsUEFFDVWizLWS0BR47QoYz0FFDVeizI2iICiJmhRxgYWUNRELcrYQAKKmqRFGRtQQFGTtShjAwgoaooWZayHgKKmalHGfhXwF9mmaVHGfhFQ1HQtytjPAoqaoUUZ+0lAUTO1KGM/CihqlhZl7AcBRc3Woox9L6CoOVqUse8EFDVXizK2kIAD7zwtytiCAoqar0UZW0BAUQu0KGPzCyhqoRZlbD4BRS3SoozNK6CoxVqUsXkEFLVEizI2t4CilmpRxuYSUNQyLcrYnAKKWq5FGZtDQFErtChjswsoaqUWZWw2AUWt0qKMzSqgqNValLFZBBS1RosyNrOAotZqUcZmElDUOi3K2IwCilqvRRmbQUBRG7QoY9MLKGqjFmVsOgFFbdKijE0roKjNWpSxVkBRW7QoY42AorZqUcamEVDUNi3K2NQCitquRRmbSkBRO7QoY1MKKGqnFmVsCgFF7dKijE0uoKjdWpSxyQQUtUeLMjapgKL2alHGJhFQ1D4tytjEAorar0UZm0hAUQe0KGMTCijqoBZlbAIBRR3SooyNL6Cow1qUsfEEFHVEizI2roCijmpRxjYVUNQxLcrYJgKKOq5FGdtYQFEntChjGwko6qQWZexfAoo6pUUZ+6eAok5rUcb+IaCoM1qUsb8LKOqsFmXsbwKKOqdFGdtQQFHntShjGwgo6oIWZWx9AUVd1KKMrSegqEtalLF1BRR1WYsyto6Aoq5oUcbWFlDUVS3K2FoCirqmRRlbU0BR17UoY2sIKOqGFmVsdQFF3dSijK0moKhbWpSxVQUUdVuLMraKgKLuaFHGVhZQ1F0tythKAoq6p0UZW1FAUfe1KGMrCCjqgRZlbHkBRT3UoowtJ6CoR1qUsWUFFPVYizK2jICinmhRxpYWUNRTLcrYUgKKeqZFGVtSQFHPtShjSwgo6oUWZWxxAUW91KKMLSagqFdalLFFBRT1WosytoiAot5oUcYWFlDUWy3K2LECinqnRRk7RkBR77UoY0cLKOqDFmXsKAFFfdSijB0poKhPWpSxIwQU9VmLMna4gKK+aFHGDhNQ1FctytihAoryCKFF2SECigqgRRk7WEBRAbUoYwcJKCqQFmXsQAFFBdaijB0goKggWpSx/QUU5alFGdtPQFFeWpSxfQUUFVSLMraPgKKCaVHG9hZQVHAtytheAooKoUUZ21NAUSG1KGN7CCgqlBZlbHcBRYXWooztJqCoMFqUsV0FFBVWizK2i4CiwmlRxnYWUFR4LcrYTgKKiqBFGdtRQFERtShjOwgoKpIWZWx7AUVF1qKMbSegqChalLFtBRQVVYsyto2AoqJpUca2FlBUdC3K2FYCioqhRRnbUkBRMbUoY1sIKCqWFmVscwFFxdaijG0moKg4WpSxWwUUFVeLMnaLgKLiaVHGbhZQVHwtythNAopKoEUZu1FAUQm1KGM3CCgqkRZl7HoBRSXWooxdJ6CoJFqUsWsFFJVUizJ2jYCikmlRxq4WUFRyLcrYVQKKSqFFGbtSQFEptShjVwgoKpUWZexyAUWl1qKMXSagqDRalLFLBRRltChjlwgoympRxi4WUFRaLcrYRQKKSqdFGbtQQFHptShjFwgoKoMWZex8AUVl1KKMnSegqExalLFzBRSVWYsydo6AorJoUcbOFlBUVi3K2FkCisqmRRk7U0BR2bUoY2cIKCqHFmXsdAFF5dSijJ0moKhcWpSxUwUUlVuLMnaKgKLyaFHGThZQVF4tythJAorKp0UZO1FAUfm1KGMnCCiqgBZl7HgBRRXUoowdJ6CoQlqUsXcFFFVYizL2joCiimhRxt4WUFRRLcrYWwKKKqZFGXtTQFHFtShjbwgoqoQWZex1AUWV1KKMvSagqFJalLFXBRRVWosy9oqAospoUcZeFlBUWS3K2EsCiiqnRRl7UUBR5bUoYy8IKKqCFmXseQFFVdSijD0noKhKWpSxZwUUVVmLMvaMgKKqaFHGnhZQVFUtythTAoqqpkUZe1JAUdW1KGNPCCiqhhZl7HEBRdXUoow9JqCoWlqUsUcFFFVbizL2iICi6mhRxh4WUFRdLcrYQwKKqqdFGXtQQFH1tShjDwgoqoEWZex+AUU11KKM3SegqN+0KGP3Cijqdy3K2D0CivpDizJ2t4Ci/tSijN0loKi/tChjdwooqpEWZewOAUU11qKM3S6gqCZalLHbBBTVVIsyNkzQ//efsZkWZWxoAUU116KMDSWgqBZalLEhBRTVUosyNoSAolppUcYGF1BUay3K2GACimqjRRkbVEBRbbUoY70EFNVOizLWU0BR7bUoY4MIKKqDFmVsYAFFddSijA0koKhOWpSxAQUU1VmLMjaAgKK6aFHGeggoqqsWZexXAV847KZFGftFQFHdtShjPwsoqocWZewnAUX11KKM/SigqF5alLEfBBTVW4sy9r2AovpoUca+E1BUXy3K2LcCiuqnRRn7RkBR/bUoY18LKGqAFmXsKwFFDdSijH0poKhBWpSxLwQUNViLMva5gKKGaFHGPhNQ1FAtytinAooapkUZ+0RAUcO1KGMfCyhqhBZl7CMBRY3Uoox9KKCoUVqUsQ8EFDVaizL2voCixmhRxt4TUNRYLcrYTAIGmOO0KGMzCihqvBZlbAYBRU3QooxNL6CoiVqUsekEFDVJizI2rYCiJmtRxloBRU3Roow1AoqaqkUZm0ZAUdO0KGNTCyhquhZlbCoBRc3QooxNKaComVqUsSkEFDVLizI2uYCiZmtRxiYTUNQcLcrYpAKKmqtFGZtEQFHztChjEwsoar4WZWwiAUUt0KKMTSigqIValLEJBBS1SIsyNr6AohZrUcbGE1DUEi3K2LgCilqqRRkbR0BRy7QoY2MLKGq5FmVsLAFFrdCijI0poKiVWpSxMQQUtUqLMja6gKJWa1HGRhNQ1BotytioAopaq0UZG0VAUeu0KGMjCyhqvRZlbCQBRW3QooyNKKCojVqUsREEFLVJizI2vICiNmtRxoYTUNQWLcrYsAKK2qpFGVtLQFHbtChjawooarsWZWwNAUXt0KKMrS6gqJ1alLHVBBS1S4sytqqAonZrUcZWEVDUHi3K2MoCitqrRRlbSUBR+7QoYysKKGq/FmVsBQFFHdCijC0voKiDWpSx5QQUdUiLMrasgKIOa1HGlhFQ1BEtytjSAoo6qkUZW0pAUce0KGNLCijquBZlbAkBRZ3QoowtLqCok1qUscUEFHVKizK2qICiTmtRxhYRUNQZLcrYwgKKOqtFGVtIQFHntChjCwoo6rwWZWwBAUVd0KKMzS+gqItalLH5BBR1SYsyNq+Aoi5rUcbmEVDUFS3K2NwCirqqRRmbS0BR17QoY3MKKOq6FmVsDgFF3dCijM0uoKibWpSx2QQUdUuLMjargKJua1HGZhFQ1B0tytjMAoq6q0UZ21dAUfe0KGP7CCjqvhZlbG8BRT3QooztJaCoh1qUsT0FFPVIizK2h4CiHmtRxnYXUNQTLcrYbgKKeqpFGdtVQFHPtChjuwgo6rkWZWxnAUW90KKM7SSgqJdalLEdBRT1SosytoOAol5rUca2F1DUGy3K2HYCinqrRRnbVkBR77QoY9sIKOq9FmVsawFFfdCijG0loKiPWpSxLQUU9UmLMraFgKI+a1HGNhdQ1BctythmAor6qkUZ21RAUR4htSjbREBRAbQoYxsLKCqgFmVsIwFFBdKijP1LQFGBtShj/xRQVBAtytg/BBTlqUUZ+7uAory0KGN/E1BUUC3K2IYCigqmRRnbQEBRwbUoY+sLKCqEFmVsPQFFhdSijK0roKhQWpSxdQQUFVqLMra2gKLCaFHGLhVQVFgtytglAooKp0UZu1hAUeG1KGMXCSgqghZl7EIBRUXUooxdIKCoSFqUsfMFFBVZizJ2noCiomhRxs4VUFRULcrYOQKKiqZFGTtbQFHRtShjZwkoKoYWZexMAUXF1KKMnSGgqFhalLHTBRQVW4sydpqAouJoUcZOFVBUXC3K2CkCioqnRRk7WUBR8bUoYycJKCqBFmXsRAFFJdSijJ0goKhEWpSx4wUUlViLMnacgKKSaFHGjhVQVFItytgxAopKpkUZO1pAUcm1KGNHCSgqhRZl7EgBRaXUoowdIaCoVFqUscMFFJVaizJ2mICi0mhRxg4VUJTRoowdIqAoq0UZO1hAUWm1KGMHCSgqnRZl7EABRaXXoowdIKCoDFqUsf0FFJVRizK2n4CiMmlRxp4VUFRmLcrYMwKKyqJFGXtaQFFZtShjTwkoKpsWZexJAUVl16KMPSGgqBxalLHHBRSVU4sy9piAonJpUcYeFVBUbi3K2CMCisqjRRl7WEBRebUoYw8JKCqfFmXsQQFF5deijD0goKgCIfmf8e9XQOYHrRvw/7zSmYzp0zfIlLaBTWfrmLRZ6mbOYNJnqJsxs81sM2TOUD9t5nTpGmROnzlTlrpZMpksNn26BrZhhizpGn4zixrMf0JzZ67HmDmakMz1GTNHF5K5AWPmGEIyN2TMHFNI5t8YM8cSkvl3xsyxhWT+gzFzHCGZ/2TMHFdI5r8YM8cTkrkRY+b4QjI3ZsycQEjmJoyZEwrJ3JQxcyIhmZsxZk4sJHNzxsxJhGRuwZg5qZDMLRkzJxOSuRVj5uRCMrdmzJxCSOY2jJlTCsncljFzKiGZ2zFmTi0kc3vGzGmEZO7AmNkIydyRMbMVkrkTY+a0QjJ3ZsycTkjmLoyZ0wvJ3JUxcwYhmbsxZs4oJHN3xsyZhGTuwZg5s5DMPRkzZxGSuRdj5qxCMvdmzJxNSOY+jJmzC8nclzFzDiGZ+zFmzikkc3/GzLmEZB7AmDm3kMwDGTPnEZJ5EGPmvEIyD2bMnE9I5iGMmfMLyTyUMXMBIZmHMWYuKCTzcMbMhYRkHsGYubCQzCMZMxcRknkUY+aiQjKPZsxcTEjmMYyZiwvJPJYxcwkhmccxZi4pJPN4xsylhGSewJi5tJDMExkzlxGSeRJj5rJCMk9mzFxOSOYpjJnLC8k8lTFzBSGZpzFmrigk83TGzJWEZJ7BmLmykMwzGTNXEZJ5FmPmqkIyz2bMXE1I5jmMmasLyTyXMXMNIZnnMWauKSTzfMbMtYRkXsCYubaQzAsZM9cRknkRY+a6QjIvZsxcT0jmJYyZ6wvJvJQxcwMhmZcxZm4oJPNyxsy/Ccm8gjHz70Iyr2TM/IeQzKsYM/8pJPNqxsx/Ccm8hjFzIyGZ1zJmbiwk8zrGzE2EZF7PmLmpkMwbGDM3E5J5I2Pm5kIyb2LM3EJI5s2MmVsKybyFMXMrIZm3MmZuLSTzNsbMbYRk3s6Yua2QzDsYM7cTknknY+b2QjLvYszcQUjm3YyZOwrJvIcxcychmfcyZu4sJPM+xsxdhGTez5i5q5DMBxgzdxOS+SBj5u5CMh9izNxDSObDjJl7Csl8hDFzLyGZjzJm7i0k8zHGzH2EZD7OmLmvkMwnGDP3E5L5JGPm/kIyn2LMPEBI5tOMmQcKyXyGMfMgIZnPMmYeLCTzOcbMQ4RkPs+YeaiQzBcYMw8TkvkiY+bhQjJfYsw8Qkjmy4yZRwrJfIUx8yghma8yZh4tJPM1xsxjhGS+zph5rJDMNxgzjxOS+SZj5vFCMt9izDxBSObbjJknCsl8hzHzJCGZ7zJmniwk8z3GzFOEZL7PmHmqkMwPGDNPE5L5IWPm6UIyP2LMPENI5seMmWcKyfyEMfMsIZmfMmaeLSTzM8bMc4Rkfs6Yea6QzC8YM88TkvklY+b5QjK/Ysy8QEjm14yZFwrJ/IYx8yIhmd8yZl4sJPM7xsxLhGR+z5h5qZDMHxgzLxOS+SNj5uVCMn9izLxCSObPjJlXCsn8hTHzKiGZvzJmXi0ks0cgvsxrhGQOwJh5rZDMARkzrxOSORBj5vVCMgdmzLxBSOYgjJk3CsnsyZh5k5DMXoyZNwvJHJQx8xYhmYMxZt4qJHNwxszbhGQOwZh5u5DMIRkz7xCSORRj5p1CModmzLxLSOYwjJl3C8kcljHzHiGZwzFm3iskc3jGzPuEZI7AmHm/kMwRGTMfEJI5EmPmg0IyR2bMfEhI5iiMmQ8LyRyVMfMRIZmjMWY+KiRzdMbMx4RkjsGY+biQzDEZM58QkjkWY+aTQjLHZsx8SkjmOIyZTwvJHJcx8xkhmeMxZj4rJHN8xsznhGROwJj5vJDMCRkzXxCSORFj5otCMidmzHxJSOYkjJkvC8mclDHzFSGZkzFmviokc3LGzNeEZE7BmPm6kMwpGTPfEJI5FWPmm0Iyp2bMfEtI5jSMmW8LyWwYM98RktkyZr4rJHNaxsz3hGROx5j5vpDM6RkzPxCSOQNj5odCMmdkzPxISOZMjJkfC8mcmTHzEyGZszBmfiokc1bGzM+EZM7GmPm5kMzZGTO/EJI5B2Pml0Iy52TM/EpI5lyMmV8LyZybMfMbIZnzMGZ+KyRzXsbM74RkzseY+b2QzPkZM38QkrkAY+aPQjIXZMz8SUjmQoyZPwvJXJgx8xchmYswZv4qJHNRxswewWVkLsaYOYCQzMUZMwcUkrkEY+ZAQjKXZMwcWEjmUoyZgwjJXJoxs6eQzGUYM3sJyVyWMXNQIZnLMWYOJiRzecbMwYVkrsCYOYSQzBUZM4cUkrkSY+ZQQjJXZswcWkjmKoyZwwjJXJUxc1ghmasxZg4nJHN1xszhhWSuwZg5gpDMNRkzRxSSuRZj5khCMtdmzBxZSOY6jJmjCMlclzFzVCGZ6zFmjiYkc33GzNGFZG7AmDmGkMwNGTPHFJL5N8bMsYRk/p0xc2whmf9gzBxHSOY/GTPHFZL5L8bM8YRkbsSYOb6QzI0ZMycQkrkJY+aEQjI3ZcycSEjmZoyZEwvJ3JwxcxIhmVswZk4qJHNLxszJhGRuxZg5uZDMrRkzpxCSuQ1j5pRCMrdlzJxKSOZ2jJlTC8ncnjFzGiGZOwTiy2yEZO7ImNkKydyJMXNaIZk7M2ZOJyRzF8bM6YVk7sqYOYOQzN0YM2cUkrk7Y+ZMQjL3YMycWUjmnoyZswjJ3Isxc1YhmXszZs4mJHMfxszZhWTuy5g5h5DM/Rgz5xSSuT9j5lxCMg9gzJxbSOaBjJnzCMk8iDFzXiGZBzNmzick8xDGzPmFZB7KmLmAkMzDGDMXFJJ5OGPmQkIyj2DMXFhI5pGMmYsIyTyKMXNRIZlHM2YuJiTzGMbMxYVkHsuYuYSQzOMYM5cUknk8Y+ZSQjJPYMxcWkjmiYyZywjJPIkxc1khmSczZi4nJPMUxszlhWSeypi5gpDM0xgzVxSSeTpj5kpCMs9gzFxZSOaZjJmrCMk8izFzVSGZZzNmriYk8xzGzNWFZJ7LmLmGkMzzGDPXFJJ5PmPmWkIyL2DMXFtI5oWMmesIybyIMXNdIZkXM2auJyTzEsbM9YVkXsqYuYGQzMsYMzcUknk5Y+bfhGRewZj5dyGZVzJm/kNI5lWMmf8Uknk1Y+a/hGRew5i5kZDMaxkzNxaSeR1j5iZCMq9nzNxUSOYNjJmbCcm8kTFzcyGZNzFmbiEk82bGzC2FZN7CmLmVkMxbGTO3FpJ5G2PmNkIyb2fM3FZI5h2MmdsJybyTMXN7IZl3MWbuICTzbsbMHYVk3sOYuZOQzHsZM3cWknkfY+YuQjLvZ8zcVUjmA4yZuwnJfJAxc3chmQ8xZu4hJPNhxsw9hWQ+wpi5l5DMRxkz9xaS+Rhj5j5CMh9nzNxXSOYTjJn7Ccl8kjFzfyGZTzFmHiAk82nGzAOFZD7DmHmQkMxnGTMPFpL5HGPmIUIyn2fMPFRI5guMmYcJyXyRMfNwIZkvMWYeISTzZcbMI4VkvsKYeZSQzFcZM48WkvkaY+YxQjJfZ8w8VkjmG4yZxwnJfJMx83ghmW8xZp4gJPNtxswThWS+w5h5kpDMdxkzTxaS+R5j5ilCMt9nzDxVSOYHjJmnCcn8kDHzdCGZHzFmniEk82PGzDOFZH7CmHmWkMxPGTPPFpL5GWPmOUIyP2fMPFdI5heMmecJyfySMfN8IZlfMWZeICTza8bMC4VkfsOYeZGQzG8ZMy8WkvkdY+YlQjK/Z8y8VEjmD4yZlwnJ/JEx83IhmT8xZl4hJPNnxswrhWT+wph5lZDMXxkzrxaS2SMwX+Y1QjIHYMy8VkjmgIyZ1wnJHIgx83ohmQMzZt4gJHMQxswbhWT2ZMy8SUhmL8bMm4VkDsqYeYuQzMEYM28Vkjk4Y+ZtQjKHYMy8XUjmkIyZdwjJHIox804hmUMzZt4lJHMYxsy7hWQOy5h5j5DM4Rgz7xWSOTxj5n1CMkdgzLxfSOaIjJkPCMkciTHzQSGZIzNmPiQkcxTGzIeFZI7KmPmIkMzRGDMfFZI5OmPmY0Iyx2DMfFxI5piMmU8IyRyLMfNJIZljM2Y+JSRzHMbMp4VkjsuY+YyQzPEYM58Vkjk+Y+ZzQjInYMx8XkjmhIyZLwjJnIgx80UhmRMzZr4kJHMSxsyXhWROypj5ipDMyRgzXxWSOTlj5mtCMqdgzHxdSOaUjJlvCMmcijHzTSGZUzNmviUkcxrGzLeFZDaMme8IyWwZM98VkjktY+Z7QjKnY8x8X0jm9IyZHwjJnIEx80MhmTMyZn4kJHMmxsyPhWTOzJj5iZDMWRgzPxWSOStj5mdCMmdjzPxcSObsjJlfCMmcgzHzSyGZczJmfiUkcy7GzK+FZM7NmPmNkMx5GDO/FZI5L2Pmd0Iy52PM/F5I5vyMmT8IyVyAMfNHIZkLMmb+JCRzIcbMn4VkLsyY+YuQzEUYM38VkrkoY2aPEDIyF2PMHEBI5uKMmQMKyVyCMXMgIZlLMmYOLCRzKcbMQYRkLs2Y2VNI5jKMmb2EZC7LmDmokMzlGDMHE5K5PGPm4EIyV2DMHEJI5oqMmUMKyVyJMXMoIZkrM2YOLSRzFcbMYYRkrsqYOayQzNUYM4cTkrk6Y+bwQjLXYMwcQUjmmoyZIwrJXIsxcyQhmWszZo4sJHMdxsxRhGSuy5g5qpDM9RgzRxOSuT5j5uhCMjdgzBxDSOaGjJljCsn8G2PmWEIy/86YObaQzH8wZo4jJPOfjJnjCsn8F2PmeEIyN2LMHF9I5saMmRMIydyEMXNCIZmbMmZOJCRzM8bMiYVkbs6YOYmQzC0YMycVkrklY+ZkQjK3YsycXEjm1oyZUwjJ3IYxc0ohmdsyZk4lJHM7xsyphWRuz5g5jZDMHRgzGyGZOzJmtkIyd2LMnFZI5s6MmdMJydyFMXN6IZm7MmbOICRzN8bMGYVk7s6YOZOQzD0YM2cWkrknY+YsQjL3YsycVUjm3oyZswnJ3Icxc3YhmfsyZs4hJHM/xsw5hWTuz5g5l5DMAxgz5xaSeSBj5jxCMg9izJxXSObBjJnzCck8hDFzfiGZhzJmLiAk8zDGzAWFZB7OmLmQkMwjGDMXFpJ5JGPmIkIyj2LMXFRI5tGMmYsJyTyGMXNxIZnHMmYuISTzOMbMJYVkHs+YuZSQzBMYM5cWknkiY+YyQjJPYsxcVkjmyYyZywnJPIUxc3khmacyZq4gJPM0xswVhWSezpi5kpDMMxgzVxaSeSZj5ipCMs9izFxVSObZjJmrCck8hzFzdSGZ5zJmriEk8zzGzDWFZJ7PmLmWkMwLGDPXFpJ5IWPmOkIyL2LMXFdI5sWMmesJybyEMXN9IZmXMmZuICTzMsbMDYVkXs6Y+TchmVcwZv5dSOaVjJn/EJJ5FWPmP4VkXs2Y+S8hmdcwZm4kJPNaxsyNhWRex5i5iZDM6xkzNxWSeQNj5mZCMm9kzNxcSOZNjJlbCMm8mTFzSyGZtzBmbiUk81bGzK2FZN7GmLmNkMzbGTO3FZJ5B2PmdkIy72TM3F5I5l2MmTsIybybMXNHIZn3MGbuJCTzXsbMnYVk3seYuYuQzPsZM3cVkvkAY+ZuQjIfZMzcXUjmQ4yZewjJfJgxc08hmY8wZu4lJPNRxsy9hWQ+xpi5j5DMxxkz9xWS+QRj5n5CMp9kzNxfSOZTjJkHCMl8mjHzQCGZzzBmHiQk81nGzIOFZD7HmHmIkMznGTMPFZL5AmPmYUIyX2TMPFxI5kuMmUcIyXyZMfNIIZmvMGYeJSTzVcbMo4VkvsaYeYyQzNcZM48VkvkGY+ZxQjLfZMw8XkjmW4yZJwjJfJsx80Qhme8wZp4kJPNdxsyThWS+x5h5ipDM9xkzTxWS+QFj5mlCMj9kzDxdSOZHjJlnCMn8mDHzTCGZnzBmniUk81PGzLOFZH7GmHmOkMzPGTPPFZL5BWPmeUIyv2TMPF9I5leMmRcIyfyaMfNCIZnfMGZeJCTzW8bMi4VkfseYeYmQzO8ZMy8VkvkDY+ZlQjJ/ZMy8XEjmT4yZVwjJ/Jkx80ohmb8wZl4lJPNXxsyrhWT2CMKXeY2QzAEYM68VkjkgY+Z1QjIHYsy8XkjmwIyZNwjJHIQx80YhmT0ZM28SktmLMfNmIZmDMmbeIiRzMMbMW4VkDs6YeZuQzCEYM28XkjkkY+YdQjKHYsy8U0jm0IyZdwnJHIYx824hmcMyZt4jJHM4xsx7hWQOz5h5n5DMERgz7xeSOSJj5gNCMkdizHxQSObIjJkPCckchTHzYSGZozJmPiIkczTGzEeFZI7OmPmYkMwxGDMfF5I5JmPmE0Iyx2LMfFJI5tiMmU8JyRyHMfNpIZnjMmY+IyRzPMbMZ4Vkjs+Y+ZyQzAkYM58XkjkhY+YLQjInYsx8UUjmxIyZLwnJnIQx82UhmZMyZr4iJHMyxsxXhWROzpj5mpDMKRgzXxeSOSVj5htCMqdizHxTSObUjJlvCcmchjHzbSGZDWPmO0IyW8bMd4VkTsuY+Z6QzOkYM98Xkjk9Y+YHQjJnYMz8UEjmjIyZHwnJnIkx82MhmTMzZn4iJHMWxsxPhWTOypj5mZDM2RgzPxeSOTtj5hdCMudgzPxSSOacjJlfCcmcizHzayGZczNmfiMkcx7GzG+FZM7LmPmdkMz5GDO/F5I5P2PmD0IyF2DM/FFI5oKMmT8JyVyIMfNnIZkLM2b+IiRzEcbMX4VkLsqY2SOkjMzFGDMHEJK5OGPmgEIyl2DMHEhI5pKMmQMLyVyKMXMQIZlLM2b2FJK5DGNmLyGZyzJmDiokcznGzMGEZC7PmDm4kMwVGDOHEJK5ImPmkEIyV2LMHEpI5sqMmUMLyVyFMXMYIZmrMmYOKyRzNcbM4YRkrs6YObyQzDUYM0cQkrkmY+aIQjLXYswcSUjm2oyZIwvJXIcxcxQhmesyZo4qJHM9xszRhGSuz5g5upDMDRgzxxCSuSFj5phCMv/GmDmWkMy/M2aOLSTzH4yZ4wjJ/Cdj5rhCMv/FmDmekMyNGDPHF5K5MWPmBEIyN2HMnFBI5qaMmRMJydyMMXNiIZmbM2ZOIiRzC8bMSYVkbsmYOZmQzK0YMycXkrk1Y+YUQjK3YcycUkjmtoyZUwnJ3I4xc2ohmdszZk4jJHMHxsxGSOaOjJmtkMydGDOnFZK5M2PmdEIyd2HMnF5I5q6MmTMIydyNMXNGIZm7M2bOJCRzD8bMmYVk7smYOYuQzL0YM2cVkrk3Y+ZsQjL3YcycXUjmvoyZcwjJ3I8xc04hmfszZs4lJPMAxsy5hWQeyJg5j5DMgxgz5xWSeTBj5nxCMg9hzJxfSOahjJkLMGeuG/D/cgf4lj0QCAzw2B6ewAsEBcFAcBAC4DE8QoHQIAwIC8KB8CACiAgigcggCogKooHoIAaICWKB2CAOiAvigfggAUgIEoHEIAlICpKB5CAFSAlSgdQgjeP3AliQ1vF7DNKDDCAjyAQygywgK8gGsoMcICfI9a3rPCAvyAfygwKgICgECoMioCgoBoqDEqAkKAVKgzKgLCgHyoMKoCKoBCqDKqAqqAaqgxqgJqgFaoM6jj5APVAfNAANwW/gd/AH+BP8BRqBxqAJaAqageagBWgJWoHWoA1oC9qB9qAD6Ag6gc6gC+gKuoHuoAfoCXqB3qAP6Av6gf5gABgIBoHBYAgYCoaB4WAEGAlGgdFgDBgLxoHxYIKHh8dEMAlMBlPAVDANTAczwEwwC8wGc8BcMA/MBwvAQrAILAZLwFKwDCwHK8BKsAqsBmvAWrAOrAcbwEawCWwGW8BWsA1sBzvATrAL7AZ7wF6wD+wHB8BBcAgcBkfAUXAMHAcnwElwCpwGZ8BZcA6cBxfARXAJXAZXwFVwDVwHN8BNcAvcBnfAXXAP3AcPwEPwCDwGT8BT8Aw8By/AS/AKvAZvwFvwDrwHH8BH8Al8Bl/AV+D44A8AAoJAIDAIAjyBFwgKgoHgIAQICUKB0CAMCAvCgfAgAogIIoHIIAqICqKB6CAGiAligdggDogL4oH4IAFICBKBxCAJSAqSgeQgBUgJUoHUIA0wwIK0IB1IDzKAjCATyAyygKwgG8gOcoCcIBfIDfKAvCAfyA8KgIKgECgMioCioBgoDkqAkqAUKA3KgLKgHCgPKoCKoBKoDKqAqqAaqA5qgJqgFqgN6oC6oB6oDxqAhuA38Dv4A/wJ/gKNQGPQBDQFzUBz0AK0BK1Aa9AGtAXtQHvQAXQEnUBn0AV0Bd1Ad9AD9AS9QG/QB/QF/UB/MAAMBIPAYDAEDAXDwHAwAowEo8BoMAaMBePAeDABTASTwGQwBUwF08B0MAPMBLPAbDAHzAXzwHywACwEi8BisAQsBcvAcrACrASrwGqwBqwF68B6sAFsBJvAZrAFbAXbwHawA+wEu8BusAfsBfvAfnAAHASHwGFwBBwFx8BxcAKcBKfAaXAGnAXnwHlwAVwEl8BlcAVcBdfAdXAD3AS3wG1wB9wF98B98AA8BI/AY/AEPAXPwHPwArwEr8Br8Aa8Be/Ae/ABfASfwGfwBXwFjk/8AUBAEAgEBkGAJ/ACQUEwEByEACFBKBAahAFhQTgQHkQAEUEkEBlEAVFBNBAdxAAxQSwQG8QBcUE8EB8kAAlBIpAYJAFJQTKQHKQAKUEqkBqkAQZYkBakA+lBBpARZAKZQRaQFWQD2UEOkBPkArlBHpAX5AP5QQFQEBQChUERUBQUA8VBCVASlAKlQRlQFpQD5UEFUBFUApVBFVAVVAPVQQ1QE9QCtUGdH96LpQ70n18d78/qgfqgAWgIfgO/gz/An+Av0Ag0Bk1AU9AMNActQEvQCrQGbUBb0A60Bx1AR9AJdAZdQFfQDXQHPUBP0Av0Bn1AX9AP9AcDwEAwCAwGQ8BQMAwMByPASDAKjAZjwFgwDowHE8BEMAlMBlPAVDANTAczwEwwC8wGc8BcMA/MBwvAQrAILAZLwFKwDCwHK8BKsAqsBmvAWrAOrAcbwEawCWwGW8BWsA1sBzvATrAL7AZ7wF6wD+wHB8BBcAgcBkfAUXAMHAcnwElwCpwGZ8BZcA6cBxfARXAJXAZXwFVwDVwHN8BNcAvcBnfAXXAP3AcPwEPwCDwGT8BT8Aw8By/AS/AKvAZvwFvwDrwHH8BH8Al8Bl/AV+A4BAQAAUEgEBgEAZ7ACwQFwUBwEAKEBKFAaBAGhAXhQHgQAUQEkUBkEAVEBdFAdBADxASxQGwQB8QF8UB8kAAkBIlAYpAEJAXJQHKQAqQEqQL95+MmDTDAgrQgHUgPMoCMIBPIDLKArCAbyA5ygJwgF8gN8oC8IB/IDwqAgqAQKAyKgKKgGCgOSoCSoBQoDcqAsqAcKA8qgIqgEqgMqoCqoBqoDmqAmqAWqA3qgLqgHqgPGoCG4DfwO/gD/An+Ao1AY9AENAXNQHPQArQErUBr0Aa0Be1Ae9ABdASdQGfQBXQF3UB30AP0BL1Ab9AH9AX9QH8wAAwEg8BgMAQMBcPAcDACjASjwGgwBowF48B4MAFMBJPAZDAFTAXTwHQwA8wEs8BsMAfMBfPAfLAALASLwGKwBCwFy8BysAKsBKvAarAGrAXrwHqwAWwEm8BmsAVsBdvAdrAD7AS7wG6wB+wF+8B+cAAcBIfAYXAEHAXHwHFwApwEp8BpcAacBefAeXABXASXwGVwBVwF18B1cAPcBLfAbXAH3AX3wH3wADwEj8Bj8AQ8Bc/Ac/ACvASvwGvwBrwF78B78AF8BJ/AZ/AFfAWOC4AAICAIBAKDIMATeIGgIBgIDkKAkCAUCA3CgLAgHAgPIoCIIBKIDKKAqCAaiA5igJggFogN4oC4IB6IDxKAhCARSAySgKQgGUgOUoCUIBVIDdIAAyxIC9KB9CADyAgygcwgC8gKsoHsIAfICXKB3CAPyAvygfygACgICoHCoAgoCoqB4qAEKAlKgdKgDCgLyoHyoAKoCCqByqAKqAqqgeqgBqgJaoHaoA6oC+qB+qABaAh+A7+DP8Cf4C/QCDQGTUBT0Aw0By1AS9AKtAZtQFvQDrQHHUBH0Al0Bl1AV9ANdAc9QE/QC/QGfUBf0A/0BwPAQDAIDAZDwFAwDAwHI8BIMAqMBmPAWDAOjAcTwEQwCUwGU8BUMA1MBzPATDALzAZzwFwwD8wHC8BCsAgsBkvAUrAMLAcrwEqwCqwGa8BasA6sBxvARrAJbAZbwFawDWwHO8BOsAvsBnvAXrAP7AcHwEFwCBwGR8BRcAwcByfASXAKnAZnwFlwDpwHF8BFcAlcBlfAVXANXAc3wE1wC9wGd8BdcA/cBw/AQ/AIPAZPwFPwDDwHL8BL8Aq8Bm/AW/AOvAcfwEfwCXwGX8BX4Lj8CwACgkAgMAgCPIEXCAqCgeAgBAgJQoHQIAwIC8KB8CACiAgigcggCogKooHoIAaICWKB2CAOiAscPw/e8fPRHT8v3PHzsx0/T9rx85UdP2/Y8fN3HT+P1vHzWR0/r9Tx8zsdP8/S8fMdHT/v0PHz/xw/D8/x8+EcPy/N8fPDHD9Py/HzpRw/b8nx84ccP4/H8fNpHD+vxfHzSxw/z8Px8y3+/nkPwPHzABzfH9/x/eId3z/d8f3EHd9f2/H9ph3ff9nx/Ygd35/X8f1qHd+/1fH9TB3f39Px/S4d3//R8f0QHd8f0PH98hzfP87x/dQc31/M8f22HN9/yvH9mBzfn8jx/Xoc37/G8f1cHN/fxPH9Phzf/8Lx/SAc3x/B8f0CHH9/3vH3yR1/v9rx940df//W8fdRHX8/0/H3FR1/f8/x99kcf7/L8fedHH//x/H3YRx/P8Tx9yUcf3/Asad37Msde2vH/tixx3XsUx17Tcd+0bHnc+zbHHsvx/7JsQdy7GMcexHHfsKxJ3B8fd3x9WbH118dX490fH3O8fUqx9dvHF/PcNzvO+67v78CfPs13Ldfg337NcgP/7nj003ub/+3cfP13d/Tf/ztd38v//FP5+Xxz9eP2vfft0A//PO9/15/f6Zg3n7PmZ+1TgDi+QJ5+2d6f8Yf/zuBPf75Cujt/w7sTQ/kxH/X+z/vx/8sLPF83v//ghHP+qP2/d+tUB7/fHnvJei3X4P44OX1w3/+43/fy9t/1786jEA80/dn//8AsV/4dK+XCwA=","debug_symbols":"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","file_map":{"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"64":{"source":"use super::defaults::{BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK};\n\nuse crate::tables::{\n    BASE64_ENCODE_BE_TABLE, BASE64_ENCODE_BE_VAR_TABLE, BASE64URL_ENCODE_BE_TABLE,\n    BASE64URL_ENCODE_BE_VAR_TABLE,\n};\n\npub use crate::boundary_check::boundary_check;\n\nglobal CONVERT_MODULO3_TO_PADDING_BYTES: [u32; 3] = [0, 2, 1];\nglobal PAD_1: [Field; 3] = [0, 1, 1];\nglobal PAD_2: [Field; 3] = [0, 1, 0];\n\n// Encoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64EncodeBE {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * 3) + (((InputBytes % 3) / 2) * 2)] {\n        crate::encoder::encode::<InputBytes, 0, 1>(input)\n    }\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * 3) + (((MAX_INPUT_LEN % 3) / 2) * 2)> {\n        crate::encoder::encode_var::<_, 0, 1>(input)\n    }\n}\n\n// Encoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64EncodeBENoPad {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2)) + (((InputBytes % 3) / 2))] {\n        crate::encoder::encode::<InputBytes, 0, 0>(input)\n    }\n\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, (((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2)) + (((MAX_INPUT_LEN % 3) / 2)))> {\n        crate::encoder::encode_var::<_, 0, 0>(input)\n    }\n}\n\n// Encoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64EncodeBEUrlSafe {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2)) + (((InputBytes % 3) / 2))] {\n        crate::encoder::encode::<_, 1, 0>(input)\n    }\n\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, (((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2)) + (((MAX_INPUT_LEN % 3) / 2)))> {\n        crate::encoder::encode_var::<_, 1, 0>(input)\n    }\n}\n\n// Encoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64EncodeBEUrlSafeWithPad {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * 3) + (((InputBytes % 3) / 2) * 2)] {\n        crate::encoder::encode::<_, 1, 1>(input)\n    }\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * 3) + (((MAX_INPUT_LEN % 3) / 2) * 2)> {\n        crate::encoder::encode_var::<_, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Take an array of ASCII values and convert into base64 values\n * @tparam InputElements: The size of the array being encoded\n * @tparam UseUrlTable: are we encoding using the URL and Filename Safe Alphabet, or standard Base64 Alphabet? \n **/\nfn encode_elements<let InputElements: u32, let UseUrlTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; InputElements] {\n    let mut result: [u8; InputElements] = [0; InputElements];\n\n    for i in 0..InputElements {\n        let token: u8 = if UseUrlTable == 1 {\n            BASE64URL_ENCODE_BE_TABLE[input[i]]\n        } else {\n            BASE64_ENCODE_BE_TABLE[input[i]]\n        };\n        result[i] = token as u8;\n    }\n\n    result\n}\n\n/**\n * @brief Encode a variable-length ASCII string into Base64 values\n **/\nfn encode_var<let MAX_INPUT_LEN: u32, let UseURLTable: u1, let HasPadding: u32>(\n    input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))> {\n    assert((HasPadding == 0) | (HasPadding == 1), \"invalid HasPadding parameter\");\n    // The max number of output Base64 values can be derived from the max input size\n    let mut result_arr: [u8; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] = [\n        0; ((MAX_INPUT_LEN * 8) / 6)\n            + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2))\n            + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))\n    ];\n\n    // Note: is this correct?\n    let output_length = ((MAX_INPUT_LEN * 8) / 6)\n        + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2))\n        + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding));\n\n    // Step 1: convert the input into six-bit chunks. We can map each chunk into Base64 values.\n    let raw: [u8; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] =\n        crate::encoder::split_into_six_bit_chunks::<_, _, 1>(input.storage());\n\n    let real_length = input.len();\n    // The input length modulo 3 can be used to determine the number of padding bytes\n    let real_length_mod_3 = if HasPadding == 1 { real_length % 3 } else { 0 };\n    // encoded_length = the number of Base64 values minus padding\n    let encoded_length = ((real_length * 8) + 5) / 6;\n    let final_length = encoded_length\n        + if HasPadding == 1 {\n            CONVERT_MODULO3_TO_PADDING_BYTES[real_length_mod_3]\n        } else {\n            0\n        };\n\n    // Get an array of Field elements where boundary_flags[i] = 0 if i < encoded_length, otherwise i = 1.\n    // We use this array to determine if the result array should contain a valid Base64 encoded value, 0 or if an error state has been reached\n    let boundary_flags: [Field; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] =\n        boundary_check(encoded_length);\n\n    // Using 2 lookups is slightly cheaper than figuring out if the 1st/2nd padding byte is set from the padding length param... I think?\n    let has_first_padding_byte = if HasPadding == 1 {\n        PAD_1[real_length_mod_3]\n    } else {\n        0\n    };\n    let has_second_padding_byte = if HasPadding == 1 {\n        PAD_2[real_length_mod_3]\n    } else {\n        0\n    };\n\n    // If we have actual data to iterate through, populate the 1st result entry with the base64 encoding of `raw[0]`.\n    // Note: if `boundary_flags[0] = 1`, the `BASE64_ENCODE_BE_VAR_TABLE` lookup will output 0.\n    // Note: `MAX_INPUT_LEN` is known at compile time so this `if` statement should not incur constraints.\n    if MAX_INPUT_LEN > 0 {\n        result_arr[0] = BASE64_ENCODE_BE_VAR_TABLE[raw[0] as Field + boundary_flags[0] * 64] as u8;\n    }\n\n    let mut previous_was_first_padding_byte = 0;\n    for i in 1..output_length {\n        let exceed_length = boundary_flags[i];\n        // hit_limit = we are at the first location where a padding Base64 character *could* be enerated\n\n        let mut encoding_index: Field = 0;\n\n        if HasPadding == 1 {\n            let hit_limit: Field = (1 - boundary_flags[i - 1]) * boundary_flags[i];\n            // We need to write a padding byte if `i == encoding_length` and `has_first_padding_byte == 1`\n            let write_first_padding_byte: Field = hit_limit * has_first_padding_byte;\n            // We need to write a padding byte if `i == encoding_length + 1` and `has_second_padding_byte == 1`\n            let write_second_padding_byte =\n                previous_was_first_padding_byte * has_second_padding_byte;\n\n            // Look up the encoded Base64 value given an input 6-bit chunk.\n            // We have 2 edge cases that we need to handle efficiently (writing padding bytes or we have exceeded the input length)\n            // Instead of expensive conditional logic we apply lookup tables as a quasi state machine to handle these edge cases.\n            // CASE 1: `exceed_length = 0`, `write_first_padding_byte = 0`, `write_second_padding_byte = 0`\n            //      outcome: we map the 6-bit input value into a Base64 encoding\n            // CASE 2: `exceed_length = 1` AND `write_first_padding_byte = 0` AND `write_second_padding_byte = 0`\n            //      outcome: if `raw[i] = 0`, the returned value is 0. All other inputs for `raw[i]` return an error state\n            // CASE 3: `exceed_length = 1` AND ()`write_first_padding_byte = 1` OR `write_second_padding_byte = 1`)\n            //      outcome: if `raw[i] = 0`, the returned value is BASE64_PADDING_CHAR. All other inputs for `raw[i]` return an error state\n            // Note: due to how they are constructed, it is not possible for both `write_first_padding_byte` and `write_second_padding_byte` to equal 1.\n            //       Similarly, it is not possible for `exceed_length = 0` and either of `write_first_padding_byte` or `write_second_padding_byte` to equal 1.\n            encoding_index = raw[i] as Field\n                + (exceed_length + write_first_padding_byte + write_second_padding_byte) * 64;\n            previous_was_first_padding_byte = write_first_padding_byte;\n        } else {\n            // We have 2 edge cases that we need to handle efficiently (writing padding bytes or we have exceeded the input length)\n            // Instead of expensive conditional logic we apply lookup tables as a quasi state machine to handle these edge cases.\n            // CASE 1: `exceed_length = 0`\n            //      outcome: we map the 6-bit input value into a Base64 encoding\n            // CASE 2: `exceed_length = 1`\n            //      outcome: if `raw[i] = 0`, the returned value is 0. All other inputs for `raw[i]` return an error state\n\n            encoding_index = raw[i] as Field + (exceed_length * 64);\n        }\n\n        // Note: this `if` condition is known at compile time so should not incur additional constraints\n        let token: u8 = if UseURLTable == 1 {\n            BASE64_ENCODE_BE_VAR_TABLE[encoding_index]\n        } else {\n            BASE64URL_ENCODE_BE_VAR_TABLE[encoding_index]\n        };\n        (token as Field).assert_max_bit_size::<7>();\n        result_arr[i] = token;\n    }\n\n    // we can use `from_parts_unchecked` here because the table BASE64_ENCODE_BE_VAR_TABLE (and it's URL equivalent)\n    // will produce an error if a nonzero input is given past `final_length`\n    let mut r: BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))> =\n        BoundedVec::from_parts_unchecked(result_arr, final_length);\n\n    r\n}\n\n/**\n * @brief Take an array of ASCII bytes and convert into an array of six-bit chunks\n **/\nfn split_into_six_bit_chunks<let InputBytes: u32, let OutputElements: u32, let HasPadding: u32>(\n    input: [u8; InputBytes],\n) -> [u8; OutputElements] {\n    // Calculate the number of padding characters and the length of the output without padding\n\n    // input bytes modulo 3 . e.g.\n\n    // input = 5 implies 1 padding char = 40 bits of data = 6 base64 vals + 2 bits\n    // 1 is padding so we have 5 base64 vals\n    let rem = InputBytes % 3;\n    let num_padding_chars = if HasPadding == 1 {\n        if rem == 1 {\n            2\n        } else if rem == 2 {\n            1\n        } else {\n            0\n        }\n    } else {\n        0\n    };\n\n    let mut result: [u8; OutputElements] = [0; OutputElements];\n\n    let num_chunks = (InputBytes / BYTES_PER_CHUNK) + (InputBytes % BYTES_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            // pack the bytes into the field element\n            let mut slice: Field = 0;\n            for j in 0..BYTES_PER_CHUNK {\n                slice *= 256;\n                slice += input[i * BYTES_PER_CHUNK + j] as Field;\n            }\n            // extract the 6-bit values from the Field element\n            let slice_base64_chunks: [u8; BASE64_ELEMENTS_PER_CHUNK] = slice.to_be_radix(64);\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                result[i * BASE64_ELEMENTS_PER_CHUNK + j] = slice_base64_chunks[j];\n            }\n        }\n\n        // process the final chunk, which may require padding\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_offset = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let bytes_in_final_chunk = InputBytes - byte_offset;\n        let num_elements_in_final_chunk = OutputElements - base64_offset;\n\n        // pack the bytes into the field element\n        let mut slice: Field = 0;\n        for j in 0..bytes_in_final_chunk {\n            slice *= 256;\n            slice += input[(num_chunks - 1) * BYTES_PER_CHUNK + j] as Field;\n        }\n        for _ in bytes_in_final_chunk..BYTES_PER_CHUNK {\n            slice *= 256;\n        }\n\n        // extract the 6-bit values from the Field element\n        let slice_base64_chunks: [u8; BASE64_ELEMENTS_PER_CHUNK] = slice.to_be_radix(64);\n        for i in 0..num_elements_in_final_chunk {\n            // If padding is enabled, we can skip setting the last `non_padded_output_length` chars\n            // N.B. if statement is compile time so shouldn't add c onstraints\n            if HasPadding == 1 {\n                let non_padded_output_length = OutputElements - num_padding_chars;\n                if (base64_offset + i < non_padded_output_length) {\n                    result[base64_offset + i] = slice_base64_chunks[i];\n                }\n            } else {\n                result[base64_offset + i] = slice_base64_chunks[i];\n            }\n        }\n    }\n\n    result\n}\n\nfn encode<let InputBytes: u32, let UseUrlTable: u1, let UsePadding: u32>(\n    input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * (1 + UsePadding * 2)) + (((InputBytes % 3) / 2) * (1 + UsePadding))] {\n    assert((UsePadding == 0 as u32) | (UsePadding == 1 as u32), \"UsePadding must be 0 or 1\");\n    let mut result = crate::encoder::encode_elements::<_, UseUrlTable>(\n        crate::encoder::split_into_six_bit_chunks::<_, _, UsePadding>(input),\n    );\n    // this relationship should be evaluated at compile time\n    let OutputElements = ((InputBytes * 8) / 6)\n        + (((InputBytes % 3) % 2) * (1 + UsePadding * 2))\n        + (((InputBytes % 3) / 2) * (1 + UsePadding));\n    if UsePadding == 1 {\n        // handle padding\n        let rem = InputBytes % 3;\n        if (rem == 1) {\n            result[OutputElements - 1] = BASE64_PADDING_CHAR;\n            result[OutputElements - 2] = BASE64_PADDING_CHAR;\n        } else if (rem == 2) {\n            result[OutputElements - 1] = BASE64_PADDING_CHAR;\n        }\n    }\n    result\n}\n\n// === TESTS ======================================================================================\n\n#[test]\nfn test_encode_elements() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII (with the = padding character stripped)\n    let ascii_expected: [u8; 43] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85,\n    ];\n\n    let input: [u8; 43] = [\n        6, 49, 12, 37, 32, 48, 11, 34, 50, 41, 39, 21, 43, 4, 54, 2, 52, 18, 31, 56, 50, 51, 33, 28,\n        22, 19, 36, 0, 33, 18, 25, 57, 62, 22, 4, 17, 33, 10, 33, 23, 45, 37, 20,\n    ];\n\n    let ascii_result = crate::encoder::encode_elements::<_, 0>(input);\n\n    assert(ascii_result == ascii_expected);\n}\n\n#[test]\nfn test_encode_empty() {\n    let input: [u8; 0] = [];\n    let result = Base64EncodeBE::encode(input);\n    let expected: [u8; 0] = [];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_padding() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 4] = [90, 103, 61, 61];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 4] = [90, 109, 56, 61];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_standard_no_pad() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 2] = [90, 103];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 3] = [90, 109, 56];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_max_byte() {\n    let input: [u8; 1] = [255];\n\n    let result: [u8; 4] = Base64EncodeBE::encode(input);\n    let expected: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    assert(result == expected);\n\n    let result: [u8; 2] = Base64EncodeBENoPad::encode(input);\n    let expected: [u8; 2] = [47, 119]; // \"/w\"\n    assert(result == expected);\n\n    let result: [u8; 4] = Base64EncodeBEUrlSafeWithPad::encode(input);\n    let expected: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    assert(result == expected);\n\n    let result: [u8; 2] = Base64EncodeBEUrlSafe::encode(input);\n    let expected: [u8; 2] = [95, 119]; // \"_w\"\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_ascii() {\n    // \"Hello World!\"\n    let input: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n    // base64: SGVsbG8gV29ybGQh\n    let expected: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_utf8() {\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let input: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let expected: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let input: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let expected: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n\n    let expected: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_standard() {\n    // test encoding to / and +\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 4] = [47, 43, 65, 61];\n    let result: [u8; 4] = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_url_safe_with_pad() {\n    // test encoding to _ and -\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 4] = [95, 45, 65, 61];\n    let result: [u8; 4] = Base64EncodeBEUrlSafeWithPad::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_url_safe() {\n    // test encoding to _ and -\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 3] = [95, 45, 65];\n    let result: [u8; 3] = Base64EncodeBEUrlSafe::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU\n    // Translated directly to ASCII (with padding byte character stripped)\n    let expected: [u8; 43] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85,\n    ];\n\n    let input: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_base64_encode_slash() {\n    let input: [u8; 1] = [63]; // '/' in Base64\n    let result: [u8; 1] = crate::encoder::encode_elements::<_, 0>(input);\n\n    // Should map to '/' in ASCII, which is 47\n    assert(result[0] == 47);\n}\n\n#[test]\nfn test_encode_var_empty() {\n    let input: BoundedVec<u8, 3> = BoundedVec::new();\n    let result = Base64EncodeBE::encode_var(input);\n    let expected: BoundedVec<u8, 4> = BoundedVec::new();\n    assert(result == expected);\n\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64EncodeBE::encode_var(input);\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var() {\n    // \"Hello, World!\"\n    let input: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let expected: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let expected_no_pad: BoundedVec<u8, 22> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode_var(input);\n    println(f\"result = {result}\");\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode_var(input);\n    assert(result == expected_no_pad);\n    let result = Base64EncodeBEUrlSafeWithPad::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafe::encode_var(input);\n    assert(result == expected_no_pad);\n}\n\n#[test]\nfn test_encode_var_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let input: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let expected: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let expected_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode_var(input);\n    assert(result == expected_no_pad);\n    let result = Base64EncodeBEUrlSafeWithPad::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafe::encode_var(input);\n    assert(result == expected_no_pad);\n}\n","path":"/Users/zac/noir_base64/src/encoder.nr"},"67":{"source":"use crate::decoder::{Base64DecodeBE, Base64DecodeBENoPad};\nuse crate::encoder::{Base64EncodeBE, Base64EncodeBENoPad, Base64EncodeBEUrlSafe};\n\n#[export]\nfn bench_encode_610(input: [u8; 610]) -> [u8; 816] {\n    Base64EncodeBE::encode(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBEUrlSafe::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 816> {\n    Base64EncodeBE::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBEUrlSafe::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_no_pad(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBENoPad::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var_no_pad(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBENoPad::encode_var(input)\n}\n\n#[export]\nfn bench_decode_610(input: [u8; 816]) -> [u8; 610] {\n    (Base64DecodeBE::decode(input))\n}\n\n#[export]\nfn bench_decode_610_var(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBE::decode_var(input));\n    r\n}\n\n#[export]\nfn bench_decode_610_no_pad(input: [[u8; 816]; 3]) -> [[u8; 610]; 3] {\n    let mut r: [[u8; 610]; 3] = [[0; 610]; 3];\n    for i in 0..3 {\n        r[i] = (Base64DecodeBENoPad::decode(input[i]));\n    }\n    r\n}\n\n#[export]\nfn bench_decode_610_var_no_pad(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBENoPad::decode_var(input));\n    r\n}\n\n","path":"/Users/zac/noir_base64/src/benchmarks/mod.nr"}},"names":["bench_encode_610_url_safe"],"brillig_names":["directive_to_radix"]}