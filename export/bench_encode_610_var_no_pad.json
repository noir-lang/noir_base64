{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":13300543175641160235,"abi":{"parameters":[{"name":"input","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":610,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":814,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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Zd8rLfOOVCWWfa+0zDtSlVz2vdIy70hVgtn3Ssu8I1VJZt8rLfOOVCWafa+0zDtSlWz2vdIy70hVwtn3Ssu8I1VJZ98rLfOOVCWefa+0zDtSlXz2vdIy70hVAtr3Ssu8I1VJaN8rLfOOVCWifa+0zDtSlYz2vdIy70hVQtr3Ssu8I1VJad8rLfOOVCWmfa+0zDtSlZz2vdIy70hVgtr3Ssu8I1VJat8rLfOOVCWqfa+0zDtSlaz2vdIy70hVwtr3Ssu8I1VJa98rLfOOVCWufa+0zDtSlbz2vdIy70hVAtv3Ssu8I1VJbN8rLfOOVCWyfa+0zDtSlcz2vdIq70itTGe7lelstzKd7Vams92eXuZKq7wjtTKd7Vams93KdLZbmc52K9PZbmU6261MZ7uV6Wy3Mp3tVqaz3cp0tluZznYr09luZTrbrUxnu5XpbLcyne1WprPdynS2W5nOdivT2W5lOtutTGe7lelstzKd7Vams93KdLZbmc52K9PZbmU6261MZ7uV6Wy3Mp3tVqaz3cp0tluZznYr09luZTrbrUxnu5XpbLcyne1WprPdynS2W5nOdivT2W5lOtutTGe7lelstzKd7Vams93KdLZbmc52K9PZbmU6261MZ7uV6Wy3Mp3tVqaz3cp0tluZznYr09luZTrbrUxnu5XpbLcyne1WprPdynS2W5nOdivT2W5lOtutTGe7lelstzKd7Vams93KdLZbmc52K9PZbmU6261MZ7uV6Wy3Mp3tVqaz3cp0tluZznYr09luZTrbrUxnu5XpbLcyne1WprPdynS2W5nOdivT2W5lOttRprMdZTrbUaazHWU62/H0Mlda5R0pynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvKdLajTGc7ynS2o0xnO8p0tqNMZzvLdLazTGc7y3S2s0xnO59e5kqrvCNlmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbGeZznaW6Wxnmc52lulsZ5nOdpbpbPcyne1eprPdy3S2e5nOdn96mSut8o7Uy3S2e5nOdi/T2e5lOtu9TGe7l+ls9zKd7V6ms93LdLZ7mc52L9PZ7mU6271MZ7uX6Wz3Mp3tXqaz3ct0tnuZznYv09nuZTrbvUxnu5fpbPcyne1eprPdy3S2e5nOdi/T2e5lOtu9TGe7l+ls9zKd7V6ms93LdLZ7mc52L9PZ7mU6271MZ7uX6Wz3Mp3tXqaz3ct0tnuZznYv09nuZTrbvUxnu5M72xntz//qjOz/l1cKfkf68JWC35E+fKW9zJWC35E+fKXgd6QPXyn4HenDVwp+R/rwlYLfkT57peTO9oevtMw7Ermz/eErLfOORO5sf/hKy7wjkTvbH77SMu9I5M72h6+0zDsSubP94Sst845E7mx/+ErLvCORO9sfvtIy70jkzvaHr7TMOxK5s/3hKy3zjkTubH/4Ssu8I5E72x++0jLvSOTO9oevtMw7Ermz/eErLfOORO5sf/hKy7wjkTvbH77SMu9I5M72h6/0u+9IY/78Lx5jjb/+h//3aTrqNN991xjj/Pk0+/nb00zUadaXT7P/cpq/c6c26jQHdJrx5caxOk1DnSZQp/nqb/FsO//0D89oKZ46z/7zv7m1v/o5GH86eucefY/x53/zir89+gAf/fz533za/tujT+zR4xn9T/9wXHb+9ujLF5jtC8yxBea7GdqPAvPdruxHgfluKPazwICfpgoY8tNUAMN9mkpguE9TCQz5aSqA4T5NJTDcp6kCJshP03dggvs0VcAE92kqgSE/TQUw3KepBIb8bSqAIT9NBTDcp6kEhvxtKoAhP03fgUnu01QBk+Rv03dgkvw0FcBwn6YSGO7TVALja3rT1/Smr+lNX9Obvqa3+5re7mt6u6/p7b6m97shwc8C42t6u6/p7b6mt/ua3u5reoev6R2+pnf4mt7ha3q/m5z7LDC+pnf4mt7ha3qHr+kdvqZ3+pre6Wt6p6/pnb6m97txss8C42t6p6/pnb6md/qa3ulrepev6V2+pnf5mt7la3q/m7H6LDC+pnf5mt7la3qXr+ldvqZ3+5re7Wt6t6/p3b6m97vBo88C42t6t6/p3b6md/ua3u1reo+v6T2+pvf4mt7ja3q/m935LDC+pvf4mt7ja3qPr+k9tqZ3Pramdz62pnc+tqZ3kltIChjy01QAY2t6J7iFJIGxNb0T3EKSwNia3oluIb0DA24hKWDALSQJjK3pneAWkgTG1vROdAtJAGNreie4hSSBsTW9E9xCUsCAW0gKGHQLSQBja3onuIUkgbE1vRPcQpLA2JreiW4hCWB8TS+4haSAQbeQ3oEBt5AkML6mF91CEsD4ml5wC0kC42t6wS0kCYyv6UW3kN6BAbeQFDDgFpIExtf0gltIEhhf04tuIQlgfE0vuIUkgfE1veAWkgIG3EJSwKBbSAIYX9MLbiFJYHxNL7iFJIHxNb3oFpIAxtf0gltIChh0C+kdGHALSQLja3rRLSQBjK/pBbeQJDC+phfcQpLA+JpedAvpHRhwC0kBA24hSWB8TS+4hSSB8TW96BaSAMbX9IJbSBIYX9MLbiEpYMAtJAUMuoUkgPE1veAWkgTG1/SCW0gSGF/Ti24hCWB8TS+4haSAQbeQ3oEBt5AkML6mF91CEsD4ml5wC0kC42t6wS0kCYyt6V3oFtIrMAvcQhLALHALSQJja3rXw32aSmBsTe9Ct5AEMLamd4FbSBIYW9O7wC0kBQy4haSAQbeQBDC2pneBW0gSGFvTu8AtJAmMreld6BaSAMbW9C5wC0kBg24hvQMDbiFJYGxN70K3kAQwtqZ3gVtIEhhb07vALSQJjK/pRbeQ3oEBt5AUMOAWkgTG1/SCW0gSGF/Ti24hCWB8TS+4hSSB8TW94BaSAgbcQlLAoFtIAhhf0wtuIUlgfE0vuIUkgfE1vegWkgDG1/SCW0gKGHQL6R0YcAtJAuNretEtJAGMr+kFt5AkML6mF9xCksD4ml50C+kdGHALSQEDbiFJYHxNL7iFJIHxNb3oFpIAxtf0gltIEhhf0wtuISlgwC0kBQy6hSSA8TW94BaSBMbX9IJbSBIYX9OLbiEJYHxNL7iFpIBBt5DegQG3kCQwvqYX3UISwPiaXnALSQLja3rBLSQJjK/pRbeQ3oEBt5AUMOAWkgTG1/SCW0gSGF/Ti24hCWB8TS+4hSSBsTW9G9xCEsBscAtJALPRLSQBjK3p3Q/3aSqBsTW9G9xCksDYmt6NbiEJYGxN7wa3kBQw6BbSOzDgFpIExtb0bnQLSQBja3o3uIUkgbE1vRvcQpLA2JrejW4hvQMDbiEpYMAtJAmMrend4BaSBMbW9G50C0kAY2t6N7iFJIHxNb3gFpICBtxCUsCgW0gCGF/TC24hSWB8TS+4hSSB8TW96BaSAMbX9IJbSAoYdAvpHRhwC0kC42t60S0kAYyv6QW3kCQwvqYX3EKSwPiaXnQL6R0YcAtJAQNuIUlgfE0vuIUkgfE1vegWkgDG1/SCW0gSGF/TC24hKWDALSQFDLqFJIDxNb3gFpIExtf0gltIEhhf04tuIQlgfE0vuIWkgEG3kN6BAbeQJDC+phfdQhLA+JpecAtJAuNresEtJAmMr+lFt5DegQG3kBQw4BaSBMbX9IJbSBIYX9OLbiEJYHxNL7iFJIHxNb3gFpICBtxCUsCgW0gCGF/TC24hSWB8TS+4hSSB8TW96BaSAMbW9B5wC0kAc9AtpFdgDriFJIGxNb3nIT9NBTC2pveAW0gSGFvTe8AtJAmMrek96BbSOzDgFpICBtxCksDYmt4DbiFJYGxN70G3kAQwtqb3gFtIEhhb03vALSQFDLiFpIBBt5AEMLam94BbSBIYW9N7wC0kCYyt6T3oFpIAxtf0gltIChh0C+kdGHALSQLja3rRLSQBjK/pBbeQJDC+phfcQpLA+JpedAvpHRhwC0kBA24hSWB8TS+4hSSB8TW96BaSAMbX9IJbSBIYX9MLbiEpYMAtJAUMuoUkgPE1veAWkgTG1/SCW0gSGF/Ti24hCWB8TS+4haSAQbeQ3oEBt5AkML6mF91CEsD4ml5wC0kC42t6wS0kCYyv6UW3kN6BAbeQFDDgFpIExtf0gltIEhhf04tuIQlgfE0vuIUkgfE1veAWkgIG3EJSwKBbSAIYX9MLbiFJYHxNL7iFJIHxNb3oFpIAxtf0gltIChh0C+kdGHALSQLja3rRLSQBjK/pBbeQJDC+phfcQpLAuJreeNAtpDdg7tFdTe89uqvpvUd3Nb336NynqQTG1fTeo7ua3nt0V9N7j+5qeu/RXU1vPOAWkgIG3EJSwKBbSAIYV9N7j859mkpgXE3vPbqr6b1HdzW99+iupvce3dX0xgNuISlg0C2kd2DALSQJjKvpvUcnP00FMK6m9x7d1fTeo7ua3nt0V9N7j+5retEtpHdgwC0kBQy4hSSB8TW94BaSBMbX9KJbSAIYX9MLbiFJYHxNL7iFpIABt5AUMOgWkgDG1/SCW0gSGF/TC24hSWB8TS+6hSSA8TW94BaSAgbdQnoHBtxCksD4ml50C0kA42t6wS0kCYyv6QW3kCQwvqYX3UJ6BwbcQlLAgFtIEhhf0wtuIUlgfE0vuoUkgPE1veAWkgTG1/SCW0gKGHALSQGDbiEJYHxNL7iFJIHxNb3gFpIExtf0oltIAhhf0wtuISlg0C2kd2DALSQJjK/pRbeQBDC+phfcQpLA+JpecAtJAuNretEtpHdgwC0kBQy4hSSB8TW94BaSBMbX9KJbSAIYX9MLbiFJYGxNbwO3kAQwDdxCEsA0dAtJAGNretvDfZpKYGxNbwO3kCQwtqa3oVtIAhhb09vALSQFDLqF9A4MuIUkgbE1vQ3dQhLA2JreBm4hSWBsTW8Dt5AkMLamt6FbSO/AgFtIChhwC0kCY2t6G7iFJIGxNb0N3UISwNia3gZuIUlgfE0vuIWkgAG3kBQw6BaSAMbX9IJbSBIYX9MLbiFJYHxNL7qFJIDxNb3gFpICBt1CegcG3EKSwPiaXnQLSQDja3rBLSQJjK/pBbeQJDC+phfdQnoHBtxCUsCAW0gSGF/TC24hSWB8TS+6hSSA8TW94BaSBMbX9IJbSAoYcAtJAYNuIQlgfE0vuIUkgfE1veAWkgTG1/SiW0gCGF/TC24hKWDQLaR3YMAtJAmMr+lFt5AEML6mF9xCksD4ml5wC0kC42t60S2kd2DALSQFDLiFJIHxNb3gFpIExtf0oltIAhhf0wtuIUlgfE0vuIWkgAG3kBQw6BaSAMbX9IJbSBIYX9MLbiFJYHxNL7qFJICxNb0BbiEJYALdQnoFJsAtJAmMremNh/w0FcDYmt4At5AkMLamN8AtJAmMrekNdAvpHRhwC0kBA24hSWBsTW+AW0gSGFvTG+gWkgDG1vQGuIUkgbE1vQFuISlgwC0kBQy6hSSAsTW9AW4hSWBsTW+AW0gSGFvTG+gWkgDG1/SCW0gKGHQL6R0YcAtJAuNretEtJAGMr+kFt5AkML6mF9xCksD4ml50C+kdGHALSQEDbiFJYHxNL7iFJIHxNb3oFpIAxtf0gltIEhhf0wtuISlgwC0kBQy6hSSA8TW94BaSBMbX9IJbSBIYX9OLbiEJYHxNL7iFpIBBt5DegQG3kCQwvqYX3UISwPiaXnALSQLja3rBLSQJjK/pRbeQ3oEBt5AUMOAWkgTG1/SCW0gSGF/Ti24hCWB8TS+4hSSB8TW94BaSAgbcQlLAoFtIAhhf0wtuIUlgfE0vuIUkgfE1vegWkgDG1/SCW0gKGHQL6R0YcAtJAuNretEtJAGMr+kFt5AkML6mF9xCksDYmt5Et5BegUlwC0kAk+AWkgTG1vTmw32aSmBsTW+iW0gCGFvTm+AWkgTG1vQmuIWkgAG3kBQw6BaSAMbW9Ca4hSSBsTW9CW4hSWBsTW+iW0gCGFvTm+AWkgIG3UJ6BwbcQpLA2JreRLeQBDC2pjfBLSQJjK3pTXALSQLja3rRLaR3YMAtJAUMuIUkgfE1veAWkgTG1/SiW0gCGF/TC24hSWB8TS+4haSAAbeQFDDoFpIAxtf0gltIEhhf0wtuIUlgfE0vuoUkgPE1veAWkgIG3UJ6BwbcQpLA+JpedAtJAONresEtJAmMr+kFt5AkML6mF91CegcG3EJSwIBbSBIYX9MLbiFJYHxNL7qFJIDxNb3gFpIExtf0gltIChhwC0kBg24hCWB8TS+4hSSB8TW94BaSBMbX9KJbSAIYX9MLbiEpYNAtpHdgwC0kCYyv6UW3kAQwvqYX3EKSwPiaXnALSQLja3rRLaR3YMAtJAUMuIUkgfE1veAWkgTG1/SiW0gCGF/TC24hSWBsTW8Ht5AEMB3cQhLAdHQLSQBja3r7w32aSmBsTW8Ht5AkMLamt6NbSAIYW9PbwS0kBQy6hfQODLiFJIGxNb0d3UISwNia3g5uIUlgbE1vB7eQJDC2prejW0jvwIBbSAoYcAtJAmNreju4hSSBsTW9Hd1CEsDYmt4ObiFJYHxNL7iFpIABt5AUMOgWkgDG1/SCW0gSGF/TC24hSWB8TS+6hSSA8TW94BaSAgbdQnoHBtxCksD4ml50C0kA42t6wS0kCYyv6QW3kCQwvqYX3UJ6BwbcQlLAgFtIEhhf0wtuIUlgfE0vuoUkgPE1veAWkgTG1/SCW0gKGHALSQGDbiEJYHxNL7iFJIHxNb3gFpIExtf0oltIAhhf0wtuISlg0C2kd2DALSQJjK/pRbeQBDC+phfcQpLA+JpecAtJAuNretEtpHdgwC0kBQy4hSSB8TW94BaSBMbX9KJbSAIYX9MLbiFJYHxNL7iFpIABt5AUMOgWkgDG1/SCW0gSGF/TC24hSWB8TS+6hSSAsTW9A9xCEsAMdAvpFZgBbiFJYGxN73jIT1MBjK3pHeAWkgTG1vQOcAtJAmNrege6hfQODLiFpIABt5AkMLamd4BbSBIYW9M70C0kAYyt6R3gFpIExtb0DnALSQEDbiEpYNAtJAGMrekd4BaSBMbW9A5wC0kCY2t6B7qFJIDxNb3gFpICBt1CegcG3EKSwPiaXnQLSQDja3rBLSQJjK/pBbeQJDC+phfdQnoHBtxCUsCAW0gSGF/TC24hSWB8TS+6hSSA8TW94BaSBMbX9IJbSAoYcAtJAYNuIQlgfE0vuIUkgfE1veAWkgTG1/SiW0gCGF/TC24hKWDQLaR3YMAtJAmMr+lFt5AEML6mF9xCksD4ml5wC0kC42t60S2kd2DALSQFDLiFJIHxNb3gFpIExtf0oltIAhhf0wtuIUlgfE0vuIWkgAG3kBQw6BaSAMbX9IJbSBIYX9MLbiFJYHxNL7qFJIDxNb3gFpICBt1CegcG3EKSwPiaXnQLSQDja3rBLSQJjK/pBbeQJDC2pneiW0ivwExwC0kAM8EtJAmMremdD/dpKoGxNb0T3UISwNia3gluIUlgbE3vBLeQFDDgFpICBt1CEsDYmt4JbiFJYGxN7wS3kCQwtqZ3oltIAhhb0zvBLSQFDLqF9A4MuIUkgbE1vRPdQhLA2JreCW4hSWBsTe8Et5AkML6mF91CegcG3EJSwIBbSBIYX9MLbiFJYHxNL7qFJIDxNb3gFpIExtf0gltIChhwC0kBg24hCWB8TS+4hSSB8TW94BaSBMbX9KJbSAIYX9MLbiEpYNAtpHdgwC0kCYyv6UW3kAQwvqYX3EKSwPiaXnALSQLja3rRLaR3YMAtJAUMuIUkgfE1veAWkgTG1/SiW0gCGF/TC24hSWB8TS+4haSAAbeQFDDoFpIAxtf0gltIEhhf0wtuIUlgfE0vuoUkgPE1veAWkgIG3UJ6BwbcQpLA+JpedAtJAONresEtJAmMr+kFt5AkML6mF91CegcG3EJSwIBbSBIYX9MLbiFJYHxNL7qFJIDxNb3gFpIExtb0LnALSQCzwC0kAcxCt5AEMLamdz3cp6kExtb0LnALSQJja3oXuoUkgLE1vQvcQlLAoFtI78CAW0gSGFvTu9AtJAGMreld4BaSBMbW9C5wC0kCY2t6F7qF9A4MuIWkgAG3kCQwtqZ3gVtIEhhb07vQLSQBjK3pXeAWkgTG1/SCW0gKGHALSQGDbiEJYHxNL7iFJIHxNb3gFpIExtf0oltIAhhf0wtuISlg0C2kd2DALSQJjK/pRbeQBDC+phfcQpLA+JpecAtJAuNretEtpHdgwC0kBQy4hSSB8TW94BaSBMbX9KJbSAIYX9MLbiFJYHxNL7iFpIABt5AUMOgWkgDG1/SCW0gSGF/TC24hSWB8TS+6hSSA8TW94BaSAgbdQnoHBtxCksD4ml50C0kA42t6wS0kCYyv6QW3kCQwvqYX3UJ6BwbcQlLAgFtIEhhf0wtuIUlgfE0vuoUkgPE1veAWkgTG1/SCW0gKGHALSQGDbiEJYHxNL7iFJIHxNb3gFpIExtf0oltIAhhb07vBLSQBzEa3kF6B2eAWkgTG1vTuh/w0FcDYmt4NbiFJYGxN7wa3kCQwtqZ3o1tI78CAW0gKGHALSQJja3o3uIUkgbE1vRvdQhLA2JreDW4hSWBsTe8Gt5AUMOAWkgIG3UISwNia3g1uIUlgbE3vBreQJDC2pnejW0gCGF/TC24hKWDQLaR3YMAtJAmMr+lFt5AEML6mF9xCksD4ml5wC0kC42t60S2kd2DALSQFDLiFJIHxNb3gFpIExtf0oltIAhhf0wtuIUlgfE0vuIWkgAG3kBQw6BaSAMbX9IJbSBIYX9MLbiFJYHxNL7qFJIDxNb3gFpICBt1CegcG3EKSwPiaXnQLSQDja3rBLSQJjK/pBbeQJDC+phfdQnoHBtxCUsCAW0gSGF/TC24hSWB8TS+6hSSA8TW94BaSBMbX9IJbSAoYcAtJAYNuIQlgfE0vuIUkgfE1veAWkgTG1/SiW0gCGF/TC24hKWDQLaR3YMAtJAmMr+lFt5AEML6mF9xCksD4ml5wC0kCY2t6D7qF9ArMAbeQBDAH3EKSwNia3vNwn6YSGFvTe9AtJAGMrek94BaSBMbW9B5wC0kBA24hKWDQLSQBjK3pPeAWkgTG1vQecAtJAmNreg+6hSSAsTW9B9xCUsCgW0jvwIBbSBIYW9N70C0kAYyt6T3gFpIExtb0HnALSQLja3rRLaR3YMAtJAUMuIUkgfE1veAWkgTG1/SiW0gCGF/TC24hSWB8TS+4haSAAbeQFDDoFpIAxtf0gltIEhhf0wtuIUlgfE0vuoUkgPE1veAWkgIG3UJ6BwbcQpLA+JpedAtJAONresEtJAmMr+kFt5AkML6mF91CegcG3EJSwIBbSBIYX9MLbiFJYHxNL7qFJIDxNb3gFpIExtf0gltIChhwC0kBg24hCWB8TS+4hSSB8TW94BaSBMbX9KJbSAIYX9MLbiEpYNAtpHdgwC0kCYyv6UW3kAQwvqYX3EKSwPiaXnALSQLja3rRLaR3YMAtJAUMuIUkgfE1veAWkgTG1/SiW0gCGF/TC24hSWBcTW8+4BbSOzD36K6m9x7d1fTeo7ua3nt07tNUAuNqeu/RXU3vPbqr6b1HdzW99+iupjcfcAtJAYNuIb0DA24hSWBcTe89OvlpKoBxNb336K6m9x7d1fTeo7ua3nt0V9ObD7qF9A4MuIWkgAG3kCQwrqb3Hp37NJXAuJree3RX03uP7mp679FdTe89uq/pBbeQFDDgFpICBt1CEsD4ml5wC0kC42t6wS0kCYyv6UW3kAQwvqYX3EJSwKBbSO/AgFtIEhhf04tuIQlgfE0vuIUkgfE1veAWkgTG1/SiW0jvwIBbSAoYcAtJAuNresEtJAmMr+lFt5AEML6mF9xCksD4ml5wC0kBA24hKWDQLSQBjK/pBbeQJDC+phfcQpLA+JpedAtJAONresEtJAUMuoX0Dgy4hSSB8TW96BaSAMbX9IJbSBIYX9MLbiFJYHxNL7qF9A4MuIWkgAG3kCQwvqYX3EKSwPiaXnQLSQDja3rBLSQJjK/pBbeQFDDgFpICBt1CEsD4ml5wC0kC42t6wS0kCYyv6UW3kAQwtqa3gVtIApiGbiG9AtPALSQJjK3pbQ/5aSqAsTW9DdxCksDYmt4GbiFJYGxNb0O3kN6BAbeQFDDgFpIExtb0NnALSQJja3obuoUkgLE1vQ3cQpLA2JreBm4hKWDALSQFDLqFJICxNb0N3EKSwNia3gZuIUlgbE1vQ7eQBDC+phfcQlLAoFtI78CAW0gSGF/Ti24hCWB8TS+4hSSB8TW94BaSBMbX9KJbSO/AgFtIChhwC0kC42t6wS0kCYyv6UW3kAQwvqYX3EKSwPiaXnALSQEDbiEpYNAtJAGMr+kFt5AkML6mF9xCksD4ml50C0kA42t6wS0kBQy6hfQODLiFJIHxNb3oFpIAxtf0gltIEhhf0wtuIUlgfE0vuoX0Dgy4haSAAbeQJDC+phfcQpLA+JpedAtJAONresEtJAmMr+kFt5AUMOAWkgIG3UISwPiaXnALSQLja3rBLSQJjK/pRbeQBDC+phfcQlLAoFtI78CAW0gSGF/Ti24hCWB8TS+4hSSB8TW94BaSBMbW9Aa6hfQKTIBbSAKYALeQJDC2pjce7tNUAmNregPdQhLA2JreALeQJDC2pjfALSQFDLiFpIBBt5AEMLamN8AtJAmMrekNcAtJAmNregPdQhLA2JreALeQFDDoFtI7MOAWkgTG1vQGuoUkgLE1vQFuIUlgbE1vgFtIEhhf04tuIb0DA24hKWDALSQJjK/pBbeQJDC+phfdQhLA+JpecAtJAuNresEtJAUMuIWkgEG3kAQwvqYX3EKSwPiaXnALSQLja3rRLSQBjK/pBbeQFDDoFtI7MOAWkgTG1/SiW0gCGF/TC24hSWB8TS+4hSSB8TW96BbSOzDgFpICBtxCksD4ml5wC0kC42t60S0kAYyv6QW3kCQwvqYX3EJSwIBbSAoYdAtJAONresEtJAmMr+kFt5AkML6mF91CEsD4ml5wC0kBg24hvQMDbiFJYHxNL7qFJIDxNb3gFpIExtf0gltIEhhf04tuIb0DA24hKWDALSQJjK/pBbeQJDC+phfdQhLA+JpecAtJAmNrehPcQhLAJLiFJIBJdAtJAGNrevPhPk0lMLamN8EtJAmMrelNdAtJAGNrehPcQlLAoFtI78CAW0gSGFvTm+gWkgDG1vQmuIUkgbE1vQluIUlgbE1voltI78CAW0gKGHALSQJja3oT3EKSwNia3kS3kAQwtqY3wS0kCYyv6QW3kBQw4BaSAgbdQhLA+JpecAtJAuNresEtJAmMr+lFt5AEML6mF9xCUsCgW0jvwIBbSBIYX9OLbiEJYHxNL7iFJIHxNb3gFpIExtf0oltI78CAW0gKGHALSQLja3rBLSQJjK/pRbeQBDC+phfcQpLA+JpecAtJAQNuISlg0C0kAYyv6QW3kCQwvqYX3EKSwPiaXnQLSQDja3rBLSQFDLqF9A4MuIUkgfE1vegWkgDG1/SCW0gSGF/TC24hSWB8TS+6hfQODLiFpIABt5AkML6mF9xCksD4ml50C0kA42t6wS0kCYyv6QW3kBQw4BaSAgbdQhLA+JpecAtJAuNresEtJAmMr+lFt5AEMLamt4NbSAKYjm4hvQLTwS0kCYyt6e0P+WkqgLE1vR3cQpLA2JreDm4hSWBsTW9Ht5DegQG3kBQw4BaSBMbW9HZwC0kCY2t6O7qFJICxNb0d3EKSwNia3g5uISlgwC0kBQy6hSSAsTW9HdxCksDYmt4ObiFJYGxNb0e3kAQwvqYX3EJSwKBbSO/AgFtIEhhf04tuIQlgfE0vuIUkgfE1veAWkgTG1/SiW0jvwIBbSAoYcAtJAuNresEtJAmMr+lFt5AEML6mF9xCksD4ml5wC0kBA24hKWDQLSQBjK/pBbeQJDC+phfcQpLA+JpedAtJAONresEtJAUMuoX0Dgy4hSSB8TW96BaSAMbX9IJbSBIYX9MLbiFJYHxNL7qF9A4MuIWkgAG3kCQwvqYX3EKSwPiaXnQLSQDja3rBLSQJjK/pBbeQFDDgFpICBt1CEsD4ml5wC0kC42t6wS0kCYyv6UW3kAQwvqYX3EJSwKBbSO/AgFtIEhhf04tuIQlgfE0vuIUkgfE1veAWkgTG1vQOdAvpFZgBbiEJYAa4hSSBsTW94+E+TSUwtqZ3oFtIAhhb0zvALSQJjK3pHeAWkgIG3EJSwKBbSAIYW9M7wC0kCYyt6R3gFpIExtb0DnQLSQBja3oHuIWkgEG3kN6BAbeQJDC2pnegW0gCGFvTO8AtJAmMrekd4BaSBMbX9KJbSO/AgFtIChhwC0kC42t6wS0kCYyv6UW3kAQwvqYX3EKSwPiaXnALSQEDbiEpYNAtJAGMr+kFt5AkML6mF9xCksD4ml50C0kA42t6wS0kBQy6hfQODLiFJIHxNb3oFpIAxtf0gltIEhhf0wtuIUlgfE0vuoX0Dgy4haSAAbeQJDC+phfcQpLA+JpedAtJAONresEtJAmMr+kFt5AUMOAWkgIG3UISwPiaXnALSQLja3rBLSQJjK/pRbeQBDC+phfcQlLAoFtI78CAW0gSGF/Ti24hCWB8TS+4hSSB8TW94BaSBMbX9KJbSO/AgFtIChhwC0kC42t6wS0kCYyv6UW3kAQwvqYX3EKSwNia3gluIQlgJriFJICZ6BaSAMbW9M6H+zSVwNia3gluIUlgbE3vRLeQBDC2pneCW0gKGHQL6R0YcAtJAmNreie6hSSAsTW9E9xCksDYmt4JbiFJYGxN70S3kN6BAbeQFDDgFpIExtb0TnALSQJja3onuoUkgLE1vRPcQpLA+JpecAtJAQNuISlg0C0kAYyv6QW3kCQwvqYX3EKSwPiaXnQLSQDja3rBLSQFDLqF9A4MuIUkgfE1vegWkgDG1/SCW0gSGF/TC24hSWB8TS+6hfQODLiFpIABt5AkML6mF9xCksD4ml50C0kA42t6wS0kCYyv6QW3kBQw4BaSAgbdQhLA+JpecAtJAuNresEtJAmMr+lFt5AEML6mF9xCUsCgW0jvwIBbSBIYX9OLbiEJYHxNL7iFJIHxNb3gFpIExtf0oltI78CAW0gKGHALSQLja3rBLSQJjK/pRbeQBDC+phfcQpLA+JpecAtJAQNuISlg0C0kAYyv6QW3kCQwvqYX3EKSwPiaXnQLSQBja3oXuIUkgFnoFtIrMAvcQpLA2Jre9ZCfpgIYW9O7wC0kCYyt6V3gFpIExtb0LnQL6R0YcAtJAQNuIUlgbE3vAreQJDC2pnehW0gCGFvTu8AtJAmMreld4BaSAgbcQlLAoFtIAhhb07vALSQJjK3pXeAWkgTG1vQudAtJAONresEtJAUMuoX0Dgy4hSSB8TW96BaSAMbX9IJbSBIYX9MLbiFJYHxNL7qF9A4MuIWkgAG3kCQwvqYX3EKSwPiaXnQLSQDja3rBLSQJjK/pBbeQFDDgFpICBt1CEsD4ml5wC0kC42t6wS0kCYyv6UW3kAQwvqYX3EJSwKBbSO/AgFtIEhhf04tuIQlgfE0vuIUkgfE1veAWkgTG1/SiW0jvwIBbSAoYcAtJAuNresEtJAmMr+lFt5AEML6mF9xCksD4ml5wC0kBA24hKWDQLSQBjK/pBbeQJDC+phfcQpLA+JpedAtJAONresEtJAUMuoX0Dgy4hSSB8TW96BaSAMbX9IJbSBIYX9MLbiFJYGxN70a3kF6B2eAWkgBmg1tIEhhb07sf7tNUAmNreje6hSSAsTW9G9xCksDYmt4NbiEpYMAtJAUMuoUkgLE1vRvcQpLA2JreDW4hSWBsTe9Gt5AEMLamd4NbSAoYdAvpHRhwC0kCY2t6N7qFJICxNb0b3EKSwNia3g1uIUlgfE0vuoX0Dgy4haSAAbeQJDC+phfcQpLA+JpedAtJAONresEtJAmMr+kFt5AUMOAWkgIG3UISwPiaXnALSQLja3rBLSQJjK/pRbeQBDC+phfcQlLAoFtI78CAW0gSGF/Ti24hCWB8TS+4hSSB8TW94BaSBMbX9KJbSO/AgFtIChhwC0kC42t6wS0kCYyv6UW3kAQwvqYX3EKSwPiaXnALSQEDbiEpYNAtJAGMr+kFt5AkML6mF9xCksD4ml50C0kA42t6wS0kBQy6hfQODLiFJIHxNb3oFpIAxtf0gltIEhhf0wtuIUlgfE0vuoX0Dgy4haSAAbeQJDC+phfcQpLA+JpedAtJAONresEtJAmMrek94BaSAOaAW0gCmINuIQlgbE3vebhPUwmMrek94BaSBMbW9B50C0kAY2t6D7iFpIBBt5DegQG3kCQwtqb3oFtIAhhb03vALSQJjK3pPeAWkgTG1vQedAvpHRhwC0kBA24hSWBsTe8Bt5AkMLam96BbSAIYW9N7wC0kCYyv6QW3kBQw4BaSAgbdQhLA+JpecAtJAuNresEtJAmMr+lFt5AEML6mF9xCUsCgW0jvwIBbSBIY8NO0tZ//zdHG3/lb5z5NI8b5+ehx8m+P/t2n6Znxp394Pfn89T/8v08zUadZqNNs1GkO6TRfTgWp0zTUaQJ1mkSdpqNOg/otHqjf4oH6LR6o3+KB+i2eqN/iifotnqjf4on6LZ6o3+KJ+i2eqN/iifotnqjf4on6LV6o3+KF+i1eqN/ihfotXqjf4oX6LV6o3+KF+i1eqN/ihfot3qjf4o36Ld6o3+KN+i3eqN/ijfot3qjf4o36Ld6o3+KN+i0+qN/ig/otPqjf4oP6LT6o3+KD+i0+qN/ig/otPqjf4gP6Le7PA/otvqcB/Rbf04B+i+9pQL/F9zSg3+J7GtBv8T0N6Lf4ngb0W3xPA/otvqdB/RY31G9xQ/0WN9RvcUP9FjfUb/F3p5fbE6f9/E8/mfNvzzNh51mw82zYeQ7rPN8d871nGPMv5znx/o/3+fO/uv/V//fSdv509Ab7qwzYedL31nbYXyXsVz+m762FPSAC9oCIY3tr82H9VSbsAZHhe2sT9lcJe0Dk8L21sC+IhD0gcvveWtjHRoc9IHqzvbUd9rHRYQ+I745NfvbWwj42OuwB0ZfvrYV9bHTYA2L42qgB+9gYsAfE8LVR353k/Af+KmEPiOFrowbsY2PAHhDD10ZN2MfGhD0gpq+NmrCPje+Ol/4D5/G1URP2sTFhD4jpa6Mm7GNjwR4Qy9dGLdjHxoI9IL478/rZWwv72FiwB8TytVEL9rGxYA+I7WujNuxjY8MeENvXRn13Zvcf+KuEPSC2r43asI+NDXtAbF8bdWAfGwf2gDi+NurAPja+O0j8D5zH10Yd2MfGgT0gjq+NOqyPjfawHhDtsbVR7WF9bLSH9YBoT/e9tayPjfawHhDtsbVR7WF9bLQH9oBotjaqNdbHRmuwB0SztVHtu9PZ/8BfJewB0WxtVIONcjfYKHdrtjaqBexjAzbK3cLWRrWAfWzARrlb2NqoFrCPDdgodwtbG9UC9rEBG+Vu6WujEvaxARvlbt8e5f7krYV9bMBGuVv62qiEfWzARrlb97VRHfaxARvlbt3XRn176lv+VcIeEN3XRnXYxwZslLt1Xxs1YB8bsFHuNnxt1IB9bMBGudvwtVED9rEBG+Vuw9dGDdjHBmyUu01fGzVhHxuwUe727VHuT95a2McGbJS7TV8bNWEfG7BR7rZ8bdSCfWzARrnb8rVR3576ln+VsAfE8rVRC/axARvlbsvXRm3YxwZslLttXxu1YR8bsFHutn1t1IZ9bMBGudv2tVEb9rEBG+Vux9dGHdjHBmyUu317lPuTtxb2sQEb5W7H10Yd2McGbJQ7HlsbFQ/rYyNgo9zx2NqoeDrsr5L1gIjH1kbFw/rYCNgodzy2Nioa62MjYKPc0WxtVDTWx0bARrmj2dqogG3lDtgodzRbGxWwBd4BG+WOsLVRAVvgHbBR7vj2KPcnby3sYwM2yh1ha6MCtsA7YKPckb42CrbAO2Cj3JG+Ngq2wDtgo9yRvjYKtsA7YKPckb42CrbAO2Cj3NF9bRRsgXfARrmj+9oo2ALvgI1yR/e1UbAF3gEb5Y7ha6NgC7wDNsod3x7l/uSthX1swEa5Y/jaKNgC74CNcsf0tVGwBd4BG+WO6WujYAu8AzbKHdPXRsEWeAdslDumr42CLfAO2Ch3LF8bBVvgHbBR7li+Ngq2wDtgo9yxfG0UbIF3wEa5Y/vaKNgC74CNcse3R7k/eWthHxuwUe7YvjYKtsA7YKPccXxtFGyBd8BGueP42ijYAu+AjXLH8bVRsAXeARvljmNroxK2wDtho9z52NqohC3wzof1gMjH1kYlbIF3wka587G1UQlb4J2wUe5stjYqYQu8EzbKnd8e5f7krWV9bCRslDubrY1K2ALvhI1yZ9jaqIQt8E7YKHeGrY1K2ALvhI1yZ9jaqIQt8E7YKHeGr42CLfBO2Ch3pq+Ngi3wTtgod6avjYIt8E7YKHemr42CLfBO2Ch3dl8bBVvgnbBR7vz2KPcnby3sYwM2yp3d10bBFngnbJQ7h6+Ngi3wTtgodw5fGwVb4J2wUe4cvjYKtsA7YaPcOXxtFGyBd8JGuXP62ijYAu+EjXLn9LVRsAXeCRvlzulro2ALvBM2yp3L10bBFngnbJQ7vz3K/clbC/vYgI1y5/K1UbAF3gkb5c7ta6NgC7wTNsqd29dGwRZ4J2yUO7evjYIt8E7YKHduXxsFW+CdsFHuPL42CrbAO2Gj3Hl8bRRsgXfCRrnz+Noo2ALvDhvl7o+tjeqwBd4dNsrdn+57a1kfGx02yt0fWxvVYQu8O2yUuzdbG9VhC7w7bJS7N1sb1WELvDtslLs3WxvVYQu8O2yUuzdbG9VhC7w7bJS7h62N6rAF3h02yt3D1kZ12ALvDhvl7mFrozpsgXeHjXL39LVRsAXeHTbK3b89yv3JWwv72ICNcvf0tVGwBd4dNsrdu6+Ngi3w7rBR7t59bRRsgXeHjXL37mujYAu8O2yUu3dfGwVb4N1ho9x9+Noo2ALvDhvl7sPXRsEWeHfYKHcfvjYKtsC7w0a5+/S1UbAF3h02yt2/Pcr9yVsL+9iAjXL36WujYAu8O2yUuy9fGwVb4N1ho9x9+doo2ALvDhvl7svXRsEWeHfYKHdfvjYKtsC7w0a5+/a1UbAF3h02yt23r42CLfDusFHuvn1tFGyBd4eNcvfja6NgC7w7bJS7f3uU+5O3FvaxARvl7sfXRsEWeHfYKPd4bG3UgC3wHrBR7vHY2qjxdNhfJesBMR5bGzVgC7wHbJR7PLY2asAWeA/YKPdotjZqwBZ4D9go92i2NmrAFngP2Cj3aLY2asAWeA/YKPcIWxs1YAu8B2yUe3x7lPuTtxb2sQEb5R5ha6MGbIH3gI1yj/S1UbAF3gM2yj3S10bBFngP2Cj3SF8bBVvgPWCj3CN9bRRsgfeAjXKP7mujYAu8B2yUe3RfGwVb4D1go9yj+9oo2ALvARvlHsPXRsEWeA/YKPf49ij3J28t7GMDNso9hq+Ngi3wHrBR7jF9bRRsgfeAjXKP6WujYAu8B2yUe0xfGwVb4D1go9xj+too2ALvARvlHsvXRsEWeA/YKPdYvjYKtsB7wEa5x/K1UbAF3gM2yj22r42CLfAesFHu8e1R7k/eWtjHBmyUe2xfGwVb4D1go9zj+Noo2ALvARvlHsfXRsEWeA/YKPc4vjYKtsB7wEa5x7G1URO2wHvCRrnnY2ujJmyB93xYD4j52NqoCVvgPWGj3POxtVETtsB7wka5Z7O1URO2wHvCRrnnt0e5P3lrWR8bEzbKPZutjZqwBd4TNso9w9ZGTdgC7wkb5Z5ha6MmbIH3hI1yz7C1URO2wHvCRrln+Noo2ALvCRvlnulro2ALvCdslHumr42CLfCesFHumb42CrbAe8JGuWf3tVGwBd4TNso9vz3K/clbC/vYgI1yz+5ro2ALvCdslHsOXxsFW+A9YaPcc/jaKNgC7wkb5Z7D10bBFnhP2Cj3HL42CrbAe8JGuef0tVGwBd4TNso9p6+Ngi3wnrBR7jl9bRRsgfeEjXLP5WujYAu8J2yUe357lPuTtxb2sQEb5Z7L10bBFnhP2Cj33L42CrbAe8JGuef2tVGwBd4TNso9t6+Ngi3wnrBR7rl9bRRsgfeEjXLP42ujYAu8J2yUex5fGwVb4D1ho9zz+Noo2ALvBRvlXo+tjVqwBd4LNsq9nu57a1kfGws2yr0eWxu1YAu8F2yUezVbG7VgC7wXbJR7NVsbtWALvBdslHs1Wxu1YAu8F2yUezVbG7VgC7wXbJR7ha2NWrAF3gs2yr3C1kYt2ALvBRvlXmFroxZsgfeCjXKv9LVRsAXeCzbKvb49yv3JWwv72ICNcq/0tVGwBd4LNsq9uq+Ngi3wXrBR7tV9bRRsgfeCjXKv7mujYAu8F2yUe3VfGwVb4L1go9xr+Noo2ALvBRvlXsPXRsEWeC/YKPcavjYKtsB7wUa51/S1UbAF3gs2yr2+Pcr9yVsL+9iAjXKv6WujYAu8F2yUey1fGwVb4L1go9xr+doo2ALvBRvlXsvXRsEWeC/YKPdavjYKtsB7wUa51/a1UbAF3gs2yr22r42CLfBesFHutX1tFGyB94KNcq/ja6NgC7wXbJR7fXuU+5O3FvaxARvlXsfXRsEWeC/YKPd+bG3Uhi3w3rBR7v3Y2qj9dNhfJesBsR9bG7VhC7w3bJR7P7Y2asMWeG/YKPdutjZqwxZ4b9go9262NmrDFnhv2Cj3brY2asMWeG/YKPcOWxu1YQu8N2yUe397lPuTtxb2sQEb5d5ha6M2bIH3ho1y7/S1UbAF3hs2yr3T10bBFnhv2Cj3Tl8bBVvgvWGj3Dt9bRRsgfeGjXLv7mujYAu8N2yUe3dfGwVb4L1ho9y7+9oo2ALvDRvl3sPXRsEWeG/YKPf+9ij3J28t7GMDNsq9h6+Ngi3w3rBR7j19bRRsgfeGjXLv6WujYAu8N2yUe09fGwVb4L1ho9x7+too2ALvDRvl3svXRsEWeG/YKPdevjYKtsB7w0a59/K1UbAF3hs2yr23r42CLfDesFHu/e1R7k/eWtjHBmyUe29fGwVb4L1ho9z7+Noo2ALvDRvl3sfXRsEWeG/YKPc+vjYKtsB7w0a597G1UQe2wPvARrnPY2ujDmyB93lYD4jz2NqoA1vgfWCj3OextVEHtsD7wEa5T7O1UQe2wPvARrnPt0e5P3lrWR8bBzbKfZqtjTqwBd4HNsp9wtZGHdgC7wMb5T5ha6MObIH3gY1yn7C1UQe2wPvARrlP+Noo2ALvAxvlPulro2ALvA9slPukr42CLfA+sFHuk742CrbA+8BGuU/3tVGwBd4HNsp9vj3K/clbC/vYgI1yn+5ro2ALvA9slPsMXxsFW+B9YKPcZ/jaKNgC7wMb5T7D10bBFngf2Cj3Gb42CrbA+8BGuc/0tVGwBd4HNsp9pq+Ngi3wPrBR7jN9bRRsgfeBjXKf5WujYAu8D2yU+3x7lPuTtxb2sQEb5T7L10bBFngf2Cj32b42CrbA+8BGuc/2tVGwBd4HNsp9tq+Ngi3wPrBR7rN9bRRsgfeBjXKf42ujYAu8D2yU+xxfGwVb4H1go9zn+Noo1gLv8bBGue95XG3UPTrqY+OeB/WAuOfpvrcW9bFxz4N6QNzzuNqoe3TUx8Y9D+wB0Vxt1D066mPjngf2gGiuNuoevcP+KmEPiOZqo+7RUR8b9zywB0RztVHjYS3wvueBPSDC1Ubdo8M+Nlij3Pc8rjbqHh32scEa5b7ncbVR9+iwjw3WKPc9j6+NYi3wvueBPSC+Pcr9yVsL+9hgjXLf8/jaKNYC73se2AOi+9oo1gLvex7YA6L72ijWAu97HtgDovvaKNYC73se2AOi+9oo1gLvex7YA2L42ijWAu97HtgDYvjaKNYC73se2ANi+Noo1gLv8bBGue95fG0Ua4H3PQ/sAfHtUe5P3lrYxwZrlPuex9dGsRZ43/PAHhDL10axFnjf88AeEMvXRrEWeN/zwB4Qy9dGsRZ43/PAHhDL10axFnjf88AeENvXRrEWeN/zwB4Q29dGsRZ43/PAHhDb10axFniPhzXKfc/ja6NYC7zveWAPiG+Pcn/y1sI+Nlij3Pc8vjaKtcD7nof1gGiPrY1qrAXe9zysB0R7bG1Uezrsr5L1gGiPrY1qrAXe9zysB0R7bG1UYy3wvueBPSCarY1qrAXe9zywB0SztVGNtcD7ngf2gGi2NqqxFniPBhvlbmFroxprgfc9D+wB8e1R7k/eWtjHBmyUu4WtjWqsBd73PLAHRPraKNYC73se2AMifW0Ua4H3PQ/sAZG+Noq1wPueB/aASF8bxVrgfc8De0B0XxvFWuB9zwN7QHRfG8Va4H3PA3tAdF8bxVrgPRpslLsNXxvFWuB9zwN7QHx7lPuTtxb2sQEb5W7D10axFnjf88AeENPXRrEWeN/zwB4Q09dGsRZ43/PAHhDT10axFnjf88AeENPXRrEWeN/zwB4Qy9dGsRZ43/PAHhDL10axFnjf88AeEMvXRrEWeI8GG+Vu29dGsRZ43/PAHhDfHuX+5K2FfWzARrnb9rVRrAXe9zywB8TxtVGsBd73PLAHxPG1UawF3vc8sAfE8bVRrAXe9zywB8SxtVEBW+AdsFHueGxtVMAWeMfDekDEY2ujArbAO2Cj3PHY2qiALfAO2Ch3NFsbFbAF3gEb5Y5vj3J/8tayPjYCNsodzdZGBWyBd8BGuSNsbVTAFngHbJQ7wtZGBWyBd8BGuSNsbVTAFngHbJQ7wtdGwRZ4B2yUO9LXRsEWeAdslDvS10bBFngHbJQ70tdGwRZ4B2yUO7qvjYIt8A7YKHd8e5T7k7cW9rEBG+WO7mujYAu8AzbKHcPXRsEWeAdslDuGr42CLfAO2Ch3DF8bBVvgHbBR7hi+Ngq2wDtgo9wxfW0UbIF3wEa5Y/raKNgC74CNcsf0tVGwBd4BG+WO5WujYAu8AzbKHd8e5f7krYV9bMBGuWP52ijYAu+AjXLH9rVRsAXeARvlju1ro2ALvAM2yh3b10bBFngHbJQ7tq+Ngi3wDtgodxxfGwVb4B2wUe44vjYKtsA7YKPccXxtFGyBd8JGufOxtVEJW+CdsFHufLrvrWV9bCRslDsfWxuVsAXeCRvlzmZroxK2wDtho9zZbG1UwhZ4J2yUO5utjUrYAu+EjXJns7VRCVvgnbBR7gxbG5WwBd4JG+XOsLVRCVvgnbBR7gxbG5WwBd4JG+XO9LVRsAXeCRvlzm+Pcn/y1sI+NmCj3Jm+Ngq2wDtho9zZfW0UbIF3wka5s/vaKNgC74SNcmf3tVGwBd4JG+XO7mujYAu8EzbKncPXRsEWeCdslDuHr42CLfBO2Ch3Dl8bBVvgnbBR7py+Ngq2wDtho9z57VHuT95a2McGbJQ7p6+Ngi3wTtgody5fGwVb4J2wUe5cvjYKtsA7YaPcuXxtFGyBd8JGuXP52ijYAu+EjXLn9rVRsAXeCRvlzu1ro2ALvBM2yp3b10bBFngnbJQ7j6+Ngi3wTtgod357lPuTtxb2sQEb5c7ja6NgC7wTNsrdH1sb1WELvDtslLs/tjaqPx32V8l6QPTH1kZ12ALvDhvl7o+tjeqwBd4dNsrdm62N6rAF3h02yt2brY3qsAXeHTbK3ZutjeqwBd4dNsrdw9ZGddgC7w4b5e7fHuX+5K2FfWzARrl72NqoDlvg3WGj3D19bRRsgXeHjXL39LVRsAXeHTbK3dPXRsEWeHfYKHdPXxsFW+DdYaPcvfvaKNgC7w4b5e7d10bBFnh32Ch37742CrbAu8NGufvwtVGwBd4dNsrdvz3K/clbC/vYgI1y9+Fro2ALvDtslLtPXxsFW+DdYaPcffraKNgC7w4b5e7T10bBFnh32Ch3n742CrbAu8NGufvytVGwBd4dNsrdl6+Ngi3w7rBR7r58bRRsgXeHjXL37WujYAu8O2yUu397lPuTtxb2sQEb5e7b10bBFnh32Ch3P742CrbAu8NGufvxtVGwBd4dNsrdj6+Ngi3w7rBR7n5sbdSALfAesFHu8djaqAFb4D0e1gNiPLY2asAWeA/YKPd4bG3UgC3wHrBR7tFsbdSALfAesFHu8e1R7k/eWtbHxoCNco9ma6MGbIH3gI1yj7C1UQO2wHvARrlH2NqoAVvgPWCj3CNsbdSALfAesFHuEb42CrbAe8BGuUf62ijYAu8BG+Ue6WujYAu8B2yUe6SvjYIt8B6wUe7RfW0UbIH3gI1yj2+Pcn/y1sI+NmCj3KP72ijYAu8BG+Uew9dGwRZ4D9go9xi+Ngq2wHvARrnH8LVRsAXeAzbKPYavjYIt8B6wUe4xfW0UbIH3gI1yj+lro2ALvAdslHtMXxsFW+A9YKPcY/naKNgC7wEb5R7fHuX+5K2FfWzARrnH8rVRsAXeAzbKPbavjYIt8B6wUe6xfW0UbIH3gI1yj+1ro2ALvAdslHtsXxsFW+A9YKPc4/jaKNgC7wEb5R7H10bBFngP2Cj3OL42CrbAe8JGuedja6MmbIH3hI1yz6f73lrWx8aEjXLPx9ZGTdgC7wkb5Z7N1kZN2ALvCRvlns3WRk3YAu8JG+WezdZGTdgC7wkb5Z7N1kZN2ALvCRvlnmFroyZsgfeEjXLPsLVRE7bAe8JGuWfY2qgJW+A9YaPcM31tFGyB94SNcs9vj3J/8tbCPjZgo9wzfW0UbIH3hI1yz+5ro2ALvCdslHt2XxsFW+A9YaPcs/vaKNgC7wkb5Z7d10bBFnhP2Cj3HL42CrbAe8JGuefwtVGwBd4TNso9h6+Ngi3wnrBR7jl9bRRsgfeEjXLPb49yf/LWwj42YKPcc/raKNgC7wkb5Z7L10bBFnhP2Cj3XL42CrbAe8JGuefytVGwBd4TNso9l6+Ngi3wnrBR7rl9bRRsgfeEjXLP7WujYAu8J2yUe25fGwVb4D1ho9zz+Noo2ALvCRvlnt8e5f7krYV9bMBGuefxtVGwBd4TNsq9HlsbtWALvBdslHs9tjZqPR32V8l6QKzH1kYt2ALvBRvlXo+tjVqwBd4LNsq9mq2NWrAF3gs2yr2arY1asAXeCzbKvZqtjVqwBd4LNsq9wtZGLdgC7wUb5V7fHuX+5K2FfWzARrlX2NqoBVvgvWCj3Ct9bRRsgfeCjXKv9LVRsAXeCzbKvdLXRsEWeC/YKPdKXxsFW+C9YKPcq/vaKNgC7wUb5V7d10bBFngv2Cj36r42CrbAe8FGudfwtVGwBd4LNsq9vj3K/clbC/vYgI1yr+Fro2ALvBdslHtNXxsFW+C9YKPca/raKNgC7wUb5V7T10bBFngv2Cj3mr42CrbAe8FGudfytVGwBd4LNsq9lq+Ngi3wXrBR7rV8bRRsgfeCjXKv7WujYAu8F2yUe317lPuTtxb2sQEb5V7b10bBFngv2Cj3Or42CrbAe8FGudfxtVGwBd4LNsq9jq+Ngi3wXrBR7nVsbdSGLfDesFHu/djaqA1b4L0f1gNiP7Y2asMWeG/YKPd+bG3Uhi3w3rBR7t1sbdSGLfDesFHu/e1R7k/eWtbHxoaNcu9ma6M2bIH3ho1y77C1URu2wHvDRrl32NqoDVvgvWGj3DtsbdSGLfDesFHuHb42CrbAe8NGuXf62ijYAu8NG+Xe6WujYAu8N2yUe6evjYIt8N6wUe7dfW0UbIH3ho1y72+Pcn/y1sI+NmCj3Lv72ijYAu8NG+Xew9dGwRZ4b9go9x6+Ngq2wHvDRrn38LVRsAXeGzbKvYevjYIt8N6wUe49fW0UbIH3ho1y7+lro2ALvDdslHtPXxsFW+C9YaPce/naKNgC7w0b5d7fHuX+5K2FfWzARrn38rVRsAXeGzbKvbevjYIt8N6wUe69fW0UbIH3ho1y7+1ro2ALvDdslHtvXxsFW+C9YaPc+/jaKNgC7w0b5d7H10bBFnhv2Cj3Pr42CrbA+8BGuc9ja6MObIH3gY1yn6f73lrWx8aBjXKfx9ZGHdgC7wMb5T7N1kYd2ALvAxvlPs3WRh3YAu8DG+U+zdZGHdgC7wMb5T7N1kYd2ALvAxvlPmFrow5sgfeBjXKfsLVRB7bA+8BGuU/Y2qgDW+B9YKPcJ31tFGyB94GNcp9vj3J/8tbCPjZgo9wnfW0UbIH3gY1yn+5ro2ALvA9slPt0XxsFW+B9YKPcp/vaKNgC7wMb5T7d10bBFngf2Cj3Gb42CrbA+8BGuc/wtVGwBd4HNsp9hq+Ngi3wPrBR7jN9bRRsgfeBjXKfb49yf/LWwj42YKPcZ/raKNgC7wMb5T7L10bBFngf2Cj3Wb42CrbA+8BGuc/ytVGwBd4HNsp9lq+Ngi3wPrBR7rN9bRRsgfeBjXKf7WujYAu8D2yU+2xfGwVb4H1go9zn+Noo2ALvAxvlPt8e5f7krYV9bMBGuc/xtVGwBd6HNco9n8fVRt2joz427nlQD4h7HlcbdY/eYX+VqAfEPY+rjbpHR31s3POgHhD3PK42aj6sBd73PLAHRHO1UffoqI+Nex7YA6K52qh7dNTHxj0P7AHRXG3UPTrsY4M1yn3P42qj7tFhHxusUe57nu57a2EfG6xR7nseVxt1jw772GCNcs8nfW0Ua4H3PQ/sAZG+Noq1wPueB/aASF8bxVrgfc8De0Ckr41iLfC+54E9ILqvjWIt8L7ngT0guq+NYi3wvueBPSC6r41iLfCeD2uU+57H10axFnjf88AeEN8e5f7krYV9bLBGue95fG0Ua4H3PQ/sATF9bRRrgfc9D+wBMX1tFGuB9z0P7AExfW0Ua4H3PQ/sATF9bRRrgfc9D+wBsXxtFGuB9z0P7AGxfG0Ua4H3PQ/sAbF8bRRrgfd8WKPc9zy+Noq1wPueB/aA+PYo9ydvLexjgzXKfc/ja6NYC7zveWAPiONro1gLvO95YA+I42ujWAu873lgD4jja6NYC7zveWAPiGNroxprgfc9D+sB0R5bG9VYC7zveVgPiPbY2qjGWuB9z8N6QLTH1kY11gLv2WCj3K3Z2qjGWuB9zwN7QHx7lPuTt5b1sdFgo9yt2dqoxlrgfc8De0CErY1qrAXe9zywB0TY2qjGWuB9zwN7QIStjWqsBd73PLAHRPjaKNYC73se2AMifW0Ua4H3PQ/sAZG+Noq1wPueB/aASF8bxVrgPRtslLt1XxvFWuB9zwN7QHx7lPuTtxb2sQEb5W7d10axFnjf88AeEMPXRrEWeN/zwB4Qw9dGsRZ43/PAHhDD10axFnjf88AeEMPXRrEWeN/zwB4Q09dGsRZ43/PAHhDT10axFnjf88AeENPXRrEWeM8GG+Vuy9dGsRZ43/PAHhDfHuX+5K2FfWzARrnb8rVRrAXe9zywB8T2tVGsBd73PLAHxPa1UawF3vc8sAfE9rVRrAXe9zywB8T2tVGsBd73PLAHxPG1UawF3vc8sAfE8bVRrAXe9zywB8TxtVGwBd4BG+WOx9ZGBWyBd8BGuePpvreW9bERsFHueGxtVMAWeAdslDuarY0K2ALvgI1yR7O1UQFb4B2wUe5otjYqYAu8AzbKHc3WRgVsgXfARrkjbG1UwBZ4B2yUO8LWRgVsgXfARrkjbG1UwBZ4B2yUO9LXRsEWeAdslDu+Pcr9yVsL+9iAjXJH+too2ALvgI1yR/e1UbAF3gEb5Y7ua6NgC7wDNsod3ddGwRZ4B2yUO7qvjYIt8A7YKHcMXxsFW+AdsFHuGL42CrbAO2Cj3DF8bRRsgXfARrlj+too2ALvgI1yx7dHuT95a2EfG7BR7pi+Ngq2wDtgo9yxfG0UbIF3wEa5Y/naKNgC74CNcsfytVGwBd4BG+WO5WujYAu8AzbKHdvXRsEWeAdslDu2r42CLfAO2Ch3bF8bBVvgHbBR7ji+Ngq2wDtgo9zx7VHuT95a2McGbJQ7jq+Ngi3wDtgodz62NiphC7wTNsqdj62NyqfD/ipZD4h8bG1UwhZ4J2yUOx9bG5WwBd4JG+XOZmujErbAO2Gj3NlsbVTCFngnbJQ7m62NStgC74SNcmfY2qiELfBO2Ch3fnuU+5O3FvaxARvlzrC1UQlb4J2wUe5MXxsFW+CdsFHuTF8bBVvgnbBR7kxfGwVb4J2wUe5MXxsFW+CdsFHu7L42CrbAO2Gj3Nl9bRRsgXfCRrmz+9oo2ALvhI1y5/C1UbAF3gkb5c5vj3J/8tbCPjZgo9w5fG0UbIF3wka5c/raKNgC74SNcuf0tVGwBd4JG+XO6WujYAu8EzbKndPXRsEWeCdslDuXr42CLfBO2Ch3Ll8bBVvgnbBR7ly+Ngq2wDtho9y5fW0UbIF3wka589uj3J+8tbCPDdgod25fGwVb4J2wUe48vjYKtsA7YaPceXxtFGyBd8JGufP42ijYAu+EjXLnsbVRHbbAu8NGuftja6M6bIF3f1gPiP7Y2qgOW+DdYaPc/bG1UR22wLvDRrl7s7VRHbbAu8NGufu3R7k/eWtZHxsdNsrdm62N6rAF3h02yt3D1kZ12ALvDhvl7mFrozpsgXeHjXL3sLVRHbbAu8NGuXv42ijYAu8OG+Xu6WujYAu8O2yUu6evjYIt8O6wUe6evjYKtsC7w0a5e/e1UbAF3h02yt2/Pcr9yVsL+9iAjXL37mujYAu8O2yUuw9fGwVb4N1ho9x9+Noo2ALvDhvl7sPXRn176ns/8eej7/mIf3yc/PO/fJzxl398/en02/r0x/n03x4q/9zp7//8z3/4zW9/+5v/8d9++/t/+dUff/P73/37T3/2+el/+fv/70GtjZ//be2v/u//+Omv4u//P8O8/on44T+RP/wn+g//ifHDf2L+8J9YP/wn9g//ifOjfyJ/+J7nD9/z/OF7nj98z/OH73n+8D3PH77n+cP3PH/4nucP3/P+w/f8738Gtv7nZ/Fo/+ef+Punmn/+IZv/53/H33+Jfvvv+Puvua//HfnDf6L/8J8YP/wn5g//ifXDf2L/8J/44Tv49x+Lr3+i/fCf+OF7Pn/4ns8fvufzh+/5/OF7Pn/wnv/X/U//36/+8Jtf/fNvf/3TM/6n/8P/+N2//PzIv//xj///v/38f/LzS8G//eH3//Lrf/2PP/z6p9eDv7wZ/HRjz/PL1tpPPzj3P6znl/u5//P/+v9juNsv9/zpP/x0N1uL+8/1+19/j/A/AQ==","file_map":{"7":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"64":{"source":"use super::defaults::{BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK};\n\nuse crate::tables::{\n    BASE64_ENCODE_BE_TABLE, BASE64_ENCODE_BE_VAR_TABLE, BASE64URL_ENCODE_BE_TABLE,\n    BASE64URL_ENCODE_BE_VAR_TABLE,\n};\n\npub use crate::boundary_check::boundary_check;\n\nglobal CONVERT_MODULO3_TO_PADDING_BYTES: [u32; 3] = [0, 2, 1];\nglobal PAD_1: [Field; 3] = [0, 1, 1];\nglobal PAD_2: [Field; 3] = [0, 1, 0];\n\n// Encoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64EncodeBE {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * 3) + (((InputBytes % 3) / 2) * 2)] {\n        crate::encoder::encode::<InputBytes, 0, 1>(input)\n    }\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * 3) + (((MAX_INPUT_LEN % 3) / 2) * 2)> {\n        crate::encoder::encode_var::<_, 0, 1>(input)\n    }\n}\n\n// Encoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64EncodeBENoPad {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2)) + (((InputBytes % 3) / 2))] {\n        crate::encoder::encode::<InputBytes, 0, 0>(input)\n    }\n\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, (((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2)) + (((MAX_INPUT_LEN % 3) / 2)))> {\n        crate::encoder::encode_var::<_, 0, 0>(input)\n    }\n}\n\n// Encoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64EncodeBEUrlSafe {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2)) + (((InputBytes % 3) / 2))] {\n        crate::encoder::encode::<_, 1, 0>(input)\n    }\n\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, (((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2)) + (((MAX_INPUT_LEN % 3) / 2)))> {\n        crate::encoder::encode_var::<_, 1, 0>(input)\n    }\n}\n\n// Encoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64EncodeBEUrlSafeWithPad {\n    pub fn encode<let InputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * 3) + (((InputBytes % 3) / 2) * 2)] {\n        crate::encoder::encode::<_, 1, 1>(input)\n    }\n    pub fn encode_var<let MAX_INPUT_LEN: u32>(\n        input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * 3) + (((MAX_INPUT_LEN % 3) / 2) * 2)> {\n        crate::encoder::encode_var::<_, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Take an array of ASCII values and convert into base64 values\n * @tparam InputElements: The size of the array being encoded\n * @tparam UseUrlTable: are we encoding using the URL and Filename Safe Alphabet, or standard Base64 Alphabet? \n **/\nfn encode_elements<let InputElements: u32, let UseUrlTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; InputElements] {\n    let mut result: [u8; InputElements] = [0; InputElements];\n\n    for i in 0..InputElements {\n        let token: u8 = if UseUrlTable == 1 {\n            BASE64URL_ENCODE_BE_TABLE[input[i]]\n        } else {\n            BASE64_ENCODE_BE_TABLE[input[i]]\n        };\n        result[i] = token as u8;\n    }\n\n    result\n}\n\n/**\n * @brief Encode a variable-length ASCII string into Base64 values\n **/\nfn encode_var<let MAX_INPUT_LEN: u32, let UseURLTable: u1, let HasPadding: u32>(\n    input: BoundedVec<u8, MAX_INPUT_LEN>,\n    ) -> BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))> {\n    assert((HasPadding == 0) | (HasPadding == 1), \"invalid HasPadding parameter\");\n    // The max number of output Base64 values can be derived from the max input size\n    let mut result_arr: [u8; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] = [\n        0; ((MAX_INPUT_LEN * 8) / 6)\n            + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2))\n            + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))\n    ];\n\n    // Note: is this correct?\n    let output_length = ((MAX_INPUT_LEN * 8) / 6)\n        + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2))\n        + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding));\n\n    // Step 1: convert the input into six-bit chunks. We can map each chunk into Base64 values.\n    let raw: [u8; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] =\n        crate::encoder::split_into_six_bit_chunks::<_, _, 1>(input.storage());\n\n    let real_length = input.len();\n    // The input length modulo 3 can be used to determine the number of padding bytes\n    let real_length_mod_3 = if HasPadding == 1 { real_length % 3 } else { 0 };\n    // encoded_length = the number of Base64 values minus padding\n    let encoded_length = ((real_length * 8) + 5) / 6;\n    let final_length = encoded_length\n        + if HasPadding == 1 {\n            CONVERT_MODULO3_TO_PADDING_BYTES[real_length_mod_3]\n        } else {\n            0\n        };\n\n    // Get an array of Field elements where boundary_flags[i] = 0 if i < encoded_length, otherwise i = 1.\n    // We use this array to determine if the result array should contain a valid Base64 encoded value, 0 or if an error state has been reached\n    let boundary_flags: [Field; ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))] =\n        boundary_check(encoded_length);\n\n    // Using 2 lookups is slightly cheaper than figuring out if the 1st/2nd padding byte is set from the padding length param... I think?\n    let has_first_padding_byte = if HasPadding == 1 {\n        PAD_1[real_length_mod_3]\n    } else {\n        0\n    };\n    let has_second_padding_byte = if HasPadding == 1 {\n        PAD_2[real_length_mod_3]\n    } else {\n        0\n    };\n\n    // If we have actual data to iterate through, populate the 1st result entry with the base64 encoding of `raw[0]`.\n    // Note: if `boundary_flags[0] = 1`, the `BASE64_ENCODE_BE_VAR_TABLE` lookup will output 0.\n    // Note: `MAX_INPUT_LEN` is known at compile time so this `if` statement should not incur constraints.\n    if MAX_INPUT_LEN > 0 {\n        result_arr[0] = BASE64_ENCODE_BE_VAR_TABLE[raw[0] as Field + boundary_flags[0] * 64] as u8;\n    }\n\n    let mut previous_was_first_padding_byte = 0;\n    for i in 1..output_length {\n        let exceed_length = boundary_flags[i];\n        // hit_limit = we are at the first location where a padding Base64 character *could* be enerated\n\n        let mut encoding_index: Field = 0;\n\n        if HasPadding == 1 {\n            let hit_limit: Field = (1 - boundary_flags[i - 1]) * boundary_flags[i];\n            // We need to write a padding byte if `i == encoding_length` and `has_first_padding_byte == 1`\n            let write_first_padding_byte: Field = hit_limit * has_first_padding_byte;\n            // We need to write a padding byte if `i == encoding_length + 1` and `has_second_padding_byte == 1`\n            let write_second_padding_byte =\n                previous_was_first_padding_byte * has_second_padding_byte;\n\n            // Look up the encoded Base64 value given an input 6-bit chunk.\n            // We have 2 edge cases that we need to handle efficiently (writing padding bytes or we have exceeded the input length)\n            // Instead of expensive conditional logic we apply lookup tables as a quasi state machine to handle these edge cases.\n            // CASE 1: `exceed_length = 0`, `write_first_padding_byte = 0`, `write_second_padding_byte = 0`\n            //      outcome: we map the 6-bit input value into a Base64 encoding\n            // CASE 2: `exceed_length = 1` AND `write_first_padding_byte = 0` AND `write_second_padding_byte = 0`\n            //      outcome: if `raw[i] = 0`, the returned value is 0. All other inputs for `raw[i]` return an error state\n            // CASE 3: `exceed_length = 1` AND ()`write_first_padding_byte = 1` OR `write_second_padding_byte = 1`)\n            //      outcome: if `raw[i] = 0`, the returned value is BASE64_PADDING_CHAR. All other inputs for `raw[i]` return an error state\n            // Note: due to how they are constructed, it is not possible for both `write_first_padding_byte` and `write_second_padding_byte` to equal 1.\n            //       Similarly, it is not possible for `exceed_length = 0` and either of `write_first_padding_byte` or `write_second_padding_byte` to equal 1.\n            encoding_index = raw[i] as Field\n                + (exceed_length + write_first_padding_byte + write_second_padding_byte) * 64;\n            previous_was_first_padding_byte = write_first_padding_byte;\n        } else {\n            // We have 2 edge cases that we need to handle efficiently (writing padding bytes or we have exceeded the input length)\n            // Instead of expensive conditional logic we apply lookup tables as a quasi state machine to handle these edge cases.\n            // CASE 1: `exceed_length = 0`\n            //      outcome: we map the 6-bit input value into a Base64 encoding\n            // CASE 2: `exceed_length = 1`\n            //      outcome: if `raw[i] = 0`, the returned value is 0. All other inputs for `raw[i]` return an error state\n\n            encoding_index = raw[i] as Field + (exceed_length * 64);\n        }\n\n        // Note: this `if` condition is known at compile time so should not incur additional constraints\n        let token: u8 = if UseURLTable == 1 {\n            BASE64_ENCODE_BE_VAR_TABLE[encoding_index]\n        } else {\n            BASE64URL_ENCODE_BE_VAR_TABLE[encoding_index]\n        };\n        (token as Field).assert_max_bit_size::<7>();\n        result_arr[i] = token;\n    }\n\n    // we can use `from_parts_unchecked` here because the table BASE64_ENCODE_BE_VAR_TABLE (and it's URL equivalent)\n    // will produce an error if a nonzero input is given past `final_length`\n    let mut r: BoundedVec<u8, ((MAX_INPUT_LEN * 8) / 6) + (((MAX_INPUT_LEN % 3) % 2) * (1 + HasPadding * 2)) + (((MAX_INPUT_LEN % 3) / 2) * (1 + HasPadding))> =\n        BoundedVec::from_parts_unchecked(result_arr, final_length);\n\n    r\n}\n\n/**\n * @brief Take an array of ASCII bytes and convert into an array of six-bit chunks\n **/\nfn split_into_six_bit_chunks<let InputBytes: u32, let OutputElements: u32, let HasPadding: u32>(\n    input: [u8; InputBytes],\n) -> [u8; OutputElements] {\n    // Calculate the number of padding characters and the length of the output without padding\n\n    // input bytes modulo 3 . e.g.\n\n    // input = 5 implies 1 padding char = 40 bits of data = 6 base64 vals + 2 bits\n    // 1 is padding so we have 5 base64 vals\n    let rem = InputBytes % 3;\n    let num_padding_chars = if HasPadding == 1 {\n        if rem == 1 {\n            2\n        } else if rem == 2 {\n            1\n        } else {\n            0\n        }\n    } else {\n        0\n    };\n\n    let mut result: [u8; OutputElements] = [0; OutputElements];\n\n    let num_chunks = (InputBytes / BYTES_PER_CHUNK) + (InputBytes % BYTES_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            // pack the bytes into the field element\n            let mut slice: Field = 0;\n            for j in 0..BYTES_PER_CHUNK {\n                slice *= 256;\n                slice += input[i * BYTES_PER_CHUNK + j] as Field;\n            }\n            // extract the 6-bit values from the Field element\n            let slice_base64_chunks: [u8; BASE64_ELEMENTS_PER_CHUNK] = slice.to_be_radix(64);\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                result[i * BASE64_ELEMENTS_PER_CHUNK + j] = slice_base64_chunks[j];\n            }\n        }\n\n        // process the final chunk, which may require padding\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_offset = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let bytes_in_final_chunk = InputBytes - byte_offset;\n        let num_elements_in_final_chunk = OutputElements - base64_offset;\n\n        // pack the bytes into the field element\n        let mut slice: Field = 0;\n        for j in 0..bytes_in_final_chunk {\n            slice *= 256;\n            slice += input[(num_chunks - 1) * BYTES_PER_CHUNK + j] as Field;\n        }\n        for _ in bytes_in_final_chunk..BYTES_PER_CHUNK {\n            slice *= 256;\n        }\n\n        // extract the 6-bit values from the Field element\n        let slice_base64_chunks: [u8; BASE64_ELEMENTS_PER_CHUNK] = slice.to_be_radix(64);\n        for i in 0..num_elements_in_final_chunk {\n            // If padding is enabled, we can skip setting the last `non_padded_output_length` chars\n            // N.B. if statement is compile time so shouldn't add c onstraints\n            if HasPadding == 1 {\n                let non_padded_output_length = OutputElements - num_padding_chars;\n                if (base64_offset + i < non_padded_output_length) {\n                    result[base64_offset + i] = slice_base64_chunks[i];\n                }\n            } else {\n                result[base64_offset + i] = slice_base64_chunks[i];\n            }\n        }\n    }\n\n    result\n}\n\nfn encode<let InputBytes: u32, let UseUrlTable: u1, let UsePadding: u32>(\n    input: [u8; InputBytes],\n    ) -> [u8; ((InputBytes * 8) / 6) + (((InputBytes % 3) % 2) * (1 + UsePadding * 2)) + (((InputBytes % 3) / 2) * (1 + UsePadding))] {\n    assert((UsePadding == 0 as u32) | (UsePadding == 1 as u32), \"UsePadding must be 0 or 1\");\n    let mut result = crate::encoder::encode_elements::<_, UseUrlTable>(\n        crate::encoder::split_into_six_bit_chunks::<_, _, UsePadding>(input),\n    );\n    // this relationship should be evaluated at compile time\n    let OutputElements = ((InputBytes * 8) / 6)\n        + (((InputBytes % 3) % 2) * (1 + UsePadding * 2))\n        + (((InputBytes % 3) / 2) * (1 + UsePadding));\n    if UsePadding == 1 {\n        // handle padding\n        let rem = InputBytes % 3;\n        if (rem == 1) {\n            result[OutputElements - 1] = BASE64_PADDING_CHAR;\n            result[OutputElements - 2] = BASE64_PADDING_CHAR;\n        } else if (rem == 2) {\n            result[OutputElements - 1] = BASE64_PADDING_CHAR;\n        }\n    }\n    result\n}\n\n// === TESTS ======================================================================================\n\n#[test]\nfn test_encode_elements() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII (with the = padding character stripped)\n    let ascii_expected: [u8; 43] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85,\n    ];\n\n    let input: [u8; 43] = [\n        6, 49, 12, 37, 32, 48, 11, 34, 50, 41, 39, 21, 43, 4, 54, 2, 52, 18, 31, 56, 50, 51, 33, 28,\n        22, 19, 36, 0, 33, 18, 25, 57, 62, 22, 4, 17, 33, 10, 33, 23, 45, 37, 20,\n    ];\n\n    let ascii_result = crate::encoder::encode_elements::<_, 0>(input);\n\n    assert(ascii_result == ascii_expected);\n}\n\n#[test]\nfn test_encode_empty() {\n    let input: [u8; 0] = [];\n    let result = Base64EncodeBE::encode(input);\n    let expected: [u8; 0] = [];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_padding() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 4] = [90, 103, 61, 61];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 4] = [90, 109, 56, 61];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_standard_no_pad() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 2] = [90, 103];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 3] = [90, 109, 56];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = Base64EncodeBENoPad::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_max_byte() {\n    let input: [u8; 1] = [255];\n\n    let result: [u8; 4] = Base64EncodeBE::encode(input);\n    let expected: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    assert(result == expected);\n\n    let result: [u8; 2] = Base64EncodeBENoPad::encode(input);\n    let expected: [u8; 2] = [47, 119]; // \"/w\"\n    assert(result == expected);\n\n    let result: [u8; 4] = Base64EncodeBEUrlSafeWithPad::encode(input);\n    let expected: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    assert(result == expected);\n\n    let result: [u8; 2] = Base64EncodeBEUrlSafe::encode(input);\n    let expected: [u8; 2] = [95, 119]; // \"_w\"\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_ascii() {\n    // \"Hello World!\"\n    let input: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n    // base64: SGVsbG8gV29ybGQh\n    let expected: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_utf8() {\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let input: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let expected: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafeWithPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let input: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let expected: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result = Base64EncodeBE::encode(input);\n    assert(result == expected);\n\n    let expected: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_standard() {\n    // test encoding to / and +\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 4] = [47, 43, 65, 61];\n    let result: [u8; 4] = Base64EncodeBE::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_url_safe_with_pad() {\n    // test encoding to _ and -\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 4] = [95, 45, 65, 61];\n    let result: [u8; 4] = Base64EncodeBEUrlSafeWithPad::encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_url_safe() {\n    // test encoding to _ and -\n    let input: [u8; 2] = [255, 224];\n    let expected: [u8; 3] = [95, 45, 65];\n    let result: [u8; 3] = Base64EncodeBEUrlSafe::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU\n    // Translated directly to ASCII (with padding byte character stripped)\n    let expected: [u8; 43] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85,\n    ];\n\n    let input: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n\n    let result = Base64EncodeBENoPad::encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_base64_encode_slash() {\n    let input: [u8; 1] = [63]; // '/' in Base64\n    let result: [u8; 1] = crate::encoder::encode_elements::<_, 0>(input);\n\n    // Should map to '/' in ASCII, which is 47\n    assert(result[0] == 47);\n}\n\n#[test]\nfn test_encode_var_empty() {\n    let input: BoundedVec<u8, 3> = BoundedVec::new();\n    let result = Base64EncodeBE::encode_var(input);\n    let expected: BoundedVec<u8, 4> = BoundedVec::new();\n    assert(result == expected);\n\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64EncodeBE::encode_var(input);\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let result = Base64EncodeBE::encode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let expected: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let result = Base64EncodeBENoPad::encode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_var() {\n    // \"Hello, World!\"\n    let input: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let expected: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let expected_no_pad: BoundedVec<u8, 22> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode_var(input);\n    println(f\"result = {result}\");\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode_var(input);\n    assert(result == expected_no_pad);\n    let result = Base64EncodeBEUrlSafeWithPad::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafe::encode_var(input);\n    assert(result == expected_no_pad);\n}\n\n#[test]\nfn test_encode_var_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let input: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let expected: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let expected_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64EncodeBE::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBENoPad::encode_var(input);\n    assert(result == expected_no_pad);\n    let result = Base64EncodeBEUrlSafeWithPad::encode_var(input);\n    assert(result == expected);\n    let result = Base64EncodeBEUrlSafe::encode_var(input);\n    assert(result == expected_no_pad);\n}\n","path":"/Users/zac/noir_base64/src/encoder.nr"},"65":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let r = unsafe {\n        //@safety r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n        __boundary_check(limit)\n    };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/zac/noir_base64/src/boundary_check.nr"},"67":{"source":"use crate::decoder::{Base64DecodeBE, Base64DecodeBENoPad};\nuse crate::encoder::{Base64EncodeBE, Base64EncodeBENoPad, Base64EncodeBEUrlSafe};\n\n#[export]\nfn bench_encode_610(input: [u8; 610]) -> [u8; 816] {\n    Base64EncodeBE::encode(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBEUrlSafe::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 816> {\n    Base64EncodeBE::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_url_safe_var(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBEUrlSafe::encode_var(input)\n}\n\n#[export]\nfn bench_encode_610_no_pad(input: [u8; 610]) -> [u8; 814] {\n    Base64EncodeBENoPad::encode(input)\n}\n\n#[export]\nfn bench_encode_610_var_no_pad(input: BoundedVec<u8, 610>) -> BoundedVec<u8, 814> {\n    Base64EncodeBENoPad::encode_var(input)\n}\n\n#[export]\nfn bench_decode_610(input: [u8; 816]) -> [u8; 610] {\n    (Base64DecodeBE::decode(input))\n}\n\n#[export]\nfn bench_decode_610_var(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBE::decode_var(input));\n    r\n}\n\n#[export]\nfn bench_decode_610_no_pad(input: [[u8; 816]; 3]) -> [[u8; 610]; 3] {\n    let mut r: [[u8; 610]; 3] = [[0; 610]; 3];\n    for i in 0..3 {\n        r[i] = (Base64DecodeBENoPad::decode(input[i]));\n    }\n    r\n}\n\n#[export]\nfn bench_decode_610_var_no_pad(input: BoundedVec<u8, 816>) -> BoundedVec<u8, 610> {\n    let r = (Base64DecodeBENoPad::decode_var(input));\n    r\n}\n\n","path":"/Users/zac/noir_base64/src/benchmarks/mod.nr"}},"names":["bench_encode_610_var_no_pad"],"brillig_names":["__boundary_check","directive_to_radix","directive_integer_quotient"]}